"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swiper";
exports.ids = ["vendor-chunks/swiper"];
exports.modules = {

/***/ "(rsc)/./node_modules/swiper/modules/effect-coverflow.css":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/effect-coverflow.css ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"da39a3ee5e6b\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZWZmZWN0LWNvdmVyZmxvdy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5mby1uZXh0Ly4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL2VmZmVjdC1jb3ZlcmZsb3cuY3NzPzNhYzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYTM5YTNlZTVlNmJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swiper/modules/effect-coverflow.css\n");

/***/ }),

/***/ "(rsc)/./node_modules/swiper/modules/effect-creative.css":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/modules/effect-creative.css ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"4faa4a03d737\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZWZmZWN0LWNyZWF0aXZlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmZvLW5leHQvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZWZmZWN0LWNyZWF0aXZlLmNzcz82ZTUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNGZhYTRhMDNkNzM3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swiper/modules/effect-creative.css\n");

/***/ }),

/***/ "(rsc)/./node_modules/swiper/modules/free-mode.css":
/*!***************************************************!*\
  !*** ./node_modules/swiper/modules/free-mode.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"a6bec9b69ea6\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZnJlZS1tb2RlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmZvLW5leHQvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZnJlZS1tb2RlLmNzcz83MzUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYTZiZWM5YjY5ZWE2XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swiper/modules/free-mode.css\n");

/***/ }),

/***/ "(rsc)/./node_modules/swiper/modules/pagination.css":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/pagination.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"bcdc1be3afcf\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvcGFnaW5hdGlvbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5mby1uZXh0Ly4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3BhZ2luYXRpb24uY3NzPzZhNTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJiY2RjMWJlM2FmY2ZcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swiper/modules/pagination.css\n");

/***/ }),

/***/ "(rsc)/./node_modules/swiper/swiper.css":
/*!****************************************!*\
  !*** ./node_modules/swiper/swiper.css ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"789b5e46b2d9\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5mby1uZXh0Ly4vbm9kZV9tb2R1bGVzL3N3aXBlci9zd2lwZXIuY3NzPzQxMTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI3ODliNWU0NmIyZDlcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/swiper/swiper.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/shared/ssr-window.esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getWindow),\n/* harmony export */   g: () => (/* binding */ getDocument)\n/* harmony export */ });\n/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */ /* eslint-disable no-param-reassign */ function isObject(obj) {\n    return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n}\nfunction extend(target, src) {\n    if (target === void 0) {\n        target = {};\n    }\n    if (src === void 0) {\n        src = {};\n    }\n    Object.keys(src).forEach((key)=>{\n        if (typeof target[key] === \"undefined\") target[key] = src[key];\n        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\nconst ssrDocument = {\n    body: {},\n    addEventListener () {},\n    removeEventListener () {},\n    activeElement: {\n        blur () {},\n        nodeName: \"\"\n    },\n    querySelector () {\n        return null;\n    },\n    querySelectorAll () {\n        return [];\n    },\n    getElementById () {\n        return null;\n    },\n    createEvent () {\n        return {\n            initEvent () {}\n        };\n    },\n    createElement () {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute () {},\n            getElementsByTagName () {\n                return [];\n            }\n        };\n    },\n    createElementNS () {\n        return {};\n    },\n    importNode () {\n        return null;\n    },\n    location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n    }\n};\nfunction getDocument() {\n    const doc = typeof document !== \"undefined\" ? document : {};\n    extend(doc, ssrDocument);\n    return doc;\n}\nconst ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: \"\"\n    },\n    location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n    },\n    history: {\n        replaceState () {},\n        pushState () {},\n        go () {},\n        back () {}\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener () {},\n    removeEventListener () {},\n    getComputedStyle () {\n        return {\n            getPropertyValue () {\n                return \"\";\n            }\n        };\n    },\n    Image () {},\n    Date () {},\n    screen: {},\n    setTimeout () {},\n    clearTimeout () {},\n    matchMedia () {\n        return {};\n    },\n    requestAnimationFrame (callback) {\n        if (typeof setTimeout === \"undefined\") {\n            callback();\n            return null;\n        }\n        return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame (id) {\n        if (typeof setTimeout === \"undefined\") {\n            return;\n        }\n        clearTimeout(id);\n    }\n};\nfunction getWindow() {\n    const win =  false ? 0 : {};\n    extend(win, ssrWindow);\n    return win;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ0Qsb0NBQW9DLEdBQ3BDLFNBQVNBLFNBQVNDLEdBQUc7SUFDbkIsT0FBT0EsUUFBUSxRQUFRLE9BQU9BLFFBQVEsWUFBWSxpQkFBaUJBLE9BQU9BLElBQUlDLFdBQVcsS0FBS0M7QUFDaEc7QUFDQSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVDLEdBQUc7SUFDekIsSUFBSUQsV0FBVyxLQUFLLEdBQUc7UUFDckJBLFNBQVMsQ0FBQztJQUNaO0lBQ0EsSUFBSUMsUUFBUSxLQUFLLEdBQUc7UUFDbEJBLE1BQU0sQ0FBQztJQUNUO0lBQ0FILE9BQU9JLElBQUksQ0FBQ0QsS0FBS0UsT0FBTyxDQUFDQyxDQUFBQTtRQUN2QixJQUFJLE9BQU9KLE1BQU0sQ0FBQ0ksSUFBSSxLQUFLLGFBQWFKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHSCxHQUFHLENBQUNHLElBQUk7YUFBTSxJQUFJVCxTQUFTTSxHQUFHLENBQUNHLElBQUksS0FBS1QsU0FBU0ssTUFBTSxDQUFDSSxJQUFJLEtBQUtOLE9BQU9JLElBQUksQ0FBQ0QsR0FBRyxDQUFDRyxJQUFJLEVBQUVDLE1BQU0sR0FBRyxHQUFHO1lBQ3ZKTixPQUFPQyxNQUFNLENBQUNJLElBQUksRUFBRUgsR0FBRyxDQUFDRyxJQUFJO1FBQzlCO0lBQ0Y7QUFDRjtBQUNBLE1BQU1FLGNBQWM7SUFDbEJDLE1BQU0sQ0FBQztJQUNQQyxxQkFBb0I7SUFDcEJDLHdCQUF1QjtJQUN2QkMsZUFBZTtRQUNiQyxTQUFRO1FBQ1JDLFVBQVU7SUFDWjtJQUNBQztRQUNFLE9BQU87SUFDVDtJQUNBQztRQUNFLE9BQU8sRUFBRTtJQUNYO0lBQ0FDO1FBQ0UsT0FBTztJQUNUO0lBQ0FDO1FBQ0UsT0FBTztZQUNMQyxjQUFhO1FBQ2Y7SUFDRjtJQUNBQztRQUNFLE9BQU87WUFDTEMsVUFBVSxFQUFFO1lBQ1pDLFlBQVksRUFBRTtZQUNkQyxPQUFPLENBQUM7WUFDUkMsaUJBQWdCO1lBQ2hCQztnQkFDRSxPQUFPLEVBQUU7WUFDWDtRQUNGO0lBQ0Y7SUFDQUM7UUFDRSxPQUFPLENBQUM7SUFDVjtJQUNBQztRQUNFLE9BQU87SUFDVDtJQUNBQyxVQUFVO1FBQ1JDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE1BQU1DLE1BQU0sT0FBT0MsYUFBYSxjQUFjQSxXQUFXLENBQUM7SUFDMUR0QyxPQUFPcUMsS0FBSzlCO0lBQ1osT0FBTzhCO0FBQ1Q7QUFDQSxNQUFNRSxZQUFZO0lBQ2hCRCxVQUFVL0I7SUFDVmlDLFdBQVc7UUFDVEMsV0FBVztJQUNiO0lBQ0FkLFVBQVU7UUFDUkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxRQUFRO0lBQ1Y7SUFDQU8sU0FBUztRQUNQQyxpQkFBZ0I7UUFDaEJDLGNBQWE7UUFDYkMsT0FBTTtRQUNOQyxTQUFRO0lBQ1Y7SUFDQUMsYUFBYSxTQUFTQTtRQUNwQixPQUFPLElBQUk7SUFDYjtJQUNBdEMscUJBQW9CO0lBQ3BCQyx3QkFBdUI7SUFDdkJzQztRQUNFLE9BQU87WUFDTEM7Z0JBQ0UsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBQyxVQUFTO0lBQ1RDLFNBQVE7SUFDUkMsUUFBUSxDQUFDO0lBQ1RDLGVBQWM7SUFDZEMsaUJBQWdCO0lBQ2hCQztRQUNFLE9BQU8sQ0FBQztJQUNWO0lBQ0FDLHVCQUFzQkMsUUFBUTtRQUM1QixJQUFJLE9BQU9KLGVBQWUsYUFBYTtZQUNyQ0k7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPSixXQUFXSSxVQUFVO0lBQzlCO0lBQ0FDLHNCQUFxQkMsRUFBRTtRQUNyQixJQUFJLE9BQU9OLGVBQWUsYUFBYTtZQUNyQztRQUNGO1FBQ0FDLGFBQWFLO0lBQ2Y7QUFDRjtBQUNBLFNBQVNDO0lBQ1AsTUFBTUMsTUFBTSxNQUFrQixHQUFjQyxDQUFNQSxHQUFHLENBQUM7SUFDdEQ5RCxPQUFPNkQsS0FBS3RCO0lBQ1osT0FBT3NCO0FBQ1Q7QUFFNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5mby1uZXh0Ly4vbm9kZV9tb2R1bGVzL3N3aXBlci9zaGFyZWQvc3NyLXdpbmRvdy5lc20ubWpzP2U3ODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTU1IgV2luZG93IDQuMC4yXG4gKiBCZXR0ZXIgaGFuZGxpbmcgZm9yIHdpbmRvdyBvYmplY3QgaW4gU1NSIGVudmlyb25tZW50XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9saW1pdHM0d2ViL3Nzci13aW5kb3dcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMSwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqXG4gKiBSZWxlYXNlZCBvbjogRGVjZW1iZXIgMTMsIDIwMjFcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICdjb25zdHJ1Y3RvcicgaW4gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc3JjKSB7XG4gIGlmICh0YXJnZXQgPT09IHZvaWQgMCkge1xuICAgIHRhcmdldCA9IHt9O1xuICB9XG4gIGlmIChzcmMgPT09IHZvaWQgMCkge1xuICAgIHNyYyA9IHt9O1xuICB9XG4gIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICd1bmRlZmluZWQnKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO2Vsc2UgaWYgKGlzT2JqZWN0KHNyY1trZXldKSAmJiBpc09iamVjdCh0YXJnZXRba2V5XSkgJiYgT2JqZWN0LmtleXMoc3JjW2tleV0pLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4dGVuZCh0YXJnZXRba2V5XSwgc3JjW2tleV0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBzc3JEb2N1bWVudCA9IHtcbiAgYm9keToge30sXG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LFxuICBhY3RpdmVFbGVtZW50OiB7XG4gICAgYmx1cigpIHt9LFxuICAgIG5vZGVOYW1lOiAnJ1xuICB9LFxuICBxdWVyeVNlbGVjdG9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBxdWVyeVNlbGVjdG9yQWxsKCkge1xuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgZ2V0RWxlbWVudEJ5SWQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGNyZWF0ZUV2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbml0RXZlbnQoKSB7fVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgc3R5bGU6IHt9LFxuICAgICAgc2V0QXR0cmlidXRlKCkge30sXG4gICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnROUygpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIGltcG9ydE5vZGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGxvY2F0aW9uOiB7XG4gICAgaGFzaDogJycsXG4gICAgaG9zdDogJycsXG4gICAgaG9zdG5hbWU6ICcnLFxuICAgIGhyZWY6ICcnLFxuICAgIG9yaWdpbjogJycsXG4gICAgcGF0aG5hbWU6ICcnLFxuICAgIHByb3RvY29sOiAnJyxcbiAgICBzZWFyY2g6ICcnXG4gIH1cbn07XG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge307XG4gIGV4dGVuZChkb2MsIHNzckRvY3VtZW50KTtcbiAgcmV0dXJuIGRvYztcbn1cbmNvbnN0IHNzcldpbmRvdyA9IHtcbiAgZG9jdW1lbnQ6IHNzckRvY3VtZW50LFxuICBuYXZpZ2F0b3I6IHtcbiAgICB1c2VyQWdlbnQ6ICcnXG4gIH0sXG4gIGxvY2F0aW9uOiB7XG4gICAgaGFzaDogJycsXG4gICAgaG9zdDogJycsXG4gICAgaG9zdG5hbWU6ICcnLFxuICAgIGhyZWY6ICcnLFxuICAgIG9yaWdpbjogJycsXG4gICAgcGF0aG5hbWU6ICcnLFxuICAgIHByb3RvY29sOiAnJyxcbiAgICBzZWFyY2g6ICcnXG4gIH0sXG4gIGhpc3Rvcnk6IHtcbiAgICByZXBsYWNlU3RhdGUoKSB7fSxcbiAgICBwdXNoU3RhdGUoKSB7fSxcbiAgICBnbygpIHt9LFxuICAgIGJhY2soKSB7fVxuICB9LFxuICBDdXN0b21FdmVudDogZnVuY3Rpb24gQ3VzdG9tRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LFxuICBnZXRDb21wdXRlZFN0eWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQcm9wZXJ0eVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgSW1hZ2UoKSB7fSxcbiAgRGF0ZSgpIHt9LFxuICBzY3JlZW46IHt9LFxuICBzZXRUaW1lb3V0KCkge30sXG4gIGNsZWFyVGltZW91dCgpIHt9LFxuICBtYXRjaE1lZGlhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH0sXG4gIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoaWQpO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuICBleHRlbmQod2luLCBzc3JXaW5kb3cpO1xuICByZXR1cm4gd2luO1xufVxuXG5leHBvcnQgeyBnZXRXaW5kb3cgYXMgYSwgZ2V0RG9jdW1lbnQgYXMgZyB9O1xuIl0sIm5hbWVzIjpbImlzT2JqZWN0Iiwib2JqIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJleHRlbmQiLCJ0YXJnZXQiLCJzcmMiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImxlbmd0aCIsInNzckRvY3VtZW50IiwiYm9keSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJub2RlTmFtZSIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImNyZWF0ZUVsZW1lbnQiLCJjaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJzdHlsZSIsInNldEF0dHJpYnV0ZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiY3JlYXRlRWxlbWVudE5TIiwiaW1wb3J0Tm9kZSIsImxvY2F0aW9uIiwiaGFzaCIsImhvc3QiLCJob3N0bmFtZSIsImhyZWYiLCJvcmlnaW4iLCJwYXRobmFtZSIsInByb3RvY29sIiwic2VhcmNoIiwiZ2V0RG9jdW1lbnQiLCJkb2MiLCJkb2N1bWVudCIsInNzcldpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJwdXNoU3RhdGUiLCJnbyIsImJhY2siLCJDdXN0b21FdmVudCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiSW1hZ2UiLCJEYXRlIiwic2NyZWVuIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsIm1hdGNoTWVkaWEiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaWQiLCJnZXRXaW5kb3ciLCJ3aW4iLCJ3aW5kb3ciLCJhIiwiZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/swiper-core.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/shared/swiper-core.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ Swiper),\n/* harmony export */   d: () => (/* binding */ defaults)\n/* harmony export */ });\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/swiper/shared/utils.mjs\");\n\n\nlet support;\nfunction calcSupport() {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    return {\n        smoothScroll: document1.documentElement && document1.documentElement.style && \"scrollBehavior\" in document1.documentElement.style,\n        touch: !!(\"ontouchstart\" in window1 || window1.DocumentTouch && document1 instanceof window1.DocumentTouch)\n    };\n}\nfunction getSupport() {\n    if (!support) {\n        support = calcSupport();\n    }\n    return support;\n}\nlet deviceCached;\nfunction calcDevice(_temp) {\n    let { userAgent } = _temp === void 0 ? {} : _temp;\n    const support = getSupport();\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const platform = window1.navigator.platform;\n    const ua = userAgent || window1.navigator.userAgent;\n    const device = {\n        ios: false,\n        android: false\n    };\n    const screenWidth = window1.screen.width;\n    const screenHeight = window1.screen.height;\n    const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n    let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n    const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n    const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n    const windows = platform === \"Win32\";\n    let macos = platform === \"MacIntel\";\n    // iPadOs 13 fix\n    const iPadScreens = [\n        \"1024x1366\",\n        \"1366x1024\",\n        \"834x1194\",\n        \"1194x834\",\n        \"834x1112\",\n        \"1112x834\",\n        \"768x1024\",\n        \"1024x768\",\n        \"820x1180\",\n        \"1180x820\",\n        \"810x1080\",\n        \"1080x810\"\n    ];\n    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n        ipad = ua.match(/(Version)\\/([\\d.]+)/);\n        if (!ipad) ipad = [\n            0,\n            1,\n            \"13_0_0\"\n        ];\n        macos = false;\n    }\n    // Android\n    if (android && !windows) {\n        device.os = \"android\";\n        device.android = true;\n    }\n    if (ipad || iphone || ipod) {\n        device.os = \"ios\";\n        device.ios = true;\n    }\n    // Export object\n    return device;\n}\nfunction getDevice(overrides) {\n    if (overrides === void 0) {\n        overrides = {};\n    }\n    if (!deviceCached) {\n        deviceCached = calcDevice(overrides);\n    }\n    return deviceCached;\n}\nlet browser;\nfunction calcBrowser() {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const device = getDevice();\n    let needPerspectiveFix = false;\n    function isSafari() {\n        const ua = window1.navigator.userAgent.toLowerCase();\n        return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n    }\n    if (isSafari()) {\n        const ua = String(window1.navigator.userAgent);\n        if (ua.includes(\"Version/\")) {\n            const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num)=>Number(num));\n            needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n        }\n    }\n    const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window1.navigator.userAgent);\n    const isSafariBrowser = isSafari();\n    const need3dFix = isSafariBrowser || isWebView && device.ios;\n    return {\n        isSafari: needPerspectiveFix || isSafariBrowser,\n        needPerspectiveFix,\n        need3dFix,\n        isWebView\n    };\n}\nfunction getBrowser() {\n    if (!browser) {\n        browser = calcBrowser();\n    }\n    return browser;\n}\nfunction Resize(_ref) {\n    let { swiper, on, emit } = _ref;\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    let observer = null;\n    let animationFrame = null;\n    const resizeHandler = ()=>{\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"beforeResize\");\n        emit(\"resize\");\n    };\n    const createObserver = ()=>{\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        observer = new ResizeObserver((entries)=>{\n            animationFrame = window1.requestAnimationFrame(()=>{\n                const { width, height } = swiper;\n                let newWidth = width;\n                let newHeight = height;\n                entries.forEach((_ref2)=>{\n                    let { contentBoxSize, contentRect, target } = _ref2;\n                    if (target && target !== swiper.el) return;\n                    newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                    newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                });\n                if (newWidth !== width || newHeight !== height) {\n                    resizeHandler();\n                }\n            });\n        });\n        observer.observe(swiper.el);\n    };\n    const removeObserver = ()=>{\n        if (animationFrame) {\n            window1.cancelAnimationFrame(animationFrame);\n        }\n        if (observer && observer.unobserve && swiper.el) {\n            observer.unobserve(swiper.el);\n            observer = null;\n        }\n    };\n    const orientationChangeHandler = ()=>{\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"orientationchange\");\n    };\n    on(\"init\", ()=>{\n        if (swiper.params.resizeObserver && typeof window1.ResizeObserver !== \"undefined\") {\n            createObserver();\n            return;\n        }\n        window1.addEventListener(\"resize\", resizeHandler);\n        window1.addEventListener(\"orientationchange\", orientationChangeHandler);\n    });\n    on(\"destroy\", ()=>{\n        removeObserver();\n        window1.removeEventListener(\"resize\", resizeHandler);\n        window1.removeEventListener(\"orientationchange\", orientationChangeHandler);\n    });\n}\nfunction Observer(_ref) {\n    let { swiper, extendParams, on, emit } = _ref;\n    const observers = [];\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const attach = function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        const ObserverFunc = window1.MutationObserver || window1.WebkitMutationObserver;\n        const observer = new ObserverFunc((mutations)=>{\n            // The observerUpdate event should only be triggered\n            // once despite the number of mutations.  Additional\n            // triggers are redundant and are very costly\n            if (swiper.__preventObserver__) return;\n            if (mutations.length === 1) {\n                emit(\"observerUpdate\", mutations[0]);\n                return;\n            }\n            const observerUpdate = function observerUpdate() {\n                emit(\"observerUpdate\", mutations[0]);\n            };\n            if (window1.requestAnimationFrame) {\n                window1.requestAnimationFrame(observerUpdate);\n            } else {\n                window1.setTimeout(observerUpdate, 0);\n            }\n        });\n        observer.observe(target, {\n            attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n            childList: typeof options.childList === \"undefined\" ? true : options.childList,\n            characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n        });\n        observers.push(observer);\n    };\n    const init = ()=>{\n        if (!swiper.params.observer) return;\n        if (swiper.params.observeParents) {\n            const containerParents = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.hostEl);\n            for(let i = 0; i < containerParents.length; i += 1){\n                attach(containerParents[i]);\n            }\n        }\n        // Observe container\n        attach(swiper.hostEl, {\n            childList: swiper.params.observeSlideChildren\n        });\n        // Observe wrapper\n        attach(swiper.wrapperEl, {\n            attributes: false\n        });\n    };\n    const destroy = ()=>{\n        observers.forEach((observer)=>{\n            observer.disconnect();\n        });\n        observers.splice(0, observers.length);\n    };\n    extendParams({\n        observer: false,\n        observeParents: false,\n        observeSlideChildren: false\n    });\n    on(\"init\", init);\n    on(\"destroy\", destroy);\n}\n/* eslint-disable no-underscore-dangle */ var eventsEmitter = {\n    on (events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        const method = priority ? \"unshift\" : \"push\";\n        events.split(\" \").forEach((event)=>{\n            if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n            self.eventsListeners[event][method](handler);\n        });\n        return self;\n    },\n    once (events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        function onceHandler() {\n            self.off(events, onceHandler);\n            if (onceHandler.__emitterProxy) {\n                delete onceHandler.__emitterProxy;\n            }\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            handler.apply(self, args);\n        }\n        onceHandler.__emitterProxy = handler;\n        return self.on(events, onceHandler, priority);\n    },\n    onAny (handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        const method = priority ? \"unshift\" : \"push\";\n        if (self.eventsAnyListeners.indexOf(handler) < 0) {\n            self.eventsAnyListeners[method](handler);\n        }\n        return self;\n    },\n    offAny (handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsAnyListeners) return self;\n        const index = self.eventsAnyListeners.indexOf(handler);\n        if (index >= 0) {\n            self.eventsAnyListeners.splice(index, 1);\n        }\n        return self;\n    },\n    off (events, handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        events.split(\" \").forEach((event)=>{\n            if (typeof handler === \"undefined\") {\n                self.eventsListeners[event] = [];\n            } else if (self.eventsListeners[event]) {\n                self.eventsListeners[event].forEach((eventHandler, index)=>{\n                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n                        self.eventsListeners[event].splice(index, 1);\n                    }\n                });\n            }\n        });\n        return self;\n    },\n    emit () {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        let events;\n        let data;\n        let context;\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n            events = args[0];\n            data = args.slice(1, args.length);\n            context = self;\n        } else {\n            events = args[0].events;\n            data = args[0].data;\n            context = args[0].context || self;\n        }\n        data.unshift(context);\n        const eventsArray = Array.isArray(events) ? events : events.split(\" \");\n        eventsArray.forEach((event)=>{\n            if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n                self.eventsAnyListeners.forEach((eventHandler)=>{\n                    eventHandler.apply(context, [\n                        event,\n                        ...data\n                    ]);\n                });\n            }\n            if (self.eventsListeners && self.eventsListeners[event]) {\n                self.eventsListeners[event].forEach((eventHandler)=>{\n                    eventHandler.apply(context, data);\n                });\n            }\n        });\n        return self;\n    }\n};\nfunction updateSize() {\n    const swiper = this;\n    let width;\n    let height;\n    const el = swiper.el;\n    if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) {\n        width = swiper.params.width;\n    } else {\n        width = el.clientWidth;\n    }\n    if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) {\n        height = swiper.params.height;\n    } else {\n        height = el.clientHeight;\n    }\n    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n        return;\n    }\n    // Subtract paddings\n    width = width - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-left\") || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-right\") || 0, 10);\n    height = height - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-top\") || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-bottom\") || 0, 10);\n    if (Number.isNaN(width)) width = 0;\n    if (Number.isNaN(height)) height = 0;\n    Object.assign(swiper, {\n        width,\n        height,\n        size: swiper.isHorizontal() ? width : height\n    });\n}\nfunction updateSlides() {\n    const swiper = this;\n    function getDirectionPropertyValue(node, label) {\n        return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n    }\n    const params = swiper.params;\n    const { wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n    const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n    let snapGrid = [];\n    const slidesGrid = [];\n    const slidesSizesGrid = [];\n    let offsetBefore = params.slidesOffsetBefore;\n    if (typeof offsetBefore === \"function\") {\n        offsetBefore = params.slidesOffsetBefore.call(swiper);\n    }\n    let offsetAfter = params.slidesOffsetAfter;\n    if (typeof offsetAfter === \"function\") {\n        offsetAfter = params.slidesOffsetAfter.call(swiper);\n    }\n    const previousSnapGridLength = swiper.snapGrid.length;\n    const previousSlidesGridLength = swiper.slidesGrid.length;\n    let spaceBetween = params.spaceBetween;\n    let slidePosition = -offsetBefore;\n    let prevSlideSize = 0;\n    let index = 0;\n    if (typeof swiperSize === \"undefined\") {\n        return;\n    }\n    if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n    } else if (typeof spaceBetween === \"string\") {\n        spaceBetween = parseFloat(spaceBetween);\n    }\n    swiper.virtualSize = -spaceBetween;\n    // reset margins\n    slides.forEach((slideEl)=>{\n        if (rtl) {\n            slideEl.style.marginLeft = \"\";\n        } else {\n            slideEl.style.marginRight = \"\";\n        }\n        slideEl.style.marginBottom = \"\";\n        slideEl.style.marginTop = \"\";\n    });\n    // reset cssMode offsets\n    if (params.centeredSlides && params.cssMode) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n    }\n    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n    if (gridEnabled) {\n        swiper.grid.initSlides(slides);\n    } else if (swiper.grid) {\n        swiper.grid.unsetSlides();\n    }\n    // Calc slides\n    let slideSize;\n    const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key)=>{\n        return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n    }).length > 0;\n    for(let i = 0; i < slidesLength; i += 1){\n        slideSize = 0;\n        let slide;\n        if (slides[i]) slide = slides[i];\n        if (gridEnabled) {\n            swiper.grid.updateSlide(i, slide, slides);\n        }\n        if (slides[i] && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(slide, \"display\") === \"none\") continue; // eslint-disable-line\n        if (params.slidesPerView === \"auto\") {\n            if (shouldResetSlideSize) {\n                slides[i].style[swiper.getDirectionLabel(\"width\")] = ``;\n            }\n            const slideStyles = getComputedStyle(slide);\n            const currentTransform = slide.style.transform;\n            const currentWebKitTransform = slide.style.webkitTransform;\n            if (currentTransform) {\n                slide.style.transform = \"none\";\n            }\n            if (currentWebKitTransform) {\n                slide.style.webkitTransform = \"none\";\n            }\n            if (params.roundLengths) {\n                slideSize = swiper.isHorizontal() ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, \"width\", true) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, \"height\", true);\n            } else {\n                // eslint-disable-next-line\n                const width = getDirectionPropertyValue(slideStyles, \"width\");\n                const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n                const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n                const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n                const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n                const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n                if (boxSizing && boxSizing === \"border-box\") {\n                    slideSize = width + marginLeft + marginRight;\n                } else {\n                    const { clientWidth, offsetWidth } = slide;\n                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                }\n            }\n            if (currentTransform) {\n                slide.style.transform = currentTransform;\n            }\n            if (currentWebKitTransform) {\n                slide.style.webkitTransform = currentWebKitTransform;\n            }\n            if (params.roundLengths) slideSize = Math.floor(slideSize);\n        } else {\n            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n            if (params.roundLengths) slideSize = Math.floor(slideSize);\n            if (slides[i]) {\n                slides[i].style[swiper.getDirectionLabel(\"width\")] = `${slideSize}px`;\n            }\n        }\n        if (slides[i]) {\n            slides[i].swiperSlideSize = slideSize;\n        }\n        slidesSizesGrid.push(slideSize);\n        if (params.centeredSlides) {\n            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n            if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n            if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n            if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n            if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n            if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n            slidesGrid.push(slidePosition);\n        } else {\n            if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n            if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n            slidesGrid.push(slidePosition);\n            slidePosition = slidePosition + slideSize + spaceBetween;\n        }\n        swiper.virtualSize += slideSize + spaceBetween;\n        prevSlideSize = slideSize;\n        index += 1;\n    }\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n    if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) {\n        wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (params.setWrapperSize) {\n        wrapperEl.style[swiper.getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (gridEnabled) {\n        swiper.grid.updateWrapperSize(slideSize, snapGrid);\n    }\n    // Remove last grid elements depending on width\n    if (!params.centeredSlides) {\n        const newSlidesGrid = [];\n        for(let i = 0; i < snapGrid.length; i += 1){\n            let slidesGridItem = snapGrid[i];\n            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n            if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n                newSlidesGrid.push(slidesGridItem);\n            }\n        }\n        snapGrid = newSlidesGrid;\n        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n            snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n    }\n    if (isVirtual && params.loop) {\n        const size = slidesSizesGrid[0] + spaceBetween;\n        if (params.slidesPerGroup > 1) {\n            const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n            const groupSize = size * params.slidesPerGroup;\n            for(let i = 0; i < groups; i += 1){\n                snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n            }\n        }\n        for(let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1){\n            if (params.slidesPerGroup === 1) {\n                snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n            }\n            slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n            swiper.virtualSize += size;\n        }\n    }\n    if (snapGrid.length === 0) snapGrid = [\n        0\n    ];\n    if (spaceBetween !== 0) {\n        const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : swiper.getDirectionLabel(\"marginRight\");\n        slides.filter((_, slideIndex)=>{\n            if (!params.cssMode || params.loop) return true;\n            if (slideIndex === slides.length - 1) {\n                return false;\n            }\n            return true;\n        }).forEach((slideEl)=>{\n            slideEl.style[key] = `${spaceBetween}px`;\n        });\n    }\n    if (params.centeredSlides && params.centeredSlidesBounds) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue)=>{\n            allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        const maxSnap = allSlidesSize - swiperSize;\n        snapGrid = snapGrid.map((snap)=>{\n            if (snap <= 0) return -offsetBefore;\n            if (snap > maxSnap) return maxSnap + offsetAfter;\n            return snap;\n        });\n    }\n    if (params.centerInsufficientSlides) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue)=>{\n            allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        if (allSlidesSize < swiperSize) {\n            const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n            snapGrid.forEach((snap, snapIndex)=>{\n                snapGrid[snapIndex] = snap - allSlidesOffset;\n            });\n            slidesGrid.forEach((snap, snapIndex)=>{\n                slidesGrid[snapIndex] = snap + allSlidesOffset;\n            });\n        }\n    }\n    Object.assign(swiper, {\n        slides,\n        snapGrid,\n        slidesGrid,\n        slidesSizesGrid\n    });\n    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n        const addToSnapGrid = -swiper.snapGrid[0];\n        const addToSlidesGrid = -swiper.slidesGrid[0];\n        swiper.snapGrid = swiper.snapGrid.map((v)=>v + addToSnapGrid);\n        swiper.slidesGrid = swiper.slidesGrid.map((v)=>v + addToSlidesGrid);\n    }\n    if (slidesLength !== previousSlidesLength) {\n        swiper.emit(\"slidesLengthChange\");\n    }\n    if (snapGrid.length !== previousSnapGridLength) {\n        if (swiper.params.watchOverflow) swiper.checkOverflow();\n        swiper.emit(\"snapGridLengthChange\");\n    }\n    if (slidesGrid.length !== previousSlidesGridLength) {\n        swiper.emit(\"slidesGridLengthChange\");\n    }\n    if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n    }\n    swiper.emit(\"slidesUpdated\");\n    if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n        if (slidesLength <= params.maxBackfaceHiddenSlides) {\n            if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n        } else if (hasClassBackfaceClassAdded) {\n            swiper.el.classList.remove(backFaceHiddenClass);\n        }\n    }\n}\nfunction updateAutoHeight(speed) {\n    const swiper = this;\n    const activeSlides = [];\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let newHeight = 0;\n    let i;\n    if (typeof speed === \"number\") {\n        swiper.setTransition(speed);\n    } else if (speed === true) {\n        swiper.setTransition(swiper.params.speed);\n    }\n    const getSlideByIndex = (index)=>{\n        if (isVirtual) {\n            return swiper.slides[swiper.getSlideIndexByData(index)];\n        }\n        return swiper.slides[index];\n    };\n    // Find slides currently in view\n    if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n        if (swiper.params.centeredSlides) {\n            (swiper.visibleSlides || []).forEach((slide)=>{\n                activeSlides.push(slide);\n            });\n        } else {\n            for(i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1){\n                const index = swiper.activeIndex + i;\n                if (index > swiper.slides.length && !isVirtual) break;\n                activeSlides.push(getSlideByIndex(index));\n            }\n        }\n    } else {\n        activeSlides.push(getSlideByIndex(swiper.activeIndex));\n    }\n    // Find new height from highest slide in view\n    for(i = 0; i < activeSlides.length; i += 1){\n        if (typeof activeSlides[i] !== \"undefined\") {\n            const height = activeSlides[i].offsetHeight;\n            newHeight = height > newHeight ? height : newHeight;\n        }\n    }\n    // Update Height\n    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n}\nfunction updateSlidesOffset() {\n    const swiper = this;\n    const slides = swiper.slides;\n    // eslint-disable-next-line\n    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n    for(let i = 0; i < slides.length; i += 1){\n        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n}\nfunction updateSlidesProgress(translate) {\n    if (translate === void 0) {\n        translate = this && this.translate || 0;\n    }\n    const swiper = this;\n    const params = swiper.params;\n    const { slides, rtlTranslate: rtl, snapGrid } = swiper;\n    if (slides.length === 0) return;\n    if (typeof slides[0].swiperSlideOffset === \"undefined\") swiper.updateSlidesOffset();\n    let offsetCenter = -translate;\n    if (rtl) offsetCenter = translate;\n    // Visible Slides\n    slides.forEach((slideEl)=>{\n        slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass);\n    });\n    swiper.visibleSlidesIndexes = [];\n    swiper.visibleSlides = [];\n    let spaceBetween = params.spaceBetween;\n    if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n    } else if (typeof spaceBetween === \"string\") {\n        spaceBetween = parseFloat(spaceBetween);\n    }\n    for(let i = 0; i < slides.length; i += 1){\n        const slide = slides[i];\n        let slideOffset = slide.swiperSlideOffset;\n        if (params.cssMode && params.centeredSlides) {\n            slideOffset -= slides[0].swiperSlideOffset;\n        }\n        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const slideBefore = -(offsetCenter - slideOffset);\n        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n        const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n        if (isVisible) {\n            swiper.visibleSlides.push(slide);\n            swiper.visibleSlidesIndexes.push(i);\n            slides[i].classList.add(params.slideVisibleClass);\n        }\n        if (isFullyVisible) {\n            slides[i].classList.add(params.slideFullyVisibleClass);\n        }\n        slide.progress = rtl ? -slideProgress : slideProgress;\n        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n    }\n}\nfunction updateProgress(translate) {\n    const swiper = this;\n    if (typeof translate === \"undefined\") {\n        const multiplier = swiper.rtlTranslate ? -1 : 1;\n        // eslint-disable-next-line\n        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n    }\n    const params = swiper.params;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    let { progress, isBeginning, isEnd, progressLoop } = swiper;\n    const wasBeginning = isBeginning;\n    const wasEnd = isEnd;\n    if (translatesDiff === 0) {\n        progress = 0;\n        isBeginning = true;\n        isEnd = true;\n    } else {\n        progress = (translate - swiper.minTranslate()) / translatesDiff;\n        const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n        const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n        isBeginning = isBeginningRounded || progress <= 0;\n        isEnd = isEndRounded || progress >= 1;\n        if (isBeginningRounded) progress = 0;\n        if (isEndRounded) progress = 1;\n    }\n    if (params.loop) {\n        const firstSlideIndex = swiper.getSlideIndexByData(0);\n        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n        const translateAbs = Math.abs(translate);\n        if (translateAbs >= firstSlideTranslate) {\n            progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n        } else {\n            progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n        }\n        if (progressLoop > 1) progressLoop -= 1;\n    }\n    Object.assign(swiper, {\n        progress,\n        progressLoop,\n        isBeginning,\n        isEnd\n    });\n    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n    if (isBeginning && !wasBeginning) {\n        swiper.emit(\"reachBeginning toEdge\");\n    }\n    if (isEnd && !wasEnd) {\n        swiper.emit(\"reachEnd toEdge\");\n    }\n    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n        swiper.emit(\"fromEdge\");\n    }\n    swiper.emit(\"progress\", progress);\n}\nconst toggleSlideClasses = (slideEl, condition, className)=>{\n    if (condition && !slideEl.classList.contains(className)) {\n        slideEl.classList.add(className);\n    } else if (!condition && slideEl.classList.contains(className)) {\n        slideEl.classList.remove(className);\n    }\n};\nfunction updateSlidesClasses() {\n    const swiper = this;\n    const { slides, params, slidesEl, activeIndex } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    const getFilteredSlide = (selector)=>{\n        return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n    };\n    let activeSlide;\n    let prevSlide;\n    let nextSlide;\n    if (isVirtual) {\n        if (params.loop) {\n            let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n            if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n            if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n            activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n        } else {\n            activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        }\n    } else {\n        if (gridEnabled) {\n            activeSlide = slides.filter((slideEl)=>slideEl.column === activeIndex)[0];\n            nextSlide = slides.filter((slideEl)=>slideEl.column === activeIndex + 1)[0];\n            prevSlide = slides.filter((slideEl)=>slideEl.column === activeIndex - 1)[0];\n        } else {\n            activeSlide = slides[activeIndex];\n        }\n    }\n    if (activeSlide) {\n        if (!gridEnabled) {\n            // Next Slide\n            nextSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            if (params.loop && !nextSlide) {\n                nextSlide = slides[0];\n            }\n            // Prev Slide\n            prevSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            if (params.loop && !prevSlide === 0) {\n                prevSlide = slides[slides.length - 1];\n            }\n        }\n    }\n    slides.forEach((slideEl)=>{\n        toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);\n        toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);\n        toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);\n    });\n    swiper.emitSlidesClasses();\n}\nconst processLazyPreloader = (swiper, imageEl)=>{\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    const slideSelector = ()=>swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n    const slideEl = imageEl.closest(slideSelector());\n    if (slideEl) {\n        let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n        if (!lazyEl && swiper.isElement) {\n            if (slideEl.shadowRoot) {\n                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            } else {\n                // init later\n                requestAnimationFrame(()=>{\n                    if (slideEl.shadowRoot) {\n                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n                        if (lazyEl) lazyEl.remove();\n                    }\n                });\n            }\n        }\n        if (lazyEl) lazyEl.remove();\n    }\n};\nconst unlazy = (swiper, index)=>{\n    if (!swiper.slides[index]) return;\n    const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n    if (imageEl) imageEl.removeAttribute(\"loading\");\n};\nconst preload = (swiper)=>{\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    let amount = swiper.params.lazyPreloadPrevNext;\n    const len = swiper.slides.length;\n    if (!len || !amount || amount < 0) return;\n    amount = Math.min(amount, len);\n    const slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n    const activeIndex = swiper.activeIndex;\n    if (swiper.params.grid && swiper.params.grid.rows > 1) {\n        const activeColumn = activeIndex;\n        const preloadColumns = [\n            activeColumn - amount\n        ];\n        preloadColumns.push(...Array.from({\n            length: amount\n        }).map((_, i)=>{\n            return activeColumn + slidesPerView + i;\n        }));\n        swiper.slides.forEach((slideEl, i)=>{\n            if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n        });\n        return;\n    }\n    const slideIndexLastInView = activeIndex + slidesPerView - 1;\n    if (swiper.params.rewind || swiper.params.loop) {\n        for(let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1){\n            const realIndex = (i % len + len) % len;\n            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n    } else {\n        for(let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1){\n            if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n                unlazy(swiper, i);\n            }\n        }\n    }\n};\nfunction getActiveIndexByTranslate(swiper) {\n    const { slidesGrid, params } = swiper;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    let activeIndex;\n    for(let i = 0; i < slidesGrid.length; i += 1){\n        if (typeof slidesGrid[i + 1] !== \"undefined\") {\n            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n                activeIndex = i;\n            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n                activeIndex = i + 1;\n            }\n        } else if (translate >= slidesGrid[i]) {\n            activeIndex = i;\n        }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === \"undefined\") activeIndex = 0;\n    }\n    return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n    const swiper = this;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    const { snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;\n    let activeIndex = newActiveIndex;\n    let snapIndex;\n    const getVirtualRealIndex = (aIndex)=>{\n        let realIndex = aIndex - swiper.virtual.slidesBefore;\n        if (realIndex < 0) {\n            realIndex = swiper.virtual.slides.length + realIndex;\n        }\n        if (realIndex >= swiper.virtual.slides.length) {\n            realIndex -= swiper.virtual.slides.length;\n        }\n        return realIndex;\n    };\n    if (typeof activeIndex === \"undefined\") {\n        activeIndex = getActiveIndexByTranslate(swiper);\n    }\n    if (snapGrid.indexOf(translate) >= 0) {\n        snapIndex = snapGrid.indexOf(translate);\n    } else {\n        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n    }\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    if (activeIndex === previousIndex && !swiper.params.loop) {\n        if (snapIndex !== previousSnapIndex) {\n            swiper.snapIndex = snapIndex;\n            swiper.emit(\"snapIndexChange\");\n        }\n        return;\n    }\n    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.realIndex = getVirtualRealIndex(activeIndex);\n        return;\n    }\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    // Get real index\n    let realIndex;\n    if (swiper.virtual && params.virtual.enabled && params.loop) {\n        realIndex = getVirtualRealIndex(activeIndex);\n    } else if (gridEnabled) {\n        const firstSlideInColumn = swiper.slides.filter((slideEl)=>slideEl.column === activeIndex)[0];\n        let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute(\"data-swiper-slide-index\"), 10);\n        if (Number.isNaN(activeSlideIndex)) {\n            activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n        }\n        realIndex = Math.floor(activeSlideIndex / params.grid.rows);\n    } else if (swiper.slides[activeIndex]) {\n        const slideIndex = swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\");\n        if (slideIndex) {\n            realIndex = parseInt(slideIndex, 10);\n        } else {\n            realIndex = activeIndex;\n        }\n    } else {\n        realIndex = activeIndex;\n    }\n    Object.assign(swiper, {\n        previousSnapIndex,\n        snapIndex,\n        previousRealIndex,\n        realIndex,\n        previousIndex,\n        activeIndex\n    });\n    if (swiper.initialized) {\n        preload(swiper);\n    }\n    swiper.emit(\"activeIndexChange\");\n    swiper.emit(\"snapIndexChange\");\n    if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n        if (previousRealIndex !== realIndex) {\n            swiper.emit(\"realIndexChange\");\n        }\n        swiper.emit(\"slideChange\");\n    }\n}\nfunction updateClickedSlide(el, path) {\n    const swiper = this;\n    const params = swiper.params;\n    let slide = el.closest(`.${params.slideClass}, swiper-slide`);\n    if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n        [\n            ...path.slice(path.indexOf(el) + 1, path.length)\n        ].forEach((pathEl)=>{\n            if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {\n                slide = pathEl;\n            }\n        });\n    }\n    let slideFound = false;\n    let slideIndex;\n    if (slide) {\n        for(let i = 0; i < swiper.slides.length; i += 1){\n            if (swiper.slides[i] === slide) {\n                slideFound = true;\n                slideIndex = i;\n                break;\n            }\n        }\n    }\n    if (slide && slideFound) {\n        swiper.clickedSlide = slide;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n            swiper.clickedIndex = parseInt(slide.getAttribute(\"data-swiper-slide-index\"), 10);\n        } else {\n            swiper.clickedIndex = slideIndex;\n        }\n    } else {\n        swiper.clickedSlide = undefined;\n        swiper.clickedIndex = undefined;\n        return;\n    }\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n        swiper.slideToClickedSlide();\n    }\n}\nvar update = {\n    updateSize,\n    updateSlides,\n    updateAutoHeight,\n    updateSlidesOffset,\n    updateSlidesProgress,\n    updateProgress,\n    updateSlidesClasses,\n    updateActiveIndex,\n    updateClickedSlide\n};\nfunction getSwiperTranslate(axis) {\n    if (axis === void 0) {\n        axis = this.isHorizontal() ? \"x\" : \"y\";\n    }\n    const swiper = this;\n    const { params, rtlTranslate: rtl, translate, wrapperEl } = swiper;\n    if (params.virtualTranslate) {\n        return rtl ? -translate : translate;\n    }\n    if (params.cssMode) {\n        return translate;\n    }\n    let currentTranslate = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(wrapperEl, axis);\n    currentTranslate += swiper.cssOverflowAdjustment();\n    if (rtl) currentTranslate = -currentTranslate;\n    return currentTranslate || 0;\n}\nfunction setTranslate(translate, byController) {\n    const swiper = this;\n    const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;\n    let x = 0;\n    let y = 0;\n    const z = 0;\n    if (swiper.isHorizontal()) {\n        x = rtl ? -translate : translate;\n    } else {\n        y = translate;\n    }\n    if (params.roundLengths) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n    }\n    swiper.previousTranslate = swiper.translate;\n    swiper.translate = swiper.isHorizontal() ? x : y;\n    if (params.cssMode) {\n        wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n    } else if (!params.virtualTranslate) {\n        if (swiper.isHorizontal()) {\n            x -= swiper.cssOverflowAdjustment();\n        } else {\n            y -= swiper.cssOverflowAdjustment();\n        }\n        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n    }\n    // Check if we need to update progress\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n        newProgress = 0;\n    } else {\n        newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== progress) {\n        swiper.updateProgress(translate);\n    }\n    swiper.emit(\"setTranslate\", swiper.translate, byController);\n}\nfunction minTranslate() {\n    return -this.snapGrid[0];\n}\nfunction maxTranslate() {\n    return -this.snapGrid[this.snapGrid.length - 1];\n}\nfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n    if (translate === void 0) {\n        translate = 0;\n    }\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (translateBounds === void 0) {\n        translateBounds = true;\n    }\n    const swiper = this;\n    const { params, wrapperEl } = swiper;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n    }\n    const minTranslate = swiper.minTranslate();\n    const maxTranslate = swiper.maxTranslate();\n    let newTranslate;\n    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n    else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n    else newTranslate = translate;\n    // Update progress\n    swiper.updateProgress(newTranslate);\n    if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        if (speed === 0) {\n            wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n        } else {\n            if (!swiper.support.smoothScroll) {\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)({\n                    swiper,\n                    targetPosition: -newTranslate,\n                    side: isH ? \"left\" : \"top\"\n                });\n                return true;\n            }\n            wrapperEl.scrollTo({\n                [isH ? \"left\" : \"top\"]: -newTranslate,\n                behavior: \"smooth\"\n            });\n        }\n        return true;\n    }\n    if (speed === 0) {\n        swiper.setTransition(0);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n            swiper.emit(\"beforeTransitionStart\", speed, internal);\n            swiper.emit(\"transitionEnd\");\n        }\n    } else {\n        swiper.setTransition(speed);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n            swiper.emit(\"beforeTransitionStart\", speed, internal);\n            swiper.emit(\"transitionStart\");\n        }\n        if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onTranslateToWrapperTransitionEnd) {\n                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.onTranslateToWrapperTransitionEnd = null;\n                    delete swiper.onTranslateToWrapperTransitionEnd;\n                    swiper.animating = false;\n                    if (runCallbacks) {\n                        swiper.emit(\"transitionEnd\");\n                    }\n                };\n            }\n            swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n        }\n    }\n    return true;\n}\nvar translate = {\n    getTranslate: getSwiperTranslate,\n    setTranslate,\n    minTranslate,\n    maxTranslate,\n    translateTo\n};\nfunction setTransition(duration, byController) {\n    const swiper = this;\n    if (!swiper.params.cssMode) {\n        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n        swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : \"\";\n    }\n    swiper.emit(\"setTransition\", duration, byController);\n}\nfunction transitionEmit(_ref) {\n    let { swiper, runCallbacks, direction, step } = _ref;\n    const { activeIndex, previousIndex } = swiper;\n    let dir = direction;\n    if (!dir) {\n        if (activeIndex > previousIndex) dir = \"next\";\n        else if (activeIndex < previousIndex) dir = \"prev\";\n        else dir = \"reset\";\n    }\n    swiper.emit(`transition${step}`);\n    if (runCallbacks && activeIndex !== previousIndex) {\n        if (dir === \"reset\") {\n            swiper.emit(`slideResetTransition${step}`);\n            return;\n        }\n        swiper.emit(`slideChangeTransition${step}`);\n        if (dir === \"next\") {\n            swiper.emit(`slideNextTransition${step}`);\n        } else {\n            swiper.emit(`slidePrevTransition${step}`);\n        }\n    }\n}\nfunction transitionStart(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { params } = swiper;\n    if (params.cssMode) return;\n    if (params.autoHeight) {\n        swiper.updateAutoHeight();\n    }\n    transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"Start\"\n    });\n}\nfunction transitionEnd(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { params } = swiper;\n    swiper.animating = false;\n    if (params.cssMode) return;\n    swiper.setTransition(0);\n    transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"End\"\n    });\n}\nvar transition = {\n    setTransition,\n    transitionStart,\n    transitionEnd\n};\nfunction slideTo(index, speed, runCallbacks, internal, initial) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (typeof index === \"string\") {\n        index = parseInt(index, 10);\n    }\n    const swiper = this;\n    let slideIndex = index;\n    if (slideIndex < 0) slideIndex = 0;\n    const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled } = swiper;\n    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n    }\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    const translate = -snapGrid[snapIndex];\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n        for(let i = 0; i < slidesGrid.length; i += 1){\n            const normalizedTranslate = -Math.floor(translate * 100);\n            const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n            const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n                    slideIndex = i;\n                } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n                    slideIndex = i + 1;\n                }\n            } else if (normalizedTranslate >= normalizedGrid) {\n                slideIndex = i;\n            }\n        }\n    }\n    // Directions locks\n    if (swiper.initialized && slideIndex !== activeIndex) {\n        if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n            return false;\n        }\n        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n            if ((activeIndex || 0) !== slideIndex) {\n                return false;\n            }\n        }\n    }\n    if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n        swiper.emit(\"beforeSlideChangeStart\");\n    }\n    // Update progress\n    swiper.updateProgress(translate);\n    let direction;\n    if (slideIndex > activeIndex) direction = \"next\";\n    else if (slideIndex < activeIndex) direction = \"prev\";\n    else direction = \"reset\";\n    // Update Index\n    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n        swiper.updateActiveIndex(slideIndex);\n        // Update Height\n        if (params.autoHeight) {\n            swiper.updateAutoHeight();\n        }\n        swiper.updateSlidesClasses();\n        if (params.effect !== \"slide\") {\n            swiper.setTranslate(translate);\n        }\n        if (direction !== \"reset\") {\n            swiper.transitionStart(runCallbacks, direction);\n            swiper.transitionEnd(runCallbacks, direction);\n        }\n        return false;\n    }\n    if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        const t = rtl ? translate : -translate;\n        if (speed === 0) {\n            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n            if (isVirtual) {\n                swiper.wrapperEl.style.scrollSnapType = \"none\";\n                swiper._immediateVirtual = true;\n            }\n            if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n                swiper._cssModeVirtualInitialSet = true;\n                requestAnimationFrame(()=>{\n                    wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                });\n            } else {\n                wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n            }\n            if (isVirtual) {\n                requestAnimationFrame(()=>{\n                    swiper.wrapperEl.style.scrollSnapType = \"\";\n                    swiper._immediateVirtual = false;\n                });\n            }\n        } else {\n            if (!swiper.support.smoothScroll) {\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)({\n                    swiper,\n                    targetPosition: t,\n                    side: isH ? \"left\" : \"top\"\n                });\n                return true;\n            }\n            wrapperEl.scrollTo({\n                [isH ? \"left\" : \"top\"]: t,\n                behavior: \"smooth\"\n            });\n        }\n        return true;\n    }\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit(\"beforeTransitionStart\", speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (speed === 0) {\n        swiper.transitionEnd(runCallbacks, direction);\n    } else if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onSlideToWrapperTransitionEnd) {\n            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                if (!swiper || swiper.destroyed) return;\n                if (e.target !== this) return;\n                swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.onSlideToWrapperTransitionEnd = null;\n                delete swiper.onSlideToWrapperTransitionEnd;\n                swiper.transitionEnd(runCallbacks, direction);\n            };\n        }\n        swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n    }\n    return true;\n}\nfunction slideToLoop(index, speed, runCallbacks, internal) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (typeof index === \"string\") {\n        const indexAsNumber = parseInt(index, 10);\n        index = indexAsNumber;\n    }\n    const swiper = this;\n    if (swiper.destroyed) return;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n    let newIndex = index;\n    if (swiper.params.loop) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n            // eslint-disable-next-line\n            newIndex = newIndex + swiper.virtual.slidesBefore;\n        } else {\n            let targetSlideIndex;\n            if (gridEnabled) {\n                const slideIndex = newIndex * swiper.params.grid.rows;\n                targetSlideIndex = swiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex)[0].column;\n            } else {\n                targetSlideIndex = swiper.getSlideIndexByData(newIndex);\n            }\n            const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n            const { centeredSlides } = swiper.params;\n            let slidesPerView = swiper.params.slidesPerView;\n            if (slidesPerView === \"auto\") {\n                slidesPerView = swiper.slidesPerViewDynamic();\n            } else {\n                slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n                if (centeredSlides && slidesPerView % 2 === 0) {\n                    slidesPerView = slidesPerView + 1;\n                }\n            }\n            let needLoopFix = cols - targetSlideIndex < slidesPerView;\n            if (centeredSlides) {\n                needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n            }\n            if (internal && centeredSlides && swiper.params.slidesPerView !== \"auto\" && !gridEnabled) {\n                needLoopFix = false;\n            }\n            if (needLoopFix) {\n                const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? \"prev\" : \"next\" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? \"next\" : \"prev\";\n                swiper.loopFix({\n                    direction,\n                    slideTo: true,\n                    activeSlideIndex: direction === \"next\" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n                    slideRealIndex: direction === \"next\" ? swiper.realIndex : undefined\n                });\n            }\n            if (gridEnabled) {\n                const slideIndex = newIndex * swiper.params.grid.rows;\n                newIndex = swiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex)[0].column;\n            } else {\n                newIndex = swiper.getSlideIndexByData(newIndex);\n            }\n        }\n    }\n    requestAnimationFrame(()=>{\n        swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    });\n    return swiper;\n}\n/* eslint no-unused-vars: \"off\" */ function slideNext(speed, runCallbacks, internal) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { enabled, params, animating } = swiper;\n    if (!enabled || swiper.destroyed) return swiper;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    let perGroup = params.slidesPerGroup;\n    if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n    }\n    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n            direction: \"next\"\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n            requestAnimationFrame(()=>{\n                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n            });\n            return true;\n        }\n    }\n    if (params.rewind && swiper.isEnd) {\n        return swiper.slideTo(0, speed, runCallbacks, internal);\n    }\n    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slidePrev(speed, runCallbacks, internal) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { params, snapGrid, slidesGrid, rtlTranslate, enabled, animating } = swiper;\n    if (!enabled || swiper.destroyed) return swiper;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n            direction: \"prev\"\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    }\n    const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n    function normalize(val) {\n        if (val < 0) return -Math.floor(Math.abs(val));\n        return Math.floor(val);\n    }\n    const normalizedTranslate = normalize(translate);\n    const normalizedSnapGrid = snapGrid.map((val)=>normalize(val));\n    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n    if (typeof prevSnap === \"undefined\" && params.cssMode) {\n        let prevSnapIndex;\n        snapGrid.forEach((snap, snapIndex)=>{\n            if (normalizedTranslate >= snap) {\n                // prevSnap = snap;\n                prevSnapIndex = snapIndex;\n            }\n        });\n        if (typeof prevSnapIndex !== \"undefined\") {\n            prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n    }\n    let prevIndex = 0;\n    if (typeof prevSnap !== \"undefined\") {\n        prevIndex = slidesGrid.indexOf(prevSnap);\n        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n        if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n            prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n            prevIndex = Math.max(prevIndex, 0);\n        }\n    }\n    if (params.rewind && swiper.isBeginning) {\n        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n        requestAnimationFrame(()=>{\n            swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n        });\n        return true;\n    }\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slideReset(speed, runCallbacks, internal) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    if (swiper.destroyed) return;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slideToClosest(speed, runCallbacks, internal, threshold) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (threshold === void 0) {\n        threshold = 0.5;\n    }\n    const swiper = this;\n    if (swiper.destroyed) return;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    let index = swiper.activeIndex;\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    if (translate >= swiper.snapGrid[snapIndex]) {\n        // The current translate is on or after the current snap index, so the choice\n        // is between the current index and the one after it.\n        const currentSnap = swiper.snapGrid[snapIndex];\n        const nextSnap = swiper.snapGrid[snapIndex + 1];\n        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n            index += swiper.params.slidesPerGroup;\n        }\n    } else {\n        // The current translate is before the current snap index, so the choice\n        // is between the current index and the one before it.\n        const prevSnap = swiper.snapGrid[snapIndex - 1];\n        const currentSnap = swiper.snapGrid[snapIndex];\n        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n            index -= swiper.params.slidesPerGroup;\n        }\n    }\n    index = Math.max(index, 0);\n    index = Math.min(index, swiper.slidesGrid.length - 1);\n    return swiper.slideTo(index, speed, runCallbacks, internal);\n}\nfunction slideToClickedSlide() {\n    const swiper = this;\n    if (swiper.destroyed) return;\n    const { params, slidesEl } = swiper;\n    const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n    let slideToIndex = swiper.clickedIndex;\n    let realIndex;\n    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n    if (params.loop) {\n        if (swiper.animating) return;\n        realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n        if (params.centeredSlides) {\n            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                swiper.loopFix();\n                slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(()=>{\n                    swiper.slideTo(slideToIndex);\n                });\n            } else {\n                swiper.slideTo(slideToIndex);\n            }\n        } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n            swiper.loopFix();\n            slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(()=>{\n                swiper.slideTo(slideToIndex);\n            });\n        } else {\n            swiper.slideTo(slideToIndex);\n        }\n    } else {\n        swiper.slideTo(slideToIndex);\n    }\n}\nvar slide = {\n    slideTo,\n    slideToLoop,\n    slideNext,\n    slidePrev,\n    slideReset,\n    slideToClosest,\n    slideToClickedSlide\n};\nfunction loopCreate(slideRealIndex) {\n    const swiper = this;\n    const { params, slidesEl } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    const initSlides = ()=>{\n        const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n        slides.forEach((el, index)=>{\n            el.setAttribute(\"data-swiper-slide-index\", index);\n        });\n    };\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n    const addBlankSlides = (amountOfSlides)=>{\n        for(let i = 0; i < amountOfSlides; i += 1){\n            const slideEl = swiper.isElement ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"swiper-slide\", [\n                params.slideBlankClass\n            ]) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"div\", [\n                params.slideClass,\n                params.slideBlankClass\n            ]);\n            swiper.slidesEl.append(slideEl);\n        }\n    };\n    if (shouldFillGroup) {\n        if (params.loopAddBlankSlides) {\n            const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n            addBlankSlides(slidesToAdd);\n            swiper.recalcSlides();\n            swiper.updateSlides();\n        } else {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n        }\n        initSlides();\n    } else if (shouldFillGrid) {\n        if (params.loopAddBlankSlides) {\n            const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;\n            addBlankSlides(slidesToAdd);\n            swiper.recalcSlides();\n            swiper.updateSlides();\n        } else {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n        }\n        initSlides();\n    } else {\n        initSlides();\n    }\n    swiper.loopFix({\n        slideRealIndex,\n        direction: params.centeredSlides ? undefined : \"next\"\n    });\n}\nfunction loopFix(_temp) {\n    let { slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel } = _temp === void 0 ? {} : _temp;\n    const swiper = this;\n    if (!swiper.params.loop) return;\n    swiper.emit(\"beforeLoopFix\");\n    const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } = swiper;\n    const { centeredSlides } = params;\n    swiper.allowSlidePrev = true;\n    swiper.allowSlideNext = true;\n    if (swiper.virtual && params.virtual.enabled) {\n        if (slideTo) {\n            if (!params.centeredSlides && swiper.snapIndex === 0) {\n                swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n            } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n                swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n            } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n                swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n            }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit(\"loopFix\");\n        return;\n    }\n    let slidesPerView = params.slidesPerView;\n    if (slidesPerView === \"auto\") {\n        slidesPerView = swiper.slidesPerViewDynamic();\n    } else {\n        slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n        if (centeredSlides && slidesPerView % 2 === 0) {\n            slidesPerView = slidesPerView + 1;\n        }\n    }\n    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n    let loopedSlides = slidesPerGroup;\n    if (loopedSlides % slidesPerGroup !== 0) {\n        loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n    }\n    loopedSlides += params.loopAdditionalSlides;\n    swiper.loopedSlides = loopedSlides;\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    if (slides.length < slidesPerView + loopedSlides) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters\");\n    } else if (gridEnabled && params.grid.fill === \"row\") {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`\");\n    }\n    const prependSlidesIndexes = [];\n    const appendSlidesIndexes = [];\n    let activeIndex = swiper.activeIndex;\n    if (typeof activeSlideIndex === \"undefined\") {\n        activeSlideIndex = swiper.getSlideIndex(slides.filter((el)=>el.classList.contains(params.slideActiveClass))[0]);\n    } else {\n        activeIndex = activeSlideIndex;\n    }\n    const isNext = direction === \"next\" || !direction;\n    const isPrev = direction === \"prev\" || !direction;\n    let slidesPrepended = 0;\n    let slidesAppended = 0;\n    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === \"undefined\" ? -slidesPerView / 2 + 0.5 : 0);\n    // prepend last slides before start\n    if (activeColIndexWithShift < loopedSlides) {\n        slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n        for(let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1){\n            const index = i - Math.floor(i / cols) * cols;\n            if (gridEnabled) {\n                const colIndexToPrepend = cols - index - 1;\n                for(let i = slides.length - 1; i >= 0; i -= 1){\n                    if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);\n                }\n            // slides.forEach((slide, slideIndex) => {\n            //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);\n            // });\n            } else {\n                prependSlidesIndexes.push(cols - index - 1);\n            }\n        }\n    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n        slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n        for(let i = 0; i < slidesAppended; i += 1){\n            const index = i - Math.floor(i / cols) * cols;\n            if (gridEnabled) {\n                slides.forEach((slide, slideIndex)=>{\n                    if (slide.column === index) appendSlidesIndexes.push(slideIndex);\n                });\n            } else {\n                appendSlidesIndexes.push(index);\n            }\n        }\n    }\n    swiper.__preventObserver__ = true;\n    requestAnimationFrame(()=>{\n        swiper.__preventObserver__ = false;\n    });\n    if (isPrev) {\n        prependSlidesIndexes.forEach((index)=>{\n            slides[index].swiperLoopMoveDOM = true;\n            slidesEl.prepend(slides[index]);\n            slides[index].swiperLoopMoveDOM = false;\n        });\n    }\n    if (isNext) {\n        appendSlidesIndexes.forEach((index)=>{\n            slides[index].swiperLoopMoveDOM = true;\n            slidesEl.append(slides[index]);\n            slides[index].swiperLoopMoveDOM = false;\n        });\n    }\n    swiper.recalcSlides();\n    if (params.slidesPerView === \"auto\") {\n        swiper.updateSlides();\n    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n        swiper.slides.forEach((slide, slideIndex)=>{\n            swiper.grid.updateSlide(slideIndex, slide, swiper.slides);\n        });\n    }\n    if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n    }\n    if (slideTo) {\n        if (prependSlidesIndexes.length > 0 && isPrev) {\n            if (typeof slideRealIndex === \"undefined\") {\n                const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n                const diff = newSlideTranslate - currentSlideTranslate;\n                if (byMousewheel) {\n                    swiper.setTranslate(swiper.translate - diff);\n                } else {\n                    swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);\n                    if (setTranslate) {\n                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n                    }\n                }\n            } else {\n                if (setTranslate) {\n                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n                    swiper.touchEventsData.currentTranslate = swiper.translate;\n                }\n            }\n        } else if (appendSlidesIndexes.length > 0 && isNext) {\n            if (typeof slideRealIndex === \"undefined\") {\n                const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n                const diff = newSlideTranslate - currentSlideTranslate;\n                if (byMousewheel) {\n                    swiper.setTranslate(swiper.translate - diff);\n                } else {\n                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n                    if (setTranslate) {\n                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n                    }\n                }\n            } else {\n                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);\n            }\n        }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.controller && swiper.controller.control && !byController) {\n        const loopParams = {\n            slideRealIndex,\n            direction,\n            setTranslate,\n            activeSlideIndex,\n            byController: true\n        };\n        if (Array.isArray(swiper.controller.control)) {\n            swiper.controller.control.forEach((c)=>{\n                if (!c.destroyed && c.params.loop) c.loopFix({\n                    ...loopParams,\n                    slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false\n                });\n            });\n        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n            swiper.controller.control.loopFix({\n                ...loopParams,\n                slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false\n            });\n        }\n    }\n    swiper.emit(\"loopFix\");\n}\nfunction loopDestroy() {\n    const swiper = this;\n    const { params, slidesEl } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    swiper.recalcSlides();\n    const newSlidesOrder = [];\n    swiper.slides.forEach((slideEl)=>{\n        const index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n        newSlidesOrder[index] = slideEl;\n    });\n    swiper.slides.forEach((slideEl)=>{\n        slideEl.removeAttribute(\"data-swiper-slide-index\");\n    });\n    newSlidesOrder.forEach((slideEl)=>{\n        slidesEl.append(slideEl);\n    });\n    swiper.recalcSlides();\n    swiper.slideTo(swiper.realIndex, 0);\n}\nvar loop = {\n    loopCreate,\n    loopFix,\n    loopDestroy\n};\nfunction setGrabCursor(moving) {\n    const swiper = this;\n    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n    const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n    if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n    }\n    el.style.cursor = \"move\";\n    el.style.cursor = moving ? \"grabbing\" : \"grab\";\n    if (swiper.isElement) {\n        requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n}\nfunction unsetGrabCursor() {\n    const swiper = this;\n    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n        return;\n    }\n    if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n    }\n    swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n    if (swiper.isElement) {\n        requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n}\nvar grabCursor = {\n    setGrabCursor,\n    unsetGrabCursor\n};\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base) {\n    if (base === void 0) {\n        base = this;\n    }\n    function __closestFrom(el) {\n        if (!el || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)() || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)()) return null;\n        if (el.assignedSlot) el = el.assignedSlot;\n        const found = el.closest(selector);\n        if (!found && !el.getRootNode) {\n            return null;\n        }\n        return found || __closestFrom(el.getRootNode().host);\n    }\n    return __closestFrom(base);\n}\nfunction preventEdgeSwipe(swiper, event, startX) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const { params } = swiper;\n    const edgeSwipeDetection = params.edgeSwipeDetection;\n    const edgeSwipeThreshold = params.edgeSwipeThreshold;\n    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window1.innerWidth - edgeSwipeThreshold)) {\n        if (edgeSwipeDetection === \"prevent\") {\n            event.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    return true;\n}\nfunction onTouchStart(event) {\n    const swiper = this;\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    const data = swiper.touchEventsData;\n    if (e.type === \"pointerdown\") {\n        if (data.pointerId !== null && data.pointerId !== e.pointerId) {\n            return;\n        }\n        data.pointerId = e.pointerId;\n    } else if (e.type === \"touchstart\" && e.targetTouches.length === 1) {\n        data.touchId = e.targetTouches[0].identifier;\n    }\n    if (e.type === \"touchstart\") {\n        // don't proceed touch event\n        preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n        return;\n    }\n    const { params, touches, enabled } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && e.pointerType === \"mouse\") return;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n        return;\n    }\n    if (!swiper.animating && params.cssMode && params.loop) {\n        swiper.loopFix();\n    }\n    let targetEl = e.target;\n    if (params.touchEventsTarget === \"wrapper\") {\n        if (!swiper.wrapperEl.contains(targetEl)) return;\n    }\n    if (\"which\" in e && e.which === 3) return;\n    if (\"button\" in e && e.button > 0) return;\n    if (data.isTouched && data.isMoved) return;\n    // change target el for shadow root component\n    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n    // eslint-disable-next-line\n    const eventPath = e.composedPath ? e.composedPath() : e.path;\n    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n        targetEl = eventPath[0];\n    }\n    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n    const isTargetShadow = !!(e.target && e.target.shadowRoot);\n    // use closestElement for shadow root element to get the actual closest for nested shadow root element\n    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n        swiper.allowClick = true;\n        return;\n    }\n    if (params.swipeHandler) {\n        if (!targetEl.closest(params.swipeHandler)) return;\n    }\n    touches.currentX = e.pageX;\n    touches.currentY = e.pageY;\n    const startX = touches.currentX;\n    const startY = touches.currentY;\n    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n    if (!preventEdgeSwipe(swiper, e, startX)) {\n        return;\n    }\n    Object.assign(data, {\n        isTouched: true,\n        isMoved: false,\n        allowTouchCallbacks: true,\n        isScrolling: undefined,\n        startMoving: undefined\n    });\n    touches.startX = startX;\n    touches.startY = startY;\n    data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    swiper.allowClick = true;\n    swiper.updateSize();\n    swiper.swipeDirection = undefined;\n    if (params.threshold > 0) data.allowThresholdMove = false;\n    let preventDefault = true;\n    if (targetEl.matches(data.focusableElements)) {\n        preventDefault = false;\n        if (targetEl.nodeName === \"SELECT\") {\n            data.isTouched = false;\n        }\n    }\n    if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== targetEl) {\n        document1.activeElement.blur();\n    }\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n        e.preventDefault();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n        swiper.freeMode.onTouchStart();\n    }\n    swiper.emit(\"touchStart\", e);\n}\nfunction onTouchMove(event) {\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const { params, touches, rtlTranslate: rtl, enabled } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === \"mouse\") return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    if (e.type === \"pointermove\") {\n        if (data.touchId !== null) return; // return from pointer if we use touch\n        const id = e.pointerId;\n        if (id !== data.pointerId) return;\n    }\n    let targetTouch;\n    if (e.type === \"touchmove\") {\n        targetTouch = [\n            ...e.changedTouches\n        ].filter((t)=>t.identifier === data.touchId)[0];\n        if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n    } else {\n        targetTouch = e;\n    }\n    if (!data.isTouched) {\n        if (data.startMoving && data.isScrolling) {\n            swiper.emit(\"touchMoveOpposite\", e);\n        }\n        return;\n    }\n    const pageX = targetTouch.pageX;\n    const pageY = targetTouch.pageY;\n    if (e.preventedByNestedSwiper) {\n        touches.startX = pageX;\n        touches.startY = pageY;\n        return;\n    }\n    if (!swiper.allowTouchMove) {\n        if (!e.target.matches(data.focusableElements)) {\n            swiper.allowClick = false;\n        }\n        if (data.isTouched) {\n            Object.assign(touches, {\n                startX: pageX,\n                startY: pageY,\n                currentX: pageX,\n                currentY: pageY\n            });\n            data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n        }\n        return;\n    }\n    if (params.touchReleaseOnEdges && !params.loop) {\n        if (swiper.isVertical()) {\n            // Vertical\n            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                data.isTouched = false;\n                data.isMoved = false;\n                return;\n            }\n        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n            return;\n        }\n    }\n    if (document1.activeElement) {\n        if (e.target === document1.activeElement && e.target.matches(data.focusableElements)) {\n            data.isMoved = true;\n            swiper.allowClick = false;\n            return;\n        }\n    }\n    if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchMove\", e);\n    }\n    touches.previousX = touches.currentX;\n    touches.previousY = touches.currentY;\n    touches.currentX = pageX;\n    touches.currentY = pageY;\n    const diffX = touches.currentX - touches.startX;\n    const diffY = touches.currentY - touches.startY;\n    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n    if (typeof data.isScrolling === \"undefined\") {\n        let touchAngle;\n        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n            data.isScrolling = false;\n        } else {\n            // eslint-disable-next-line\n            if (diffX * diffX + diffY * diffY >= 25) {\n                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n            }\n        }\n    }\n    if (data.isScrolling) {\n        swiper.emit(\"touchMoveOpposite\", e);\n    }\n    if (typeof data.startMoving === \"undefined\") {\n        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n            data.startMoving = true;\n        }\n    }\n    if (data.isScrolling || e.type === \"touchmove\" && data.preventTouchMoveFromPointerMove) {\n        data.isTouched = false;\n        return;\n    }\n    if (!data.startMoving) {\n        return;\n    }\n    swiper.allowClick = false;\n    if (!params.cssMode && e.cancelable) {\n        e.preventDefault();\n    }\n    if (params.touchMoveStopPropagation && !params.nested) {\n        e.stopPropagation();\n    }\n    let diff = swiper.isHorizontal() ? diffX : diffY;\n    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n    if (params.oneWayMovement) {\n        diff = Math.abs(diff) * (rtl ? 1 : -1);\n        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n    }\n    touches.diff = diff;\n    diff *= params.touchRatio;\n    if (rtl) {\n        diff = -diff;\n        touchesDiff = -touchesDiff;\n    }\n    const prevTouchesDirection = swiper.touchesDirection;\n    swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n    swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n    const isLoop = swiper.params.loop && !params.cssMode;\n    const allowLoopFix = swiper.touchesDirection === \"next\" && swiper.allowSlideNext || swiper.touchesDirection === \"prev\" && swiper.allowSlidePrev;\n    if (!data.isMoved) {\n        if (isLoop && allowLoopFix) {\n            swiper.loopFix({\n                direction: swiper.swipeDirection\n            });\n        }\n        data.startTranslate = swiper.getTranslate();\n        swiper.setTransition(0);\n        if (swiper.animating) {\n            const evt = new window.CustomEvent(\"transitionend\", {\n                bubbles: true,\n                cancelable: true\n            });\n            swiper.wrapperEl.dispatchEvent(evt);\n        }\n        data.allowMomentumBounce = false;\n        // Grab Cursor\n        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n            swiper.setGrabCursor(true);\n        }\n        swiper.emit(\"sliderFirstMove\", e);\n    }\n    let loopFixed;\n    new Date().getTime();\n    if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n        Object.assign(touches, {\n            startX: pageX,\n            startY: pageY,\n            currentX: pageX,\n            currentY: pageY,\n            startTranslate: data.currentTranslate\n        });\n        data.loopSwapReset = true;\n        data.startTranslate = data.currentTranslate;\n        return;\n    }\n    swiper.emit(\"sliderMove\", e);\n    data.isMoved = true;\n    data.currentTranslate = diff + data.startTranslate;\n    let disableParentSwiper = true;\n    let resistanceRatio = params.resistanceRatio;\n    if (params.touchReleaseOnEdges) {\n        resistanceRatio = 0;\n    }\n    if (diff > 0) {\n        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {\n            swiper.loopFix({\n                direction: \"prev\",\n                setTranslate: true,\n                activeSlideIndex: 0\n            });\n        }\n        if (data.currentTranslate > swiper.minTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) {\n                data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n            }\n        }\n    } else if (diff < 0) {\n        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {\n            swiper.loopFix({\n                direction: \"next\",\n                setTranslate: true,\n                activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n            });\n        }\n        if (data.currentTranslate < swiper.maxTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) {\n                data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n            }\n        }\n    }\n    if (disableParentSwiper) {\n        e.preventedByNestedSwiper = true;\n    }\n    // Directions locks\n    if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n        data.currentTranslate = data.startTranslate;\n    }\n    // Threshold\n    if (params.threshold > 0) {\n        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n            if (!data.allowThresholdMove) {\n                data.allowThresholdMove = true;\n                touches.startX = touches.currentX;\n                touches.startY = touches.currentY;\n                data.currentTranslate = data.startTranslate;\n                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                return;\n            }\n        } else {\n            data.currentTranslate = data.startTranslate;\n            return;\n        }\n    }\n    if (!params.followFinger || params.cssMode) return;\n    // Update active index in free mode\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n        swiper.freeMode.onTouchMove();\n    }\n    // Update progress\n    swiper.updateProgress(data.currentTranslate);\n    // Update translate\n    swiper.setTranslate(data.currentTranslate);\n}\nfunction onTouchEnd(event) {\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    let targetTouch;\n    const isTouchEvent = e.type === \"touchend\" || e.type === \"touchcancel\";\n    if (!isTouchEvent) {\n        if (data.touchId !== null) return; // return from pointer if we use touch\n        if (e.pointerId !== data.pointerId) return;\n        targetTouch = e;\n    } else {\n        targetTouch = [\n            ...e.changedTouches\n        ].filter((t)=>t.identifier === data.touchId)[0];\n        if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n    }\n    if ([\n        \"pointercancel\",\n        \"pointerout\",\n        \"pointerleave\",\n        \"contextmenu\"\n    ].includes(e.type)) {\n        const proceed = [\n            \"pointercancel\",\n            \"contextmenu\"\n        ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n        if (!proceed) {\n            return;\n        }\n    }\n    data.pointerId = null;\n    data.touchId = null;\n    const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && e.pointerType === \"mouse\") return;\n    if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchEnd\", e);\n    }\n    data.allowTouchCallbacks = false;\n    if (!data.isTouched) {\n        if (data.isMoved && params.grabCursor) {\n            swiper.setGrabCursor(false);\n        }\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n    }\n    // Return Grab Cursor\n    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(false);\n    }\n    // Time diff\n    const touchEndTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    // Tap, doubleTap, Click\n    if (swiper.allowClick) {\n        const pathTree = e.path || e.composedPath && e.composedPath();\n        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n        swiper.emit(\"tap click\", e);\n        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n            swiper.emit(\"doubleTap doubleClick\", e);\n        }\n    }\n    data.lastClickTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(()=>{\n        if (!swiper.destroyed) swiper.allowClick = true;\n    });\n    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n    }\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    let currentPos;\n    if (params.followFinger) {\n        currentPos = rtl ? swiper.translate : -swiper.translate;\n    } else {\n        currentPos = -data.currentTranslate;\n    }\n    if (params.cssMode) {\n        return;\n    }\n    if (params.freeMode && params.freeMode.enabled) {\n        swiper.freeMode.onTouchEnd({\n            currentPos\n        });\n        return;\n    }\n    // Find current slide\n    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n    let stopIndex = 0;\n    let groupSize = swiper.slidesSizesGrid[0];\n    for(let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){\n        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (typeof slidesGrid[i + increment] !== \"undefined\") {\n            if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                stopIndex = i;\n                groupSize = slidesGrid[i + increment] - slidesGrid[i];\n            }\n        } else if (swipeToLast || currentPos >= slidesGrid[i]) {\n            stopIndex = i;\n            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n        }\n    }\n    let rewindFirstIndex = null;\n    let rewindLastIndex = null;\n    if (params.rewind) {\n        if (swiper.isBeginning) {\n            rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        } else if (swiper.isEnd) {\n            rewindFirstIndex = 0;\n        }\n    }\n    // Find current slide size\n    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (timeDiff > params.longSwipesMs) {\n        // Long touches\n        if (!params.longSwipes) {\n            swiper.slideTo(swiper.activeIndex);\n            return;\n        }\n        if (swiper.swipeDirection === \"next\") {\n            if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n            else swiper.slideTo(stopIndex);\n        }\n        if (swiper.swipeDirection === \"prev\") {\n            if (ratio > 1 - params.longSwipesRatio) {\n                swiper.slideTo(stopIndex + increment);\n            } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n                swiper.slideTo(rewindLastIndex);\n            } else {\n                swiper.slideTo(stopIndex);\n            }\n        }\n    } else {\n        // Short swipes\n        if (!params.shortSwipes) {\n            swiper.slideTo(swiper.activeIndex);\n            return;\n        }\n        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n        if (!isNavButtonTarget) {\n            if (swiper.swipeDirection === \"next\") {\n                swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n            }\n            if (swiper.swipeDirection === \"prev\") {\n                swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n            }\n        } else if (e.target === swiper.navigation.nextEl) {\n            swiper.slideTo(stopIndex + increment);\n        } else {\n            swiper.slideTo(stopIndex);\n        }\n    }\n}\nfunction onResize() {\n    const swiper = this;\n    const { params, el } = swiper;\n    if (el && el.offsetWidth === 0) return;\n    // Breakpoints\n    if (params.breakpoints) {\n        swiper.setBreakpoint();\n    }\n    // Save locks\n    const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    // Disable locks on resize\n    swiper.allowSlideNext = true;\n    swiper.allowSlidePrev = true;\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateSlidesClasses();\n    const isVirtualLoop = isVirtual && params.loop;\n    if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n        if (swiper.params.loop && !isVirtual) {\n            swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        } else {\n            swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n    }\n    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        clearTimeout(swiper.autoplay.resizeTimeout);\n        swiper.autoplay.resizeTimeout = setTimeout(()=>{\n            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n                swiper.autoplay.resume();\n            }\n        }, 500);\n    }\n    // Return locks after resize\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n    }\n}\nfunction onClick(e) {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    if (!swiper.allowClick) {\n        if (swiper.params.preventClicks) e.preventDefault();\n        if (swiper.params.preventClicksPropagation && swiper.animating) {\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n        }\n    }\n}\nfunction onScroll() {\n    const swiper = this;\n    const { wrapperEl, rtlTranslate, enabled } = swiper;\n    if (!enabled) return;\n    swiper.previousTranslate = swiper.translate;\n    if (swiper.isHorizontal()) {\n        swiper.translate = -wrapperEl.scrollLeft;\n    } else {\n        swiper.translate = -wrapperEl.scrollTop;\n    }\n    // eslint-disable-next-line\n    if (swiper.translate === 0) swiper.translate = 0;\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n        newProgress = 0;\n    } else {\n        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== swiper.progress) {\n        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n    }\n    swiper.emit(\"setTranslate\", swiper.translate, false);\n}\nfunction onLoad(e) {\n    const swiper = this;\n    processLazyPreloader(swiper, e.target);\n    if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) {\n        return;\n    }\n    swiper.update();\n}\nfunction onDocumentTouchStart() {\n    const swiper = this;\n    if (swiper.documentTouchHandlerProceeded) return;\n    swiper.documentTouchHandlerProceeded = true;\n    if (swiper.params.touchReleaseOnEdges) {\n        swiper.el.style.touchAction = \"auto\";\n    }\n}\nconst events = (swiper, method)=>{\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    const { params, el, wrapperEl, device } = swiper;\n    const capture = !!params.nested;\n    const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n    const swiperMethod = method;\n    // Touch Events\n    document1[domMethod](\"touchstart\", swiper.onDocumentTouchStart, {\n        passive: false,\n        capture\n    });\n    el[domMethod](\"touchstart\", swiper.onTouchStart, {\n        passive: false\n    });\n    el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n        passive: false\n    });\n    document1[domMethod](\"touchmove\", swiper.onTouchMove, {\n        passive: false,\n        capture\n    });\n    document1[domMethod](\"pointermove\", swiper.onTouchMove, {\n        passive: false,\n        capture\n    });\n    document1[domMethod](\"touchend\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerup\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"touchcancel\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerout\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"contextmenu\", swiper.onTouchEnd, {\n        passive: true\n    });\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n        el[domMethod](\"click\", swiper.onClick, true);\n    }\n    if (params.cssMode) {\n        wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n    }\n    // Resize handler\n    if (params.updateOnWindowResize) {\n        swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n    } else {\n        swiper[swiperMethod](\"observerUpdate\", onResize, true);\n    }\n    // Images loader\n    el[domMethod](\"load\", swiper.onLoad, {\n        capture: true\n    });\n};\nfunction attachEvents() {\n    const swiper = this;\n    const { params } = swiper;\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n    if (params.cssMode) {\n        swiper.onScroll = onScroll.bind(swiper);\n    }\n    swiper.onClick = onClick.bind(swiper);\n    swiper.onLoad = onLoad.bind(swiper);\n    events(swiper, \"on\");\n}\nfunction detachEvents() {\n    const swiper = this;\n    events(swiper, \"off\");\n}\nvar events$1 = {\n    attachEvents,\n    detachEvents\n};\nconst isGridEnabled = (swiper, params)=>{\n    return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n    const swiper = this;\n    const { realIndex, initialized, params, el } = swiper;\n    const breakpoints = params.breakpoints;\n    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n    // Get breakpoint for window width and update parameters\n    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const wasMultiRow = isGridEnabled(swiper, params);\n    const isMultiRow = isGridEnabled(swiper, breakpointParams);\n    const wasGrabCursor = swiper.params.grabCursor;\n    const isGrabCursor = breakpointParams.grabCursor;\n    const wasEnabled = params.enabled;\n    if (wasMultiRow && !isMultiRow) {\n        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n        swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n        el.classList.add(`${params.containerModifierClass}grid`);\n        if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") {\n            el.classList.add(`${params.containerModifierClass}grid-column`);\n        }\n        swiper.emitContainerClasses();\n    }\n    if (wasGrabCursor && !isGrabCursor) {\n        swiper.unsetGrabCursor();\n    } else if (!wasGrabCursor && isGrabCursor) {\n        swiper.setGrabCursor();\n    }\n    // Toggle navigation, pagination, scrollbar\n    [\n        \"navigation\",\n        \"pagination\",\n        \"scrollbar\"\n    ].forEach((prop)=>{\n        if (typeof breakpointParams[prop] === \"undefined\") return;\n        const wasModuleEnabled = params[prop] && params[prop].enabled;\n        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n        if (wasModuleEnabled && !isModuleEnabled) {\n            swiper[prop].disable();\n        }\n        if (!wasModuleEnabled && isModuleEnabled) {\n            swiper[prop].enable();\n        }\n    });\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n    const wasLoop = params.loop;\n    if (directionChanged && initialized) {\n        swiper.changeDirection();\n    }\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(swiper.params, breakpointParams);\n    const isEnabled = swiper.params.enabled;\n    const hasLoop = swiper.params.loop;\n    Object.assign(swiper, {\n        allowTouchMove: swiper.params.allowTouchMove,\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev\n    });\n    if (wasEnabled && !isEnabled) {\n        swiper.disable();\n    } else if (!wasEnabled && isEnabled) {\n        swiper.enable();\n    }\n    swiper.currentBreakpoint = breakpoint;\n    swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n    if (initialized) {\n        if (needsReLoop) {\n            swiper.loopDestroy();\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        } else if (!wasLoop && hasLoop) {\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        } else if (wasLoop && !hasLoop) {\n            swiper.loopDestroy();\n        }\n    }\n    swiper.emit(\"breakpoint\", breakpointParams);\n}\nfunction getBreakpoint(breakpoints, base, containerEl) {\n    if (base === void 0) {\n        base = \"window\";\n    }\n    if (!breakpoints || base === \"container\" && !containerEl) return undefined;\n    let breakpoint = false;\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const currentHeight = base === \"window\" ? window1.innerHeight : containerEl.clientHeight;\n    const points = Object.keys(breakpoints).map((point)=>{\n        if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n            const minRatio = parseFloat(point.substr(1));\n            const value = currentHeight * minRatio;\n            return {\n                value,\n                point\n            };\n        }\n        return {\n            value: point,\n            point\n        };\n    });\n    points.sort((a, b)=>parseInt(a.value, 10) - parseInt(b.value, 10));\n    for(let i = 0; i < points.length; i += 1){\n        const { point, value } = points[i];\n        if (base === \"window\") {\n            if (window1.matchMedia(`(min-width: ${value}px)`).matches) {\n                breakpoint = point;\n            }\n        } else if (value <= containerEl.clientWidth) {\n            breakpoint = point;\n        }\n    }\n    return breakpoint || \"max\";\n}\nvar breakpoints = {\n    setBreakpoint,\n    getBreakpoint\n};\nfunction prepareClasses(entries, prefix) {\n    const resultClasses = [];\n    entries.forEach((item)=>{\n        if (typeof item === \"object\") {\n            Object.keys(item).forEach((classNames)=>{\n                if (item[classNames]) {\n                    resultClasses.push(prefix + classNames);\n                }\n            });\n        } else if (typeof item === \"string\") {\n            resultClasses.push(prefix + item);\n        }\n    });\n    return resultClasses;\n}\nfunction addClasses() {\n    const swiper = this;\n    const { classNames, params, rtl, el, device } = swiper;\n    // prettier-ignore\n    const suffixes = prepareClasses([\n        \"initialized\",\n        params.direction,\n        {\n            \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n        },\n        {\n            \"autoheight\": params.autoHeight\n        },\n        {\n            \"rtl\": rtl\n        },\n        {\n            \"grid\": params.grid && params.grid.rows > 1\n        },\n        {\n            \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n        },\n        {\n            \"android\": device.android\n        },\n        {\n            \"ios\": device.ios\n        },\n        {\n            \"css-mode\": params.cssMode\n        },\n        {\n            \"centered\": params.cssMode && params.centeredSlides\n        },\n        {\n            \"watch-progress\": params.watchSlidesProgress\n        }\n    ], params.containerModifierClass);\n    classNames.push(...suffixes);\n    el.classList.add(...classNames);\n    swiper.emitContainerClasses();\n}\nfunction removeClasses() {\n    const swiper = this;\n    const { el, classNames } = swiper;\n    el.classList.remove(...classNames);\n    swiper.emitContainerClasses();\n}\nvar classes = {\n    addClasses,\n    removeClasses\n};\nfunction checkOverflow() {\n    const swiper = this;\n    const { isLocked: wasLocked, params } = swiper;\n    const { slidesOffsetBefore } = params;\n    if (slidesOffsetBefore) {\n        const lastSlideIndex = swiper.slides.length - 1;\n        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n        swiper.isLocked = swiper.size > lastSlideRightEdge;\n    } else {\n        swiper.isLocked = swiper.snapGrid.length === 1;\n    }\n    if (params.allowSlideNext === true) {\n        swiper.allowSlideNext = !swiper.isLocked;\n    }\n    if (params.allowSlidePrev === true) {\n        swiper.allowSlidePrev = !swiper.isLocked;\n    }\n    if (wasLocked && wasLocked !== swiper.isLocked) {\n        swiper.isEnd = false;\n    }\n    if (wasLocked !== swiper.isLocked) {\n        swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n    }\n}\nvar checkOverflow$1 = {\n    checkOverflow\n};\nvar defaults = {\n    init: true,\n    direction: \"horizontal\",\n    oneWayMovement: false,\n    swiperElementNodeName: \"SWIPER-CONTAINER\",\n    touchEventsTarget: \"wrapper\",\n    initialSlide: 0,\n    speed: 300,\n    cssMode: false,\n    updateOnWindowResize: true,\n    resizeObserver: true,\n    nested: false,\n    createElements: false,\n    eventsPrefix: \"swiper\",\n    enabled: true,\n    focusableElements: \"input, select, option, textarea, button, video, label\",\n    // Overrides\n    width: null,\n    height: null,\n    //\n    preventInteractionOnTransition: false,\n    // ssr\n    userAgent: null,\n    url: null,\n    // To support iOS's swipe-to-go-back gesture (when being used in-app).\n    edgeSwipeDetection: false,\n    edgeSwipeThreshold: 20,\n    // Autoheight\n    autoHeight: false,\n    // Set wrapper width\n    setWrapperSize: false,\n    // Virtual Translate\n    virtualTranslate: false,\n    // Effects\n    effect: \"slide\",\n    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n    // Breakpoints\n    breakpoints: undefined,\n    breakpointsBase: \"window\",\n    // Slides grid\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    slidesPerGroupAuto: false,\n    centeredSlides: false,\n    centeredSlidesBounds: false,\n    slidesOffsetBefore: 0,\n    // in px\n    slidesOffsetAfter: 0,\n    // in px\n    normalizeSlideIndex: true,\n    centerInsufficientSlides: false,\n    // Disable swiper and hide navigation when container not overflow\n    watchOverflow: true,\n    // Round length\n    roundLengths: false,\n    // Touches\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: true,\n    shortSwipes: true,\n    longSwipes: true,\n    longSwipesRatio: 0.5,\n    longSwipesMs: 300,\n    followFinger: true,\n    allowTouchMove: true,\n    threshold: 5,\n    touchMoveStopPropagation: false,\n    touchStartPreventDefault: true,\n    touchStartForcePreventDefault: false,\n    touchReleaseOnEdges: false,\n    // Unique Navigation Elements\n    uniqueNavElements: true,\n    // Resistance\n    resistance: true,\n    resistanceRatio: 0.85,\n    // Progress\n    watchSlidesProgress: false,\n    // Cursor\n    grabCursor: false,\n    // Clicks\n    preventClicks: true,\n    preventClicksPropagation: true,\n    slideToClickedSlide: false,\n    // loop\n    loop: false,\n    loopAddBlankSlides: true,\n    loopAdditionalSlides: 0,\n    loopPreventsSliding: true,\n    // rewind\n    rewind: false,\n    // Swiping/no swiping\n    allowSlidePrev: true,\n    allowSlideNext: true,\n    swipeHandler: null,\n    // '.swipe-handler',\n    noSwiping: true,\n    noSwipingClass: \"swiper-no-swiping\",\n    noSwipingSelector: null,\n    // Passive Listeners\n    passiveListeners: true,\n    maxBackfaceHiddenSlides: 10,\n    // NS\n    containerModifierClass: \"swiper-\",\n    // NEW\n    slideClass: \"swiper-slide\",\n    slideBlankClass: \"swiper-slide-blank\",\n    slideActiveClass: \"swiper-slide-active\",\n    slideVisibleClass: \"swiper-slide-visible\",\n    slideFullyVisibleClass: \"swiper-slide-fully-visible\",\n    slideNextClass: \"swiper-slide-next\",\n    slidePrevClass: \"swiper-slide-prev\",\n    wrapperClass: \"swiper-wrapper\",\n    lazyPreloaderClass: \"swiper-lazy-preloader\",\n    lazyPreloadPrevNext: 0,\n    // Callbacks\n    runCallbacksOnInit: true,\n    // Internals\n    _emitClasses: false\n};\nfunction moduleExtendParams(params, allModulesParams) {\n    return function extendParams(obj) {\n        if (obj === void 0) {\n            obj = {};\n        }\n        const moduleParamName = Object.keys(obj)[0];\n        const moduleParams = obj[moduleParamName];\n        if (typeof moduleParams !== \"object\" || moduleParams === null) {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(allModulesParams, obj);\n            return;\n        }\n        if (params[moduleParamName] === true) {\n            params[moduleParamName] = {\n                enabled: true\n            };\n        }\n        if (moduleParamName === \"navigation\" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n            params[moduleParamName].auto = true;\n        }\n        if ([\n            \"pagination\",\n            \"scrollbar\"\n        ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n            params[moduleParamName].auto = true;\n        }\n        if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(allModulesParams, obj);\n            return;\n        }\n        if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) {\n            params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = {\n            enabled: false\n        };\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(allModulesParams, obj);\n    };\n}\n/* eslint no-param-reassign: \"off\" */ const prototypes = {\n    eventsEmitter,\n    update,\n    translate,\n    transition,\n    slide,\n    loop,\n    grabCursor,\n    events: events$1,\n    breakpoints,\n    checkOverflow: checkOverflow$1,\n    classes\n};\nconst extendedDefaults = {};\nclass Swiper {\n    constructor(){\n        let el;\n        let params;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") {\n            params = args[0];\n        } else {\n            [el, params] = args;\n        }\n        if (!params) params = {};\n        params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, params);\n        if (el && !params.el) params.el = el;\n        const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n        if (params.el && typeof params.el === \"string\" && document1.querySelectorAll(params.el).length > 1) {\n            const swipers = [];\n            document1.querySelectorAll(params.el).forEach((containerEl)=>{\n                const newParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, params, {\n                    el: containerEl\n                });\n                swipers.push(new Swiper(newParams));\n            });\n            // eslint-disable-next-line no-constructor-return\n            return swipers;\n        }\n        // Swiper Instance\n        const swiper = this;\n        swiper.__swiper__ = true;\n        swiper.support = getSupport();\n        swiper.device = getDevice({\n            userAgent: params.userAgent\n        });\n        swiper.browser = getBrowser();\n        swiper.eventsListeners = {};\n        swiper.eventsAnyListeners = [];\n        swiper.modules = [\n            ...swiper.__modules__\n        ];\n        if (params.modules && Array.isArray(params.modules)) {\n            swiper.modules.push(...params.modules);\n        }\n        const allModulesParams = {};\n        swiper.modules.forEach((mod)=>{\n            mod({\n                params,\n                swiper,\n                extendParams: moduleExtendParams(params, allModulesParams),\n                on: swiper.on.bind(swiper),\n                once: swiper.once.bind(swiper),\n                off: swiper.off.bind(swiper),\n                emit: swiper.emit.bind(swiper)\n            });\n        });\n        // Extend defaults with modules params\n        const swiperParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, defaults, allModulesParams);\n        // Extend defaults with passed params\n        swiper.params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, swiperParams, extendedDefaults, params);\n        swiper.originalParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, swiper.params);\n        swiper.passedParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, params);\n        // add event listeners\n        if (swiper.params && swiper.params.on) {\n            Object.keys(swiper.params.on).forEach((eventName)=>{\n                swiper.on(eventName, swiper.params.on[eventName]);\n            });\n        }\n        if (swiper.params && swiper.params.onAny) {\n            swiper.onAny(swiper.params.onAny);\n        }\n        // Extend Swiper\n        Object.assign(swiper, {\n            enabled: swiper.params.enabled,\n            el,\n            // Classes\n            classNames: [],\n            // Slides\n            slides: [],\n            slidesGrid: [],\n            snapGrid: [],\n            slidesSizesGrid: [],\n            // isDirection\n            isHorizontal () {\n                return swiper.params.direction === \"horizontal\";\n            },\n            isVertical () {\n                return swiper.params.direction === \"vertical\";\n            },\n            // Indexes\n            activeIndex: 0,\n            realIndex: 0,\n            //\n            isBeginning: true,\n            isEnd: false,\n            // Props\n            translate: 0,\n            previousTranslate: 0,\n            progress: 0,\n            velocity: 0,\n            animating: false,\n            cssOverflowAdjustment () {\n                // Returns 0 unless `translate` is > 2**23\n                // Should be subtracted from css values to prevent overflow\n                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n            },\n            // Locks\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev,\n            // Touch Events\n            touchEventsData: {\n                isTouched: undefined,\n                isMoved: undefined,\n                allowTouchCallbacks: undefined,\n                touchStartTime: undefined,\n                isScrolling: undefined,\n                currentTranslate: undefined,\n                startTranslate: undefined,\n                allowThresholdMove: undefined,\n                // Form elements to match\n                focusableElements: swiper.params.focusableElements,\n                // Last click time\n                lastClickTime: 0,\n                clickTimeout: undefined,\n                // Velocities\n                velocities: [],\n                allowMomentumBounce: undefined,\n                startMoving: undefined,\n                pointerId: null,\n                touchId: null\n            },\n            // Clicks\n            allowClick: true,\n            // Touches\n            allowTouchMove: swiper.params.allowTouchMove,\n            touches: {\n                startX: 0,\n                startY: 0,\n                currentX: 0,\n                currentY: 0,\n                diff: 0\n            },\n            // Images\n            imagesToLoad: [],\n            imagesLoaded: 0\n        });\n        swiper.emit(\"_swiper\");\n        // Init\n        if (swiper.params.init) {\n            swiper.init();\n        }\n        // Return app instance\n        // eslint-disable-next-line no-constructor-return\n        return swiper;\n    }\n    getDirectionLabel(property) {\n        if (this.isHorizontal()) {\n            return property;\n        }\n        // prettier-ignore\n        return ({\n            \"width\": \"height\",\n            \"margin-top\": \"margin-left\",\n            \"margin-bottom \": \"margin-right\",\n            \"margin-left\": \"margin-top\",\n            \"margin-right\": \"margin-bottom\",\n            \"padding-left\": \"padding-top\",\n            \"padding-right\": \"padding-bottom\",\n            \"marginRight\": \"marginBottom\"\n        })[property];\n    }\n    getSlideIndex(slideEl) {\n        const { slidesEl, params } = this;\n        const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n        const firstSlideIndex = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slides[0]);\n        return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slideEl) - firstSlideIndex;\n    }\n    getSlideIndexByData(index) {\n        return this.getSlideIndex(this.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index)[0]);\n    }\n    recalcSlides() {\n        const swiper = this;\n        const { slidesEl, params } = swiper;\n        swiper.slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n    }\n    enable() {\n        const swiper = this;\n        if (swiper.enabled) return;\n        swiper.enabled = true;\n        if (swiper.params.grabCursor) {\n            swiper.setGrabCursor();\n        }\n        swiper.emit(\"enable\");\n    }\n    disable() {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        swiper.enabled = false;\n        if (swiper.params.grabCursor) {\n            swiper.unsetGrabCursor();\n        }\n        swiper.emit(\"disable\");\n    }\n    setProgress(progress, speed) {\n        const swiper = this;\n        progress = Math.min(Math.max(progress, 0), 1);\n        const min = swiper.minTranslate();\n        const max = swiper.maxTranslate();\n        const current = (max - min) * progress + min;\n        swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n    }\n    emitContainerClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const cls = swiper.el.className.split(\" \").filter((className)=>{\n            return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n        });\n        swiper.emit(\"_containerClasses\", cls.join(\" \"));\n    }\n    getSlideClasses(slideEl) {\n        const swiper = this;\n        if (swiper.destroyed) return \"\";\n        return slideEl.className.split(\" \").filter((className)=>{\n            return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n        }).join(\" \");\n    }\n    emitSlidesClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const updates = [];\n        swiper.slides.forEach((slideEl)=>{\n            const classNames = swiper.getSlideClasses(slideEl);\n            updates.push({\n                slideEl,\n                classNames\n            });\n            swiper.emit(\"_slideClass\", slideEl, classNames);\n        });\n        swiper.emit(\"_slideClasses\", updates);\n    }\n    slidesPerViewDynamic(view, exact) {\n        if (view === void 0) {\n            view = \"current\";\n        }\n        if (exact === void 0) {\n            exact = false;\n        }\n        const swiper = this;\n        const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;\n        let spv = 1;\n        if (typeof params.slidesPerView === \"number\") return params.slidesPerView;\n        if (params.centeredSlides) {\n            let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;\n            let breakLoop;\n            for(let i = activeIndex + 1; i < slides.length; i += 1){\n                if (slides[i] && !breakLoop) {\n                    slideSize += Math.ceil(slides[i].swiperSlideSize);\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            }\n            for(let i = activeIndex - 1; i >= 0; i -= 1){\n                if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            }\n        } else {\n            // eslint-disable-next-line\n            if (view === \"current\") {\n                for(let i = activeIndex + 1; i < slides.length; i += 1){\n                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n                    if (slideInView) {\n                        spv += 1;\n                    }\n                }\n            } else {\n                // previous\n                for(let i = activeIndex - 1; i >= 0; i -= 1){\n                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n                    if (slideInView) {\n                        spv += 1;\n                    }\n                }\n            }\n        }\n        return spv;\n    }\n    update() {\n        const swiper = this;\n        if (!swiper || swiper.destroyed) return;\n        const { snapGrid, params } = swiper;\n        // Breakpoints\n        if (params.breakpoints) {\n            swiper.setBreakpoint();\n        }\n        [\n            ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n        ].forEach((imageEl)=>{\n            if (imageEl.complete) {\n                processLazyPreloader(swiper, imageEl);\n            }\n        });\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        function setTranslate() {\n            const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n            const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n            swiper.setTranslate(newTranslate);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        let translated;\n        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n            setTranslate();\n            if (params.autoHeight) {\n                swiper.updateAutoHeight();\n            }\n        } else {\n            if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n                const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n                translated = swiper.slideTo(slides.length - 1, 0, false, true);\n            } else {\n                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n            }\n            if (!translated) {\n                setTranslate();\n            }\n        }\n        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n            swiper.checkOverflow();\n        }\n        swiper.emit(\"update\");\n    }\n    changeDirection(newDirection, needUpdate) {\n        if (needUpdate === void 0) {\n            needUpdate = true;\n        }\n        const swiper = this;\n        const currentDirection = swiper.params.direction;\n        if (!newDirection) {\n            // eslint-disable-next-line\n            newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n        }\n        if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") {\n            return swiper;\n        }\n        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n        swiper.emitContainerClasses();\n        swiper.params.direction = newDirection;\n        swiper.slides.forEach((slideEl)=>{\n            if (newDirection === \"vertical\") {\n                slideEl.style.width = \"\";\n            } else {\n                slideEl.style.height = \"\";\n            }\n        });\n        swiper.emit(\"changeDirection\");\n        if (needUpdate) swiper.update();\n        return swiper;\n    }\n    changeLanguageDirection(direction) {\n        const swiper = this;\n        if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\") return;\n        swiper.rtl = direction === \"rtl\";\n        swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n        if (swiper.rtl) {\n            swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n            swiper.el.dir = \"rtl\";\n        } else {\n            swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n            swiper.el.dir = \"ltr\";\n        }\n        swiper.update();\n    }\n    mount(element) {\n        const swiper = this;\n        if (swiper.mounted) return true;\n        // Find el\n        let el = element || swiper.params.el;\n        if (typeof el === \"string\") {\n            el = document.querySelector(el);\n        }\n        if (!el) {\n            return false;\n        }\n        el.swiper = swiper;\n        if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {\n            swiper.isElement = true;\n        }\n        const getWrapperSelector = ()=>{\n            return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n        };\n        const getWrapper = ()=>{\n            if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                const res = el.shadowRoot.querySelector(getWrapperSelector());\n                // Children needs to return slot items\n                return res;\n            }\n            return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, getWrapperSelector())[0];\n        };\n        // Find Wrapper\n        let wrapperEl = getWrapper();\n        if (!wrapperEl && swiper.params.createElements) {\n            wrapperEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"div\", swiper.params.wrapperClass);\n            el.append(wrapperEl);\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, `.${swiper.params.slideClass}`).forEach((slideEl)=>{\n                wrapperEl.append(slideEl);\n            });\n        }\n        Object.assign(swiper, {\n            el,\n            wrapperEl,\n            slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n            hostEl: swiper.isElement ? el.parentNode.host : el,\n            mounted: true,\n            // RTL\n            rtl: el.dir.toLowerCase() === \"rtl\" || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"direction\") === \"rtl\",\n            rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"direction\") === \"rtl\"),\n            wrongRTL: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(wrapperEl, \"display\") === \"-webkit-box\"\n        });\n        return true;\n    }\n    init(el) {\n        const swiper = this;\n        if (swiper.initialized) return swiper;\n        const mounted = swiper.mount(el);\n        if (mounted === false) return swiper;\n        swiper.emit(\"beforeInit\");\n        // Set breakpoint\n        if (swiper.params.breakpoints) {\n            swiper.setBreakpoint();\n        }\n        // Add Classes\n        swiper.addClasses();\n        // Update size\n        swiper.updateSize();\n        // Update slides\n        swiper.updateSlides();\n        if (swiper.params.watchOverflow) {\n            swiper.checkOverflow();\n        }\n        // Set Grab Cursor\n        if (swiper.params.grabCursor && swiper.enabled) {\n            swiper.setGrabCursor();\n        }\n        // Slide To Initial Slide\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n            swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n        } else {\n            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n        }\n        // Create loop\n        if (swiper.params.loop) {\n            swiper.loopCreate();\n        }\n        // Attach events\n        swiper.attachEvents();\n        const lazyElements = [\n            ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n        ];\n        if (swiper.isElement) {\n            lazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n        }\n        lazyElements.forEach((imageEl)=>{\n            if (imageEl.complete) {\n                processLazyPreloader(swiper, imageEl);\n            } else {\n                imageEl.addEventListener(\"load\", (e)=>{\n                    processLazyPreloader(swiper, e.target);\n                });\n            }\n        });\n        preload(swiper);\n        // Init Flag\n        swiper.initialized = true;\n        preload(swiper);\n        // Emit\n        swiper.emit(\"init\");\n        swiper.emit(\"afterInit\");\n        return swiper;\n    }\n    destroy(deleteInstance, cleanStyles) {\n        if (deleteInstance === void 0) {\n            deleteInstance = true;\n        }\n        if (cleanStyles === void 0) {\n            cleanStyles = true;\n        }\n        const swiper = this;\n        const { params, el, wrapperEl, slides } = swiper;\n        if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n            return null;\n        }\n        swiper.emit(\"beforeDestroy\");\n        // Init Flag\n        swiper.initialized = false;\n        // Detach events\n        swiper.detachEvents();\n        // Destroy loop\n        if (params.loop) {\n            swiper.loopDestroy();\n        }\n        // Cleanup styles\n        if (cleanStyles) {\n            swiper.removeClasses();\n            el.removeAttribute(\"style\");\n            wrapperEl.removeAttribute(\"style\");\n            if (slides && slides.length) {\n                slides.forEach((slideEl)=>{\n                    slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n                    slideEl.removeAttribute(\"style\");\n                    slideEl.removeAttribute(\"data-swiper-slide-index\");\n                });\n            }\n        }\n        swiper.emit(\"destroy\");\n        // Detach emitter events\n        Object.keys(swiper.eventsListeners).forEach((eventName)=>{\n            swiper.off(eventName);\n        });\n        if (deleteInstance !== false) {\n            swiper.el.swiper = null;\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.v)(swiper);\n        }\n        swiper.destroyed = true;\n        return null;\n    }\n    static extendDefaults(newDefaults) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(extendedDefaults, newDefaults);\n    }\n    static get extendedDefaults() {\n        return extendedDefaults;\n    }\n    static get defaults() {\n        return defaults;\n    }\n    static installModule(mod) {\n        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n        const modules = Swiper.prototype.__modules__;\n        if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n            modules.push(mod);\n        }\n    }\n    static use(module) {\n        if (Array.isArray(module)) {\n            module.forEach((m)=>Swiper.installModule(m));\n            return Swiper;\n        }\n        Swiper.installModule(module);\n        return Swiper;\n    }\n}\nObject.keys(prototypes).forEach((prototypeGroup)=>{\n    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod)=>{\n        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n    });\n});\nSwiper.use([\n    Resize,\n    Observer\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9zd2lwZXItY29yZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTtBQUN3UTtBQUVoVixJQUFJbUM7QUFDSixTQUFTQztJQUNQLE1BQU1DLFVBQVNwQyxzREFBU0E7SUFDeEIsTUFBTXFDLFlBQVduQyxzREFBV0E7SUFDNUIsT0FBTztRQUNMb0MsY0FBY0QsVUFBU0UsZUFBZSxJQUFJRixVQUFTRSxlQUFlLENBQUNDLEtBQUssSUFBSSxvQkFBb0JILFVBQVNFLGVBQWUsQ0FBQ0MsS0FBSztRQUM5SEMsT0FBTyxDQUFDLENBQUUsbUJBQWtCTCxXQUFVQSxRQUFPTSxhQUFhLElBQUlMLHFCQUFvQkQsUUFBT00sYUFBYTtJQUN4RztBQUNGO0FBQ0EsU0FBU0M7SUFDUCxJQUFJLENBQUNULFNBQVM7UUFDWkEsVUFBVUM7SUFDWjtJQUNBLE9BQU9EO0FBQ1Q7QUFFQSxJQUFJVTtBQUNKLFNBQVNDLFdBQVdDLEtBQUs7SUFDdkIsSUFBSSxFQUNGQyxTQUFTLEVBQ1YsR0FBR0QsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUM1QixNQUFNWixVQUFVUztJQUNoQixNQUFNUCxVQUFTcEMsc0RBQVNBO0lBQ3hCLE1BQU1nRCxXQUFXWixRQUFPYSxTQUFTLENBQUNELFFBQVE7SUFDMUMsTUFBTUUsS0FBS0gsYUFBYVgsUUFBT2EsU0FBUyxDQUFDRixTQUFTO0lBQ2xELE1BQU1JLFNBQVM7UUFDYkMsS0FBSztRQUNMQyxTQUFTO0lBQ1g7SUFDQSxNQUFNQyxjQUFjbEIsUUFBT21CLE1BQU0sQ0FBQ0MsS0FBSztJQUN2QyxNQUFNQyxlQUFlckIsUUFBT21CLE1BQU0sQ0FBQ0csTUFBTTtJQUN6QyxNQUFNTCxVQUFVSCxHQUFHUyxLQUFLLENBQUMsZ0NBQWdDLHNCQUFzQjtJQUMvRSxJQUFJQyxPQUFPVixHQUFHUyxLQUFLLENBQUM7SUFDcEIsTUFBTUUsT0FBT1gsR0FBR1MsS0FBSyxDQUFDO0lBQ3RCLE1B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O1FBQ3BCLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPc0UsY0FBYzVDLEdBQUcsRUFBRTtRQUN4QixJQUFJLENBQUNULE9BQU9DLFNBQVMsQ0FBQ08sV0FBVyxFQUFFUixPQUFPQyxTQUFTLENBQUNPLFdBQVcsR0FBRyxFQUFFO1FBQ3BFLE1BQU1ELFVBQVVQLE9BQU9DLFNBQVMsQ0FBQ08sV0FBVztRQUM1QyxJQUFJLE9BQU9DLFFBQVEsY0FBY0YsUUFBUXpxQixPQUFPLENBQUMycUIsT0FBTyxHQUFHO1lBQ3pERixRQUFRbG1CLElBQUksQ0FBQ29tQjtRQUNmO0lBQ0Y7SUFDQSxPQUFPNkMsSUFBSUMsTUFBTSxFQUFFO1FBQ2pCLElBQUl4bkIsTUFBTVksT0FBTyxDQUFDNG1CLFNBQVM7WUFDekJBLE9BQU9uckIsT0FBTyxDQUFDb3JCLENBQUFBLElBQUt4RCxPQUFPcUQsYUFBYSxDQUFDRztZQUN6QyxPQUFPeEQ7UUFDVDtRQUNBQSxPQUFPcUQsYUFBYSxDQUFDRTtRQUNyQixPQUFPdkQ7SUFDVDtBQUNGO0FBQ0ExaUIsT0FBT3FELElBQUksQ0FBQ21mLFlBQVkxbkIsT0FBTyxDQUFDcXJCLENBQUFBO0lBQzlCbm1CLE9BQU9xRCxJQUFJLENBQUNtZixVQUFVLENBQUMyRCxlQUFlLEVBQUVyckIsT0FBTyxDQUFDc3JCLENBQUFBO1FBQzlDMUQsT0FBT0MsU0FBUyxDQUFDeUQsWUFBWSxHQUFHNUQsVUFBVSxDQUFDMkQsZUFBZSxDQUFDQyxZQUFZO0lBQ3pFO0FBQ0Y7QUFDQTFELE9BQU9zRCxHQUFHLENBQUM7SUFBQ2xzQjtJQUFRaUM7Q0FBUztBQUVTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluZm8tbmV4dC8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3N3aXBlci1jb3JlLm1qcz9mMmZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGEgYXMgZ2V0V2luZG93LCBnIGFzIGdldERvY3VtZW50IH0gZnJvbSAnLi9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgYSBhcyBlbGVtZW50UGFyZW50cywgbyBhcyBlbGVtZW50U3R5bGUsIGUgYXMgZWxlbWVudENoaWxkcmVuLCBzIGFzIHNldENTU1Byb3BlcnR5LCBmIGFzIGVsZW1lbnRPdXRlclNpemUsIHAgYXMgZWxlbWVudE5leHRBbGwsIHEgYXMgZWxlbWVudFByZXZBbGwsIGogYXMgZ2V0VHJhbnNsYXRlLCByIGFzIGFuaW1hdGVDU1NNb2RlU2Nyb2xsLCBuIGFzIG5leHRUaWNrLCB0IGFzIHNob3dXYXJuaW5nLCBjIGFzIGNyZWF0ZUVsZW1lbnQsIGQgYXMgbm93LCB1IGFzIGV4dGVuZCwgaCBhcyBlbGVtZW50SW5kZXgsIHYgYXMgZGVsZXRlUHJvcHMgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmxldCBzdXBwb3J0O1xuZnVuY3Rpb24gY2FsY1N1cHBvcnQoKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIHJldHVybiB7XG4gICAgc21vb3RoU2Nyb2xsOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmICdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgIHRvdWNoOiAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1cHBvcnQoKSB7XG4gIGlmICghc3VwcG9ydCkge1xuICAgIHN1cHBvcnQgPSBjYWxjU3VwcG9ydCgpO1xuICB9XG4gIHJldHVybiBzdXBwb3J0O1xufVxuXG5sZXQgZGV2aWNlQ2FjaGVkO1xuZnVuY3Rpb24gY2FsY0RldmljZShfdGVtcCkge1xuICBsZXQge1xuICAgIHVzZXJBZ2VudFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IHN1cHBvcnQgPSBnZXRTdXBwb3J0KCk7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBwbGF0Zm9ybSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm07XG4gIGNvbnN0IHVhID0gdXNlckFnZW50IHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICBjb25zdCBkZXZpY2UgPSB7XG4gICAgaW9zOiBmYWxzZSxcbiAgICBhbmRyb2lkOiBmYWxzZVxuICB9O1xuICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gIGNvbnN0IHNjcmVlbkhlaWdodCA9IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGxldCBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgY29uc3QgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gIGNvbnN0IGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pO1xuICBjb25zdCB3aW5kb3dzID0gcGxhdGZvcm0gPT09ICdXaW4zMic7XG4gIGxldCBtYWNvcyA9IHBsYXRmb3JtID09PSAnTWFjSW50ZWwnO1xuXG4gIC8vIGlQYWRPcyAxMyBmaXhcbiAgY29uc3QgaVBhZFNjcmVlbnMgPSBbJzEwMjR4MTM2NicsICcxMzY2eDEwMjQnLCAnODM0eDExOTQnLCAnMTE5NHg4MzQnLCAnODM0eDExMTInLCAnMTExMng4MzQnLCAnNzY4eDEwMjQnLCAnMTAyNHg3NjgnLCAnODIweDExODAnLCAnMTE4MHg4MjAnLCAnODEweDEwODAnLCAnMTA4MHg4MTAnXTtcbiAgaWYgKCFpcGFkICYmIG1hY29zICYmIHN1cHBvcnQudG91Y2ggJiYgaVBhZFNjcmVlbnMuaW5kZXhPZihgJHtzY3JlZW5XaWR0aH14JHtzY3JlZW5IZWlnaHR9YCkgPj0gMCkge1xuICAgIGlwYWQgPSB1YS5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLyk7XG4gICAgaWYgKCFpcGFkKSBpcGFkID0gWzAsIDEsICcxM18wXzAnXTtcbiAgICBtYWNvcyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQW5kcm9pZFxuICBpZiAoYW5kcm9pZCAmJiAhd2luZG93cykge1xuICAgIGRldmljZS5vcyA9ICdhbmRyb2lkJztcbiAgICBkZXZpY2UuYW5kcm9pZCA9IHRydWU7XG4gIH1cbiAgaWYgKGlwYWQgfHwgaXBob25lIHx8IGlwb2QpIHtcbiAgICBkZXZpY2Uub3MgPSAnaW9zJztcbiAgICBkZXZpY2UuaW9zID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBvYmplY3RcbiAgcmV0dXJuIGRldmljZTtcbn1cbmZ1bmN0aW9uIGdldERldmljZShvdmVycmlkZXMpIHtcbiAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnJpZGVzID0ge307XG4gIH1cbiAgaWYgKCFkZXZpY2VDYWNoZWQpIHtcbiAgICBkZXZpY2VDYWNoZWQgPSBjYWxjRGV2aWNlKG92ZXJyaWRlcyk7XG4gIH1cbiAgcmV0dXJuIGRldmljZUNhY2hlZDtcbn1cblxubGV0IGJyb3dzZXI7XG5mdW5jdGlvbiBjYWxjQnJvd3NlcigpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IGRldmljZSA9IGdldERldmljZSgpO1xuICBsZXQgbmVlZFBlcnNwZWN0aXZlRml4ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIGNvbnN0IHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdWEuaW5kZXhPZignc2FmYXJpJykgPj0gMCAmJiB1YS5pbmRleE9mKCdjaHJvbWUnKSA8IDAgJiYgdWEuaW5kZXhPZignYW5kcm9pZCcpIDwgMDtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IHVhID0gU3RyaW5nKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAodWEuaW5jbHVkZXMoJ1ZlcnNpb24vJykpIHtcbiAgICAgIGNvbnN0IFttYWpvciwgbWlub3JdID0gdWEuc3BsaXQoJ1ZlcnNpb24vJylbMV0uc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpLm1hcChudW0gPT4gTnVtYmVyKG51bSkpO1xuICAgICAgbmVlZFBlcnNwZWN0aXZlRml4ID0gbWFqb3IgPCAxNiB8fCBtYWpvciA9PT0gMTYgJiYgbWlub3IgPCAyO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc1dlYlZpZXcgPSAvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCBpc1NhZmFyaUJyb3dzZXIgPSBpc1NhZmFyaSgpO1xuICBjb25zdCBuZWVkM2RGaXggPSBpc1NhZmFyaUJyb3dzZXIgfHwgaXNXZWJWaWV3ICYmIGRldmljZS5pb3M7XG4gIHJldHVybiB7XG4gICAgaXNTYWZhcmk6IG5lZWRQZXJzcGVjdGl2ZUZpeCB8fCBpc1NhZmFyaUJyb3dzZXIsXG4gICAgbmVlZFBlcnNwZWN0aXZlRml4LFxuICAgIG5lZWQzZEZpeCxcbiAgICBpc1dlYlZpZXdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gIGlmICghYnJvd3Nlcikge1xuICAgIGJyb3dzZXIgPSBjYWxjQnJvd3NlcigpO1xuICB9XG4gIHJldHVybiBicm93c2VyO1xufVxuXG5mdW5jdGlvbiBSZXNpemUoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBvbixcbiAgICBlbWl0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBlbWl0KCdiZWZvcmVSZXNpemUnKTtcbiAgICBlbWl0KCdyZXNpemUnKTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBhbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb250ZW50Qm94U2l6ZSxcbiAgICAgICAgICAgIGNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgICBuZXdXaWR0aCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3Qud2lkdGggOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmlubGluZVNpemU7XG4gICAgICAgICAgbmV3SGVpZ2h0ID0gY29udGVudFJlY3QgPyBjb250ZW50UmVjdC5oZWlnaHQgOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmJsb2NrU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdXaWR0aCAhPT0gd2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICByZXNpemVIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoc3dpcGVyLmVsKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIudW5vYnNlcnZlICYmIHN3aXBlci5lbCkge1xuICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9O1xuICBjb25zdCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgZW1pdCgnb3JpZW50YXRpb25jaGFuZ2UnKTtcbiAgfTtcbiAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucmVzaXplT2JzZXJ2ZXIgJiYgdHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNyZWF0ZU9ic2VydmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpO1xuICB9KTtcbiAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIoKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgb3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIE9ic2VydmVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uLFxuICAgIGVtaXRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG9ic2VydmVycyA9IFtdO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgYXR0YWNoID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXJGdW5jKG11dGF0aW9ucyA9PiB7XG4gICAgICAvLyBUaGUgb2JzZXJ2ZXJVcGRhdGUgZXZlbnQgc2hvdWxkIG9ubHkgYmUgdHJpZ2dlcmVkXG4gICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXG4gICAgICAvLyB0cmlnZ2VycyBhcmUgcmVkdW5kYW50IGFuZCBhcmUgdmVyeSBjb3N0bHlcbiAgICAgIGlmIChzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXykgcmV0dXJuO1xuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICBlbWl0KCdvYnNlcnZlclVwZGF0ZScsIG11dGF0aW9uc1swXSk7XG4gICAgICB9O1xuICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChvYnNlcnZlclVwZGF0ZSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkTGlzdDogdHlwZW9mIG9wdGlvbnMuY2hpbGRMaXN0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLmNoaWxkTGlzdCxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHR5cGVvZiBvcHRpb25zLmNoYXJhY3RlckRhdGEgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuY2hhcmFjdGVyRGF0YVxuICAgIH0pO1xuICAgIG9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgfTtcbiAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMub2JzZXJ2ZXIpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xuICAgICAgY29uc3QgY29udGFpbmVyUGFyZW50cyA9IGVsZW1lbnRQYXJlbnRzKHN3aXBlci5ob3N0RWwpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJQYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGF0dGFjaChjb250YWluZXJQYXJlbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT2JzZXJ2ZSBjb250YWluZXJcbiAgICBhdHRhY2goc3dpcGVyLmhvc3RFbCwge1xuICAgICAgY2hpbGRMaXN0OiBzd2lwZXIucGFyYW1zLm9ic2VydmVTbGlkZUNoaWxkcmVuXG4gICAgfSk7XG5cbiAgICAvLyBPYnNlcnZlIHdyYXBwZXJcbiAgICBhdHRhY2goc3dpcGVyLndyYXBwZXJFbCwge1xuICAgICAgYXR0cmlidXRlczogZmFsc2VcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJzLnNwbGljZSgwLCBvYnNlcnZlcnMubGVuZ3RoKTtcbiAgfTtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBvYnNlcnZlcjogZmFsc2UsXG4gICAgb2JzZXJ2ZVBhcmVudHM6IGZhbHNlLFxuICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiBmYWxzZVxuICB9KTtcbiAgb24oJ2luaXQnLCBpbml0KTtcbiAgb24oJ2Rlc3Ryb3knLCBkZXN0cm95KTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxudmFyIGV2ZW50c0VtaXR0ZXIgPSB7XG4gIG9uKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9uY2UoZXZlbnRzLCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICBzZWxmLm9mZihldmVudHMsIG9uY2VIYW5kbGVyKTtcbiAgICAgIGlmIChvbmNlSGFuZGxlci5fX2VtaXR0ZXJQcm94eSkge1xuICAgICAgICBkZWxldGUgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5ID0gaGFuZGxlcjtcbiAgICByZXR1cm4gc2VsZi5vbihldmVudHMsIG9uY2VIYW5kbGVyLCBwcmlvcml0eSk7XG4gIH0sXG4gIG9uQW55KGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycyB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICBjb25zdCBtZXRob2QgPSBwcmlvcml0eSA/ICd1bnNoaWZ0JyA6ICdwdXNoJztcbiAgICBpZiAoc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKSA8IDApIHtcbiAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBvZmZBbnkoaGFuZGxlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICghc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IGluZGV4ID0gc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIgfHwgZXZlbnRIYW5kbGVyLl9fZW1pdHRlclByb3h5ICYmIGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgZW1pdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBsZXQgZXZlbnRzO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF07XG4gICAgICBkYXRhID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCk7XG4gICAgICBjb250ZXh0ID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gYXJnc1swXS5ldmVudHM7XG4gICAgICBkYXRhID0gYXJnc1swXS5kYXRhO1xuICAgICAgY29udGV4dCA9IGFyZ3NbMF0uY29udGV4dCB8fCBzZWxmO1xuICAgIH1cbiAgICBkYXRhLnVuc2hpZnQoY29udGV4dCk7XG4gICAgY29uc3QgZXZlbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICBldmVudHNBcnJheS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5hcHBseShjb250ZXh0LCBbZXZlbnQsIC4uLmRhdGFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnMgJiYgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGV2ZW50SGFuZGxlciA9PiB7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IHdpZHRoO1xuICBsZXQgaGVpZ2h0O1xuICBjb25zdCBlbCA9IHN3aXBlci5lbDtcbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJyAmJiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSBudWxsKSB7XG4gICAgd2lkdGggPSBzd2lwZXIucGFyYW1zLndpZHRoO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgJiYgc3dpcGVyLnBhcmFtcy5oZWlnaHQgIT09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBzd2lwZXIucGFyYW1zLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gIH1cbiAgaWYgKHdpZHRoID09PSAwICYmIHN3aXBlci5pc0hvcml6b250YWwoKSB8fCBoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFN1YnRyYWN0IHBhZGRpbmdzXG4gIHdpZHRoID0gd2lkdGggLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLWxlZnQnKSB8fCAwLCAxMCkgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXJpZ2h0JykgfHwgMCwgMTApO1xuICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXRvcCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KGVsZW1lbnRTdHlsZShlbCwgJ3BhZGRpbmctYm90dG9tJykgfHwgMCwgMTApO1xuICBpZiAoTnVtYmVyLmlzTmFOKHdpZHRoKSkgd2lkdGggPSAwO1xuICBpZiAoTnVtYmVyLmlzTmFOKGhlaWdodCkpIGhlaWdodCA9IDA7XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHNpemU6IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHdpZHRoIDogaGVpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUobm9kZSwgbGFiZWwpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChub2RlLmdldFByb3BlcnR5VmFsdWUoc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKGxhYmVsKSkgfHwgMCk7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3Qge1xuICAgIHdyYXBwZXJFbCxcbiAgICBzbGlkZXNFbCxcbiAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHdyb25nUlRMXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICBjb25zdCBzbGlkZXMgPSBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHNsaWRlcy5sZW5ndGg7XG4gIGxldCBzbmFwR3JpZCA9IFtdO1xuICBjb25zdCBzbGlkZXNHcmlkID0gW107XG4gIGNvbnN0IHNsaWRlc1NpemVzR3JpZCA9IFtdO1xuICBsZXQgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZTtcbiAgaWYgKHR5cGVvZiBvZmZzZXRCZWZvcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRCZWZvcmUgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlLmNhbGwoc3dpcGVyKTtcbiAgfVxuICBsZXQgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0QWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKHN3aXBlcik7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNTbmFwR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCA9IHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aDtcbiAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gIGxldCBzbGlkZVBvc2l0aW9uID0gLW9mZnNldEJlZm9yZTtcbiAgbGV0IHByZXZTbGlkZVNpemUgPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCAqIHN3aXBlclNpemU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbik7XG4gIH1cbiAgc3dpcGVyLnZpcnR1YWxTaXplID0gLXNwYWNlQmV0d2VlbjtcblxuICAvLyByZXNldCBtYXJnaW5zXG4gIHNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIGlmIChydGwpIHtcbiAgICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luTGVmdCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZUVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJyc7XG4gICAgfVxuICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luQm90dG9tID0gJyc7XG4gICAgc2xpZGVFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgfSk7XG5cbiAgLy8gcmVzZXQgY3NzTW9kZSBvZmZzZXRzXG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICBzZXRDU1NQcm9wZXJ0eSh3cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlJywgJycpO1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsICcnKTtcbiAgfVxuICBjb25zdCBncmlkRW5hYmxlZCA9IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHN3aXBlci5ncmlkO1xuICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICBzd2lwZXIuZ3JpZC5pbml0U2xpZGVzKHNsaWRlcyk7XG4gIH0gZWxzZSBpZiAoc3dpcGVyLmdyaWQpIHtcbiAgICBzd2lwZXIuZ3JpZC51bnNldFNsaWRlcygpO1xuICB9XG5cbiAgLy8gQ2FsYyBzbGlkZXNcbiAgbGV0IHNsaWRlU2l6ZTtcbiAgY29uc3Qgc2hvdWxkUmVzZXRTbGlkZVNpemUgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5icmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhwYXJhbXMuYnJlYWtwb2ludHMpLmZpbHRlcihrZXkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW1zLmJyZWFrcG9pbnRzW2tleV0uc2xpZGVzUGVyVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZVNpemUgPSAwO1xuICAgIGxldCBzbGlkZTtcbiAgICBpZiAoc2xpZGVzW2ldKSBzbGlkZSA9IHNsaWRlc1tpXTtcbiAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVNsaWRlKGksIHNsaWRlLCBzbGlkZXMpO1xuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldICYmIGVsZW1lbnRTdHlsZShzbGlkZSwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgIGlmIChzaG91bGRSZXNldFNsaWRlU2l6ZSkge1xuICAgICAgICBzbGlkZXNbaV0uc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGBgO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xpZGVTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNsaWRlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBzbGlkZS5zdHlsZS50cmFuc2Zvcm07XG4gICAgICBjb25zdCBjdXJyZW50V2ViS2l0VHJhbnNmb3JtID0gc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICAgICAgc2xpZGVTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZWxlbWVudE91dGVyU2l6ZShzbGlkZSwgJ3dpZHRoJywgdHJ1ZSkgOiBlbGVtZW50T3V0ZXJTaXplKHNsaWRlLCAnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnd2lkdGgnKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ0xlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAncGFkZGluZy1sZWZ0Jyk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLWxlZnQnKTtcbiAgICAgICAgY29uc3QgbWFyZ2luUmlnaHQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IGJveFNpemluZyA9IHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcbiAgICAgICAgaWYgKGJveFNpemluZyAmJiBib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgICAgIHNsaWRlU2l6ZSA9IHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNsaWVudFdpZHRoLFxuICAgICAgICAgICAgb2Zmc2V0V2lkdGhcbiAgICAgICAgICB9ID0gc2xpZGU7XG4gICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodCArIChvZmZzZXRXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50V2ViS2l0VHJhbnNmb3JtKSB7XG4gICAgICAgIHNsaWRlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVTaXplID0gTWF0aC5mbG9vcihzbGlkZVNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZVNpemUgPSAoc3dpcGVyU2l6ZSAtIChwYXJhbXMuc2xpZGVzUGVyVmlldyAtIDEpICogc3BhY2VCZXR3ZWVuKSAvIHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcbiAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgc2xpZGVzW2ldLnN0eWxlW3N3aXBlci5nZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBgJHtzbGlkZVNpemV9cHhgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldKSB7XG4gICAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplID0gc2xpZGVTaXplO1xuICAgIH1cbiAgICBzbGlkZXNTaXplc0dyaWQucHVzaChzbGlkZVNpemUpO1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplIC8gMiArIHByZXZTbGlkZVNpemUgLyAyICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgIGlmIChpID09PSAwKSBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiAtIHN3aXBlclNpemUgLyAyIC0gc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKE1hdGguYWJzKHNsaWRlUG9zaXRpb24pIDwgMSAvIDEwMDApIHNsaWRlUG9zaXRpb24gPSAwO1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgaWYgKGluZGV4ICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVQb3NpdGlvbiA9IE1hdGguZmxvb3Ioc2xpZGVQb3NpdGlvbik7XG4gICAgICBpZiAoKGluZGV4IC0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KSkgJSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgfVxuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSArPSBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgcHJldlNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICBpbmRleCArPSAxO1xuICB9XG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHN3aXBlci52aXJ0dWFsU2l6ZSwgc3dpcGVyU2l6ZSkgKyBvZmZzZXRBZnRlcjtcbiAgaWYgKHJ0bCAmJiB3cm9uZ1JUTCAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnY292ZXJmbG93JykpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGUud2lkdGggPSBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBzcGFjZUJldHdlZW59cHhgO1xuICB9XG4gIGlmIChwYXJhbXMuc2V0V3JhcHBlclNpemUpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHNwYWNlQmV0d2Vlbn1weGA7XG4gIH1cbiAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgc3dpcGVyLmdyaWQudXBkYXRlV3JhcHBlclNpemUoc2xpZGVTaXplLCBzbmFwR3JpZCk7XG4gIH1cblxuICAvLyBSZW1vdmUgbGFzdCBncmlkIGVsZW1lbnRzIGRlcGVuZGluZyBvbiB3aWR0aFxuICBpZiAoIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgIGNvbnN0IG5ld1NsaWRlc0dyaWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgc2xpZGVzR3JpZEl0ZW0gPSBzbmFwR3JpZFtpXTtcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xuICAgICAgaWYgKHNuYXBHcmlkW2ldIDw9IHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIHtcbiAgICAgICAgbmV3U2xpZGVzR3JpZC5wdXNoKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc25hcEdyaWQgPSBuZXdTbGlkZXNHcmlkO1xuICAgIGlmIChNYXRoLmZsb29yKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIC0gTWF0aC5mbG9vcihzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSkgPiAxKSB7XG4gICAgICBzbmFwR3JpZC5wdXNoKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHNsaWRlc1NpemVzR3JpZFswXSArIHNwYWNlQmV0d2VlbjtcbiAgICBpZiAocGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSkge1xuICAgICAgY29uc3QgZ3JvdXBzID0gTWF0aC5jZWlsKChzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmUgKyBzd2lwZXIudmlydHVhbC5zbGlkZXNBZnRlcikgLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgY29uc3QgZ3JvdXBTaXplID0gc2l6ZSAqIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzOyBpICs9IDEpIHtcbiAgICAgICAgc25hcEdyaWQucHVzaChzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSArIGdyb3VwU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlICsgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQWZ0ZXI7IGkgKz0gMSkge1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSkge1xuICAgICAgICBzbmFwR3JpZC5wdXNoKHNuYXBHcmlkW3NuYXBHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICB9XG4gICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICBzd2lwZXIudmlydHVhbFNpemUgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCA9PT0gMCkgc25hcEdyaWQgPSBbMF07XG4gIGlmIChzcGFjZUJldHdlZW4gIT09IDApIHtcbiAgICBjb25zdCBrZXkgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgcnRsID8gJ21hcmdpbkxlZnQnIDogc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCdtYXJnaW5SaWdodCcpO1xuICAgIHNsaWRlcy5maWx0ZXIoKF8sIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGlmICghcGFyYW1zLmNzc01vZGUgfHwgcGFyYW1zLmxvb3ApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHNsaWRlSW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBzbGlkZUVsLnN0eWxlW2tleV0gPSBgJHtzcGFjZUJldHdlZW59cHhgO1xuICAgIH0pO1xuICB9XG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgIHNsaWRlc1NpemVzR3JpZC5mb3JFYWNoKHNsaWRlU2l6ZVZhbHVlID0+IHtcbiAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAoc3BhY2VCZXR3ZWVuIHx8IDApO1xuICAgIH0pO1xuICAgIGFsbFNsaWRlc1NpemUgLT0gc3BhY2VCZXR3ZWVuO1xuICAgIGNvbnN0IG1heFNuYXAgPSBhbGxTbGlkZXNTaXplIC0gc3dpcGVyU2l6ZTtcbiAgICBzbmFwR3JpZCA9IHNuYXBHcmlkLm1hcChzbmFwID0+IHtcbiAgICAgIGlmIChzbmFwIDw9IDApIHJldHVybiAtb2Zmc2V0QmVmb3JlO1xuICAgICAgaWYgKHNuYXAgPiBtYXhTbmFwKSByZXR1cm4gbWF4U25hcCArIG9mZnNldEFmdGVyO1xuICAgICAgcmV0dXJuIHNuYXA7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcy5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpIHtcbiAgICBsZXQgYWxsU2xpZGVzU2l6ZSA9IDA7XG4gICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goc2xpZGVTaXplVmFsdWUgPT4ge1xuICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChzcGFjZUJldHdlZW4gfHwgMCk7XG4gICAgfSk7XG4gICAgYWxsU2xpZGVzU2l6ZSAtPSBzcGFjZUJldHdlZW47XG4gICAgaWYgKGFsbFNsaWRlc1NpemUgPCBzd2lwZXJTaXplKSB7XG4gICAgICBjb25zdCBhbGxTbGlkZXNPZmZzZXQgPSAoc3dpcGVyU2l6ZSAtIGFsbFNsaWRlc1NpemUpIC8gMjtcbiAgICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXAsIHNuYXBJbmRleCkgPT4ge1xuICAgICAgICBzbmFwR3JpZFtzbmFwSW5kZXhdID0gc25hcCAtIGFsbFNsaWRlc09mZnNldDtcbiAgICAgIH0pO1xuICAgICAgc2xpZGVzR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgc2xpZGVzR3JpZFtzbmFwSW5kZXhdID0gc25hcCArIGFsbFNsaWRlc09mZnNldDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIHNsaWRlcyxcbiAgICBzbmFwR3JpZCxcbiAgICBzbGlkZXNHcmlkLFxuICAgIHNsaWRlc1NpemVzR3JpZFxuICB9KTtcbiAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY3NzTW9kZSAmJiAhcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgc2V0Q1NTUHJvcGVydHkod3JhcHBlckVsLCAnLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZScsIGAkey1zbmFwR3JpZFswXX1weGApO1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsIGAke3N3aXBlci5zaXplIC8gMiAtIHNsaWRlc1NpemVzR3JpZFtzbGlkZXNTaXplc0dyaWQubGVuZ3RoIC0gMV0gLyAyfXB4YCk7XG4gICAgY29uc3QgYWRkVG9TbmFwR3JpZCA9IC1zd2lwZXIuc25hcEdyaWRbMF07XG4gICAgY29uc3QgYWRkVG9TbGlkZXNHcmlkID0gLXN3aXBlci5zbGlkZXNHcmlkWzBdO1xuICAgIHN3aXBlci5zbmFwR3JpZCA9IHN3aXBlci5zbmFwR3JpZC5tYXAodiA9PiB2ICsgYWRkVG9TbmFwR3JpZCk7XG4gICAgc3dpcGVyLnNsaWRlc0dyaWQgPSBzd2lwZXIuc2xpZGVzR3JpZC5tYXAodiA9PiB2ICsgYWRkVG9TbGlkZXNHcmlkKTtcbiAgfVxuICBpZiAoc2xpZGVzTGVuZ3RoICE9PSBwcmV2aW91c1NsaWRlc0xlbmd0aCkge1xuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNMZW5ndGhDaGFuZ2UnKTtcbiAgfVxuICBpZiAoc25hcEdyaWQubGVuZ3RoICE9PSBwcmV2aW91c1NuYXBHcmlkTGVuZ3RoKSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICBzd2lwZXIuZW1pdCgnc25hcEdyaWRMZW5ndGhDaGFuZ2UnKTtcbiAgfVxuICBpZiAoc2xpZGVzR3JpZC5sZW5ndGggIT09IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCkge1xuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICB9XG4gIHN3aXBlci5lbWl0KCdzbGlkZXNVcGRhdGVkJyk7XG4gIGlmICghaXNWaXJ0dWFsICYmICFwYXJhbXMuY3NzTW9kZSAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnZmFkZScpKSB7XG4gICAgY29uc3QgYmFja0ZhY2VIaWRkZW5DbGFzcyA9IGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWJhY2tmYWNlLWhpZGRlbmA7XG4gICAgY29uc3QgaGFzQ2xhc3NCYWNrZmFjZUNsYXNzQWRkZWQgPSBzd2lwZXIuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGJhY2tGYWNlSGlkZGVuQ2xhc3MpO1xuICAgIGlmIChzbGlkZXNMZW5ndGggPD0gcGFyYW1zLm1heEJhY2tmYWNlSGlkZGVuU2xpZGVzKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSBzd2lwZXIuZWwuY2xhc3NMaXN0LmFkZChiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSB7XG4gICAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LnJlbW92ZShiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQXV0b0hlaWdodChzcGVlZCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBhY3RpdmVTbGlkZXMgPSBbXTtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGxldCBuZXdIZWlnaHQgPSAwO1xuICBsZXQgaTtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gIH0gZWxzZSBpZiAoc3BlZWQgPT09IHRydWUpIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKTtcbiAgfVxuICBjb25zdCBnZXRTbGlkZUJ5SW5kZXggPSBpbmRleCA9PiB7XG4gICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZXNbc3dpcGVyLmdldFNsaWRlSW5kZXhCeURhdGEoaW5kZXgpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN3aXBlci5zbGlkZXNbaW5kZXhdO1xuICB9O1xuICAvLyBGaW5kIHNsaWRlcyBjdXJyZW50bHkgaW4gdmlld1xuICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAoc3dpcGVyLnZpc2libGVTbGlkZXMgfHwgW10pLmZvckVhY2goc2xpZGUgPT4ge1xuICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChzbGlkZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IE1hdGguY2VpbChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcpOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggKyBpO1xuICAgICAgICBpZiAoaW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAmJiAhaXNWaXJ0dWFsKSBicmVhaztcbiAgICAgICAgYWN0aXZlU2xpZGVzLnB1c2goZ2V0U2xpZGVCeUluZGV4KGluZGV4KSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFjdGl2ZVNsaWRlcy5wdXNoKGdldFNsaWRlQnlJbmRleChzd2lwZXIuYWN0aXZlSW5kZXgpKTtcbiAgfVxuXG4gIC8vIEZpbmQgbmV3IGhlaWdodCBmcm9tIGhpZ2hlc3Qgc2xpZGUgaW4gdmlld1xuICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlU2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVTbGlkZXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBhY3RpdmVTbGlkZXNbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgbmV3SGVpZ2h0ID0gaGVpZ2h0ID4gbmV3SGVpZ2h0ID8gaGVpZ2h0IDogbmV3SGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBIZWlnaHRcbiAgaWYgKG5ld0hlaWdodCB8fCBuZXdIZWlnaHQgPT09IDApIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuaGVpZ2h0ID0gYCR7bmV3SGVpZ2h0fXB4YDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzT2Zmc2V0KCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBzbGlkZXMgPSBzd2lwZXIuc2xpZGVzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgY29uc3QgbWludXNPZmZzZXQgPSBzd2lwZXIuaXNFbGVtZW50ID8gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gc3dpcGVyLndyYXBwZXJFbC5vZmZzZXRMZWZ0IDogc3dpcGVyLndyYXBwZXJFbC5vZmZzZXRUb3AgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZU9mZnNldCA9IChzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBzbGlkZXNbaV0ub2Zmc2V0TGVmdCA6IHNsaWRlc1tpXS5vZmZzZXRUb3ApIC0gbWludXNPZmZzZXQgLSBzd2lwZXIuY3NzT3ZlcmZsb3dBZGp1c3RtZW50KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzUHJvZ3Jlc3ModHJhbnNsYXRlKSB7XG4gIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgIHRyYW5zbGF0ZSA9IHRoaXMgJiYgdGhpcy50cmFuc2xhdGUgfHwgMDtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHNuYXBHcmlkXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIGlmICh0eXBlb2Ygc2xpZGVzWzBdLnN3aXBlclNsaWRlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICBsZXQgb2Zmc2V0Q2VudGVyID0gLXRyYW5zbGF0ZTtcbiAgaWYgKHJ0bCkgb2Zmc2V0Q2VudGVyID0gdHJhbnNsYXRlO1xuXG4gIC8vIFZpc2libGUgU2xpZGVzXG4gIHNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIHNsaWRlRWwuY2xhc3NMaXN0LnJlbW92ZShwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MsIHBhcmFtcy5zbGlkZUZ1bGx5VmlzaWJsZUNsYXNzKTtcbiAgfSk7XG4gIHN3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcyA9IFtdO1xuICBzd2lwZXIudmlzaWJsZVNsaWRlcyA9IFtdO1xuICBsZXQgc3BhY2VCZXR3ZWVuID0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcbiAgaWYgKHR5cGVvZiBzcGFjZUJldHdlZW4gPT09ICdzdHJpbmcnICYmIHNwYWNlQmV0d2Vlbi5pbmRleE9mKCclJykgPj0gMCkge1xuICAgIHNwYWNlQmV0d2VlbiA9IHBhcnNlRmxvYXQoc3BhY2VCZXR3ZWVuLnJlcGxhY2UoJyUnLCAnJykpIC8gMTAwICogc3dpcGVyLnNpemU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBzbGlkZSA9IHNsaWRlc1tpXTtcbiAgICBsZXQgc2xpZGVPZmZzZXQgPSBzbGlkZS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICBpZiAocGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBzbGlkZU9mZnNldCAtPSBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN0IHNsaWRlUHJvZ3Jlc3MgPSAob2Zmc2V0Q2VudGVyICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApIC0gc2xpZGVPZmZzZXQpIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHNwYWNlQmV0d2Vlbik7XG4gICAgY29uc3Qgb3JpZ2luYWxTbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciAtIHNuYXBHcmlkWzBdICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApIC0gc2xpZGVPZmZzZXQpIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHNwYWNlQmV0d2Vlbik7XG4gICAgY29uc3Qgc2xpZGVCZWZvcmUgPSAtKG9mZnNldENlbnRlciAtIHNsaWRlT2Zmc2V0KTtcbiAgICBjb25zdCBzbGlkZUFmdGVyID0gc2xpZGVCZWZvcmUgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgIGNvbnN0IGlzRnVsbHlWaXNpYmxlID0gc2xpZGVCZWZvcmUgPj0gMCAmJiBzbGlkZUJlZm9yZSA8PSBzd2lwZXIuc2l6ZSAtIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbaV07XG4gICAgY29uc3QgaXNWaXNpYmxlID0gc2xpZGVCZWZvcmUgPj0gMCAmJiBzbGlkZUJlZm9yZSA8IHN3aXBlci5zaXplIC0gMSB8fCBzbGlkZUFmdGVyID4gMSAmJiBzbGlkZUFmdGVyIDw9IHN3aXBlci5zaXplIHx8IHNsaWRlQmVmb3JlIDw9IDAgJiYgc2xpZGVBZnRlciA+PSBzd2lwZXIuc2l6ZTtcbiAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICBzd2lwZXIudmlzaWJsZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgc2xpZGVzW2ldLmNsYXNzTGlzdC5hZGQocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGlzRnVsbHlWaXNpYmxlKSB7XG4gICAgICBzbGlkZXNbaV0uY2xhc3NMaXN0LmFkZChwYXJhbXMuc2xpZGVGdWxseVZpc2libGVDbGFzcyk7XG4gICAgfVxuICAgIHNsaWRlLnByb2dyZXNzID0gcnRsID8gLXNsaWRlUHJvZ3Jlc3MgOiBzbGlkZVByb2dyZXNzO1xuICAgIHNsaWRlLm9yaWdpbmFsUHJvZ3Jlc3MgPSBydGwgPyAtb3JpZ2luYWxTbGlkZVByb2dyZXNzIDogb3JpZ2luYWxTbGlkZVByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAodHlwZW9mIHRyYW5zbGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB0cmFuc2xhdGUgPSBzd2lwZXIgJiYgc3dpcGVyLnRyYW5zbGF0ZSAmJiBzd2lwZXIudHJhbnNsYXRlICogbXVsdGlwbGllciB8fCAwO1xuICB9XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBsZXQge1xuICAgIHByb2dyZXNzLFxuICAgIGlzQmVnaW5uaW5nLFxuICAgIGlzRW5kLFxuICAgIHByb2dyZXNzTG9vcFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCB3YXNCZWdpbm5pbmcgPSBpc0JlZ2lubmluZztcbiAgY29uc3Qgd2FzRW5kID0gaXNFbmQ7XG4gIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgIHByb2dyZXNzID0gMDtcbiAgICBpc0JlZ2lubmluZyA9IHRydWU7XG4gICAgaXNFbmQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHByb2dyZXNzID0gKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyB0cmFuc2xhdGVzRGlmZjtcbiAgICBjb25zdCBpc0JlZ2lubmluZ1JvdW5kZWQgPSBNYXRoLmFicyh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIDwgMTtcbiAgICBjb25zdCBpc0VuZFJvdW5kZWQgPSBNYXRoLmFicyh0cmFuc2xhdGUgLSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIDwgMTtcbiAgICBpc0JlZ2lubmluZyA9IGlzQmVnaW5uaW5nUm91bmRlZCB8fCBwcm9ncmVzcyA8PSAwO1xuICAgIGlzRW5kID0gaXNFbmRSb3VuZGVkIHx8IHByb2dyZXNzID49IDE7XG4gICAgaWYgKGlzQmVnaW5uaW5nUm91bmRlZCkgcHJvZ3Jlc3MgPSAwO1xuICAgIGlmIChpc0VuZFJvdW5kZWQpIHByb2dyZXNzID0gMTtcbiAgfVxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBjb25zdCBmaXJzdFNsaWRlSW5kZXggPSBzd2lwZXIuZ2V0U2xpZGVJbmRleEJ5RGF0YSgwKTtcbiAgICBjb25zdCBsYXN0U2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgZmlyc3RTbGlkZVRyYW5zbGF0ZSA9IHN3aXBlci5zbGlkZXNHcmlkW2ZpcnN0U2xpZGVJbmRleF07XG4gICAgY29uc3QgbGFzdFNsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbbGFzdFNsaWRlSW5kZXhdO1xuICAgIGNvbnN0IHRyYW5zbGF0ZU1heCA9IHN3aXBlci5zbGlkZXNHcmlkW3N3aXBlci5zbGlkZXNHcmlkLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHRyYW5zbGF0ZUFicyA9IE1hdGguYWJzKHRyYW5zbGF0ZSk7XG4gICAgaWYgKHRyYW5zbGF0ZUFicyA+PSBmaXJzdFNsaWRlVHJhbnNsYXRlKSB7XG4gICAgICBwcm9ncmVzc0xvb3AgPSAodHJhbnNsYXRlQWJzIC0gZmlyc3RTbGlkZVRyYW5zbGF0ZSkgLyB0cmFuc2xhdGVNYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dyZXNzTG9vcCA9ICh0cmFuc2xhdGVBYnMgKyB0cmFuc2xhdGVNYXggLSBsYXN0U2xpZGVUcmFuc2xhdGUpIC8gdHJhbnNsYXRlTWF4O1xuICAgIH1cbiAgICBpZiAocHJvZ3Jlc3NMb29wID4gMSkgcHJvZ3Jlc3NMb29wIC09IDE7XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICBwcm9ncmVzcyxcbiAgICBwcm9ncmVzc0xvb3AsXG4gICAgaXNCZWdpbm5pbmcsXG4gICAgaXNFbmRcbiAgfSk7XG4gIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fCBwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmF1dG9IZWlnaHQpIHN3aXBlci51cGRhdGVTbGlkZXNQcm9ncmVzcyh0cmFuc2xhdGUpO1xuICBpZiAoaXNCZWdpbm5pbmcgJiYgIXdhc0JlZ2lubmluZykge1xuICAgIHN3aXBlci5lbWl0KCdyZWFjaEJlZ2lubmluZyB0b0VkZ2UnKTtcbiAgfVxuICBpZiAoaXNFbmQgJiYgIXdhc0VuZCkge1xuICAgIHN3aXBlci5lbWl0KCdyZWFjaEVuZCB0b0VkZ2UnKTtcbiAgfVxuICBpZiAod2FzQmVnaW5uaW5nICYmICFpc0JlZ2lubmluZyB8fCB3YXNFbmQgJiYgIWlzRW5kKSB7XG4gICAgc3dpcGVyLmVtaXQoJ2Zyb21FZGdlJyk7XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ3Byb2dyZXNzJywgcHJvZ3Jlc3MpO1xufVxuXG5jb25zdCB0b2dnbGVTbGlkZUNsYXNzZXMgPSAoc2xpZGVFbCwgY29uZGl0aW9uLCBjbGFzc05hbWUpID0+IHtcbiAgaWYgKGNvbmRpdGlvbiAmJiAhc2xpZGVFbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgIHNsaWRlRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9IGVsc2UgaWYgKCFjb25kaXRpb24gJiYgc2xpZGVFbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgIHNsaWRlRWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9XG59O1xuZnVuY3Rpb24gdXBkYXRlU2xpZGVzQ2xhc3NlcygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHNsaWRlcyxcbiAgICBwYXJhbXMsXG4gICAgc2xpZGVzRWwsXG4gICAgYWN0aXZlSW5kZXhcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgY29uc3QgZ3JpZEVuYWJsZWQgPSBzd2lwZXIuZ3JpZCAmJiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMTtcbiAgY29uc3QgZ2V0RmlsdGVyZWRTbGlkZSA9IHNlbGVjdG9yID0+IHtcbiAgICByZXR1cm4gZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9JHtzZWxlY3Rvcn0sIHN3aXBlci1zbGlkZSR7c2VsZWN0b3J9YClbMF07XG4gIH07XG4gIGxldCBhY3RpdmVTbGlkZTtcbiAgbGV0IHByZXZTbGlkZTtcbiAgbGV0IG5leHRTbGlkZTtcbiAgaWYgKGlzVmlydHVhbCkge1xuICAgIGlmIChwYXJhbXMubG9vcCkge1xuICAgICAgbGV0IHNsaWRlSW5kZXggPSBhY3RpdmVJbmRleCAtIHN3aXBlci52aXJ0dWFsLnNsaWRlc0JlZm9yZTtcbiAgICAgIGlmIChzbGlkZUluZGV4IDwgMCkgc2xpZGVJbmRleCA9IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggKyBzbGlkZUluZGV4O1xuICAgICAgaWYgKHNsaWRlSW5kZXggPj0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCkgc2xpZGVJbmRleCAtPSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoO1xuICAgICAgYWN0aXZlU2xpZGUgPSBnZXRGaWx0ZXJlZFNsaWRlKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3NsaWRlSW5kZXh9XCJdYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZVNsaWRlID0gZ2V0RmlsdGVyZWRTbGlkZShgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHthY3RpdmVJbmRleH1cIl1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICBhY3RpdmVTbGlkZSA9IHNsaWRlcy5maWx0ZXIoc2xpZGVFbCA9PiBzbGlkZUVsLmNvbHVtbiA9PT0gYWN0aXZlSW5kZXgpWzBdO1xuICAgICAgbmV4dFNsaWRlID0gc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuY29sdW1uID09PSBhY3RpdmVJbmRleCArIDEpWzBdO1xuICAgICAgcHJldlNsaWRlID0gc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuY29sdW1uID09PSBhY3RpdmVJbmRleCAtIDEpWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVTbGlkZSA9IHNsaWRlc1thY3RpdmVJbmRleF07XG4gICAgfVxuICB9XG4gIGlmIChhY3RpdmVTbGlkZSkge1xuICAgIGlmICghZ3JpZEVuYWJsZWQpIHtcbiAgICAgIC8vIE5leHQgU2xpZGVcbiAgICAgIG5leHRTbGlkZSA9IGVsZW1lbnROZXh0QWxsKGFjdGl2ZVNsaWRlLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKVswXTtcbiAgICAgIGlmIChwYXJhbXMubG9vcCAmJiAhbmV4dFNsaWRlKSB7XG4gICAgICAgIG5leHRTbGlkZSA9IHNsaWRlc1swXTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldiBTbGlkZVxuICAgICAgcHJldlNsaWRlID0gZWxlbWVudFByZXZBbGwoYWN0aXZlU2xpZGUsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApWzBdO1xuICAgICAgaWYgKHBhcmFtcy5sb29wICYmICFwcmV2U2xpZGUgPT09IDApIHtcbiAgICAgICAgcHJldlNsaWRlID0gc2xpZGVzW3NsaWRlcy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgdG9nZ2xlU2xpZGVDbGFzc2VzKHNsaWRlRWwsIHNsaWRlRWwgPT09IGFjdGl2ZVNsaWRlLCBwYXJhbXMuc2xpZGVBY3RpdmVDbGFzcyk7XG4gICAgdG9nZ2xlU2xpZGVDbGFzc2VzKHNsaWRlRWwsIHNsaWRlRWwgPT09IG5leHRTbGlkZSwgcGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcbiAgICB0b2dnbGVTbGlkZUNsYXNzZXMoc2xpZGVFbCwgc2xpZGVFbCA9PT0gcHJldlNsaWRlLCBwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xuICB9KTtcbiAgc3dpcGVyLmVtaXRTbGlkZXNDbGFzc2VzKCk7XG59XG5cbmNvbnN0IHByb2Nlc3NMYXp5UHJlbG9hZGVyID0gKHN3aXBlciwgaW1hZ2VFbCkgPT4ge1xuICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIucGFyYW1zKSByZXR1cm47XG4gIGNvbnN0IHNsaWRlU2VsZWN0b3IgPSAoKSA9PiBzd2lwZXIuaXNFbGVtZW50ID8gYHN3aXBlci1zbGlkZWAgOiBgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWA7XG4gIGNvbnN0IHNsaWRlRWwgPSBpbWFnZUVsLmNsb3Nlc3Qoc2xpZGVTZWxlY3RvcigpKTtcbiAgaWYgKHNsaWRlRWwpIHtcbiAgICBsZXQgbGF6eUVsID0gc2xpZGVFbC5xdWVyeVNlbGVjdG9yKGAuJHtzd2lwZXIucGFyYW1zLmxhenlQcmVsb2FkZXJDbGFzc31gKTtcbiAgICBpZiAoIWxhenlFbCAmJiBzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgICBpZiAoc2xpZGVFbC5zaGFkb3dSb290KSB7XG4gICAgICAgIGxhenlFbCA9IHNsaWRlRWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGAuJHtzd2lwZXIucGFyYW1zLmxhenlQcmVsb2FkZXJDbGFzc31gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluaXQgbGF0ZXJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpZiAoc2xpZGVFbC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBsYXp5RWwgPSBzbGlkZUVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihgLiR7c3dpcGVyLnBhcmFtcy5sYXp5UHJlbG9hZGVyQ2xhc3N9YCk7XG4gICAgICAgICAgICBpZiAobGF6eUVsKSBsYXp5RWwucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhenlFbCkgbGF6eUVsLnJlbW92ZSgpO1xuICB9XG59O1xuY29uc3QgdW5sYXp5ID0gKHN3aXBlciwgaW5kZXgpID0+IHtcbiAgaWYgKCFzd2lwZXIuc2xpZGVzW2luZGV4XSkgcmV0dXJuO1xuICBjb25zdCBpbWFnZUVsID0gc3dpcGVyLnNsaWRlc1tpbmRleF0ucXVlcnlTZWxlY3RvcignW2xvYWRpbmc9XCJsYXp5XCJdJyk7XG4gIGlmIChpbWFnZUVsKSBpbWFnZUVsLnJlbW92ZUF0dHJpYnV0ZSgnbG9hZGluZycpO1xufTtcbmNvbnN0IHByZWxvYWQgPSBzd2lwZXIgPT4ge1xuICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIucGFyYW1zKSByZXR1cm47XG4gIGxldCBhbW91bnQgPSBzd2lwZXIucGFyYW1zLmxhenlQcmVsb2FkUHJldk5leHQ7XG4gIGNvbnN0IGxlbiA9IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICBpZiAoIWxlbiB8fCAhYW1vdW50IHx8IGFtb3VudCA8IDApIHJldHVybjtcbiAgYW1vdW50ID0gTWF0aC5taW4oYW1vdW50LCBsZW4pO1xuICBjb25zdCBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgPyBzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IE1hdGguY2VpbChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcpO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcbiAgaWYgKHN3aXBlci5wYXJhbXMuZ3JpZCAmJiBzd2lwZXIucGFyYW1zLmdyaWQucm93cyA+IDEpIHtcbiAgICBjb25zdCBhY3RpdmVDb2x1bW4gPSBhY3RpdmVJbmRleDtcbiAgICBjb25zdCBwcmVsb2FkQ29sdW1ucyA9IFthY3RpdmVDb2x1bW4gLSBhbW91bnRdO1xuICAgIHByZWxvYWRDb2x1bW5zLnB1c2goLi4uQXJyYXkuZnJvbSh7XG4gICAgICBsZW5ndGg6IGFtb3VudFxuICAgIH0pLm1hcCgoXywgaSkgPT4ge1xuICAgICAgcmV0dXJuIGFjdGl2ZUNvbHVtbiArIHNsaWRlc1BlclZpZXcgKyBpO1xuICAgIH0pKTtcbiAgICBzd2lwZXIuc2xpZGVzLmZvckVhY2goKHNsaWRlRWwsIGkpID0+IHtcbiAgICAgIGlmIChwcmVsb2FkQ29sdW1ucy5pbmNsdWRlcyhzbGlkZUVsLmNvbHVtbikpIHVubGF6eShzd2lwZXIsIGkpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzbGlkZUluZGV4TGFzdEluVmlldyA9IGFjdGl2ZUluZGV4ICsgc2xpZGVzUGVyVmlldyAtIDE7XG4gIGlmIChzd2lwZXIucGFyYW1zLnJld2luZCB8fCBzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggLSBhbW91bnQ7IGkgPD0gc2xpZGVJbmRleExhc3RJblZpZXcgKyBhbW91bnQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgcmVhbEluZGV4ID0gKGkgJSBsZW4gKyBsZW4pICUgbGVuO1xuICAgICAgaWYgKHJlYWxJbmRleCA8IGFjdGl2ZUluZGV4IHx8IHJlYWxJbmRleCA+IHNsaWRlSW5kZXhMYXN0SW5WaWV3KSB1bmxhenkoc3dpcGVyLCByZWFsSW5kZXgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gTWF0aC5tYXgoYWN0aXZlSW5kZXggLSBhbW91bnQsIDApOyBpIDw9IE1hdGgubWluKHNsaWRlSW5kZXhMYXN0SW5WaWV3ICsgYW1vdW50LCBsZW4gLSAxKTsgaSArPSAxKSB7XG4gICAgICBpZiAoaSAhPT0gYWN0aXZlSW5kZXggJiYgKGkgPiBzbGlkZUluZGV4TGFzdEluVmlldyB8fCBpIDwgYWN0aXZlSW5kZXgpKSB7XG4gICAgICAgIHVubGF6eShzd2lwZXIsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QWN0aXZlSW5kZXhCeVRyYW5zbGF0ZShzd2lwZXIpIHtcbiAgY29uc3Qge1xuICAgIHNsaWRlc0dyaWQsXG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGxldCBhY3RpdmVJbmRleDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSAtIChzbGlkZXNHcmlkW2kgKyAxXSAtIHNsaWRlc0dyaWRbaV0pIC8gMikge1xuICAgICAgICBhY3RpdmVJbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4ID0gaSArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgYWN0aXZlSW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxuICBpZiAocGFyYW1zLm5vcm1hbGl6ZVNsaWRlSW5kZXgpIHtcbiAgICBpZiAoYWN0aXZlSW5kZXggPCAwIHx8IHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIGFjdGl2ZUluZGV4ID0gMDtcbiAgfVxuICByZXR1cm4gYWN0aXZlSW5kZXg7XG59XG5mdW5jdGlvbiB1cGRhdGVBY3RpdmVJbmRleChuZXdBY3RpdmVJbmRleCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICBjb25zdCB7XG4gICAgc25hcEdyaWQsXG4gICAgcGFyYW1zLFxuICAgIGFjdGl2ZUluZGV4OiBwcmV2aW91c0luZGV4LFxuICAgIHJlYWxJbmRleDogcHJldmlvdXNSZWFsSW5kZXgsXG4gICAgc25hcEluZGV4OiBwcmV2aW91c1NuYXBJbmRleFxuICB9ID0gc3dpcGVyO1xuICBsZXQgYWN0aXZlSW5kZXggPSBuZXdBY3RpdmVJbmRleDtcbiAgbGV0IHNuYXBJbmRleDtcbiAgY29uc3QgZ2V0VmlydHVhbFJlYWxJbmRleCA9IGFJbmRleCA9PiB7XG4gICAgbGV0IHJlYWxJbmRleCA9IGFJbmRleCAtIHN3aXBlci52aXJ0dWFsLnNsaWRlc0JlZm9yZTtcbiAgICBpZiAocmVhbEluZGV4IDwgMCkge1xuICAgICAgcmVhbEluZGV4ID0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCArIHJlYWxJbmRleDtcbiAgICB9XG4gICAgaWYgKHJlYWxJbmRleCA+PSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoKSB7XG4gICAgICByZWFsSW5kZXggLT0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWxJbmRleDtcbiAgfTtcbiAgaWYgKHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhY3RpdmVJbmRleCA9IGdldEFjdGl2ZUluZGV4QnlUcmFuc2xhdGUoc3dpcGVyKTtcbiAgfVxuICBpZiAoc25hcEdyaWQuaW5kZXhPZih0cmFuc2xhdGUpID49IDApIHtcbiAgICBzbmFwSW5kZXggPSBzbmFwR3JpZC5pbmRleE9mKHRyYW5zbGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2tpcCA9IE1hdGgubWluKHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGFjdGl2ZUluZGV4KTtcbiAgICBzbmFwSW5kZXggPSBza2lwICsgTWF0aC5mbG9vcigoYWN0aXZlSW5kZXggLSBza2lwKSAvIHBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gIH1cbiAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XG4gIGlmIChhY3RpdmVJbmRleCA9PT0gcHJldmlvdXNJbmRleCAmJiAhc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgaWYgKHNuYXBJbmRleCAhPT0gcHJldmlvdXNTbmFwSW5kZXgpIHtcbiAgICAgIHN3aXBlci5zbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICBzd2lwZXIuZW1pdCgnc25hcEluZGV4Q2hhbmdlJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYWN0aXZlSW5kZXggPT09IHByZXZpb3VzSW5kZXggJiYgc3dpcGVyLnBhcmFtcy5sb29wICYmIHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgc3dpcGVyLnJlYWxJbmRleCA9IGdldFZpcnR1YWxSZWFsSW5kZXgoYWN0aXZlSW5kZXgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuXG4gIC8vIEdldCByZWFsIGluZGV4XG4gIGxldCByZWFsSW5kZXg7XG4gIGlmIChzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHBhcmFtcy5sb29wKSB7XG4gICAgcmVhbEluZGV4ID0gZ2V0VmlydHVhbFJlYWxJbmRleChhY3RpdmVJbmRleCk7XG4gIH0gZWxzZSBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICBjb25zdCBmaXJzdFNsaWRlSW5Db2x1bW4gPSBzd2lwZXIuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuY29sdW1uID09PSBhY3RpdmVJbmRleClbMF07XG4gICAgbGV0IGFjdGl2ZVNsaWRlSW5kZXggPSBwYXJzZUludChmaXJzdFNsaWRlSW5Db2x1bW4uZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgaWYgKE51bWJlci5pc05hTihhY3RpdmVTbGlkZUluZGV4KSkge1xuICAgICAgYWN0aXZlU2xpZGVJbmRleCA9IE1hdGgubWF4KHN3aXBlci5zbGlkZXMuaW5kZXhPZihmaXJzdFNsaWRlSW5Db2x1bW4pLCAwKTtcbiAgICB9XG4gICAgcmVhbEluZGV4ID0gTWF0aC5mbG9vcihhY3RpdmVTbGlkZUluZGV4IC8gcGFyYW1zLmdyaWQucm93cyk7XG4gIH0gZWxzZSBpZiAoc3dpcGVyLnNsaWRlc1thY3RpdmVJbmRleF0pIHtcbiAgICBjb25zdCBzbGlkZUluZGV4ID0gc3dpcGVyLnNsaWRlc1thY3RpdmVJbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xuICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICByZWFsSW5kZXggPSBwYXJzZUludChzbGlkZUluZGV4LCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWxJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWFsSW5kZXggPSBhY3RpdmVJbmRleDtcbiAgfVxuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIHByZXZpb3VzU25hcEluZGV4LFxuICAgIHNuYXBJbmRleCxcbiAgICBwcmV2aW91c1JlYWxJbmRleCxcbiAgICByZWFsSW5kZXgsXG4gICAgcHJldmlvdXNJbmRleCxcbiAgICBhY3RpdmVJbmRleFxuICB9KTtcbiAgaWYgKHN3aXBlci5pbml0aWFsaXplZCkge1xuICAgIHByZWxvYWQoc3dpcGVyKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnYWN0aXZlSW5kZXhDaGFuZ2UnKTtcbiAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xuICBpZiAoc3dpcGVyLmluaXRpYWxpemVkIHx8IHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSB7XG4gICAgaWYgKHByZXZpb3VzUmVhbEluZGV4ICE9PSByZWFsSW5kZXgpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdyZWFsSW5kZXhDaGFuZ2UnKTtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlQ2hhbmdlJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xpY2tlZFNsaWRlKGVsLCBwYXRoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG4gIGxldCBzbGlkZSA9IGVsLmNsb3Nlc3QoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCk7XG4gIGlmICghc2xpZGUgJiYgc3dpcGVyLmlzRWxlbWVudCAmJiBwYXRoICYmIHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoLmluY2x1ZGVzKGVsKSkge1xuICAgIFsuLi5wYXRoLnNsaWNlKHBhdGguaW5kZXhPZihlbCkgKyAxLCBwYXRoLmxlbmd0aCldLmZvckVhY2gocGF0aEVsID0+IHtcbiAgICAgIGlmICghc2xpZGUgJiYgcGF0aEVsLm1hdGNoZXMgJiYgcGF0aEVsLm1hdGNoZXMoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCkpIHtcbiAgICAgICAgc2xpZGUgPSBwYXRoRWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IHNsaWRlRm91bmQgPSBmYWxzZTtcbiAgbGV0IHNsaWRlSW5kZXg7XG4gIGlmIChzbGlkZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHN3aXBlci5zbGlkZXNbaV0gPT09IHNsaWRlKSB7XG4gICAgICAgIHNsaWRlRm91bmQgPSB0cnVlO1xuICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzbGlkZSAmJiBzbGlkZUZvdW5kKSB7XG4gICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHNsaWRlO1xuICAgIGlmIChzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHBhcnNlSW50KHNsaWRlLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gc2xpZGVJbmRleDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHVuZGVmaW5lZDtcbiAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLnNsaWRlVG9DbGlja2VkU2xpZGUgJiYgc3dpcGVyLmNsaWNrZWRJbmRleCAhPT0gdW5kZWZpbmVkICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHN3aXBlci5hY3RpdmVJbmRleCkge1xuICAgIHN3aXBlci5zbGlkZVRvQ2xpY2tlZFNsaWRlKCk7XG4gIH1cbn1cblxudmFyIHVwZGF0ZSA9IHtcbiAgdXBkYXRlU2l6ZSxcbiAgdXBkYXRlU2xpZGVzLFxuICB1cGRhdGVBdXRvSGVpZ2h0LFxuICB1cGRhdGVTbGlkZXNPZmZzZXQsXG4gIHVwZGF0ZVNsaWRlc1Byb2dyZXNzLFxuICB1cGRhdGVQcm9ncmVzcyxcbiAgdXBkYXRlU2xpZGVzQ2xhc3NlcyxcbiAgdXBkYXRlQWN0aXZlSW5kZXgsXG4gIHVwZGF0ZUNsaWNrZWRTbGlkZVxufTtcblxuZnVuY3Rpb24gZ2V0U3dpcGVyVHJhbnNsYXRlKGF4aXMpIHtcbiAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuICAgIGF4aXMgPSB0aGlzLmlzSG9yaXpvbnRhbCgpID8gJ3gnIDogJ3knO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgdHJhbnNsYXRlLFxuICAgIHdyYXBwZXJFbFxuICB9ID0gc3dpcGVyO1xuICBpZiAocGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHtcbiAgICByZXR1cm4gcnRsID8gLXRyYW5zbGF0ZSA6IHRyYW5zbGF0ZTtcbiAgfVxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICByZXR1cm4gdHJhbnNsYXRlO1xuICB9XG4gIGxldCBjdXJyZW50VHJhbnNsYXRlID0gZ2V0VHJhbnNsYXRlKHdyYXBwZXJFbCwgYXhpcyk7XG4gIGN1cnJlbnRUcmFuc2xhdGUgKz0gc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpO1xuICBpZiAocnRsKSBjdXJyZW50VHJhbnNsYXRlID0gLWN1cnJlbnRUcmFuc2xhdGU7XG4gIHJldHVybiBjdXJyZW50VHJhbnNsYXRlIHx8IDA7XG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zbGF0ZSh0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcikge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgcGFyYW1zLFxuICAgIHdyYXBwZXJFbCxcbiAgICBwcm9ncmVzc1xuICB9ID0gc3dpcGVyO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgY29uc3QgeiA9IDA7XG4gIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB4ID0gcnRsID8gLXRyYW5zbGF0ZSA6IHRyYW5zbGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gdHJhbnNsYXRlO1xuICB9XG4gIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSB7XG4gICAgeCA9IE1hdGguZmxvb3IoeCk7XG4gICAgeSA9IE1hdGguZmxvb3IoeSk7XG4gIH1cbiAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgc3dpcGVyLnRyYW5zbGF0ZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHggOiB5O1xuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICB3cmFwcGVyRWxbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gLXggOiAteTtcbiAgfSBlbHNlIGlmICghcGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHtcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4IC09IHN3aXBlci5jc3NPdmVyZmxvd0FkanVzdG1lbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSAtPSBzd2lwZXIuY3NzT3ZlcmZsb3dBZGp1c3RtZW50KCk7XG4gICAgfVxuICAgIHdyYXBwZXJFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsICR7en1weClgO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1cGRhdGUgcHJvZ3Jlc3NcbiAgbGV0IG5ld1Byb2dyZXNzO1xuICBjb25zdCB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAwO1xuICB9IGVsc2Uge1xuICAgIG5ld1Byb2dyZXNzID0gKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyB0cmFuc2xhdGVzRGlmZjtcbiAgfVxuICBpZiAobmV3UHJvZ3Jlc3MgIT09IHByb2dyZXNzKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zbGF0ZScsIHN3aXBlci50cmFuc2xhdGUsIGJ5Q29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIG1pblRyYW5zbGF0ZSgpIHtcbiAgcmV0dXJuIC10aGlzLnNuYXBHcmlkWzBdO1xufVxuXG5mdW5jdGlvbiBtYXhUcmFuc2xhdGUoKSB7XG4gIHJldHVybiAtdGhpcy5zbmFwR3JpZFt0aGlzLnNuYXBHcmlkLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVUbyh0cmFuc2xhdGUsIHNwZWVkLCBydW5DYWxsYmFja3MsIHRyYW5zbGF0ZUJvdW5kcywgaW50ZXJuYWwpIHtcbiAgaWYgKHRyYW5zbGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNsYXRlID0gMDtcbiAgfVxuICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xuICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBpZiAodHJhbnNsYXRlQm91bmRzID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2xhdGVCb3VuZHMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgd3JhcHBlckVsXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbWluVHJhbnNsYXRlID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBjb25zdCBtYXhUcmFuc2xhdGUgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gIGxldCBuZXdUcmFuc2xhdGU7XG4gIGlmICh0cmFuc2xhdGVCb3VuZHMgJiYgdHJhbnNsYXRlID4gbWluVHJhbnNsYXRlKSBuZXdUcmFuc2xhdGUgPSBtaW5UcmFuc2xhdGU7ZWxzZSBpZiAodHJhbnNsYXRlQm91bmRzICYmIHRyYW5zbGF0ZSA8IG1heFRyYW5zbGF0ZSkgbmV3VHJhbnNsYXRlID0gbWF4VHJhbnNsYXRlO2Vsc2UgbmV3VHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuXG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MobmV3VHJhbnNsYXRlKTtcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgY29uc3QgaXNIID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgIGlmIChzcGVlZCA9PT0gMCkge1xuICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IC1uZXdUcmFuc2xhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc3dpcGVyLnN1cHBvcnQuc21vb3RoU2Nyb2xsKSB7XG4gICAgICAgIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKHtcbiAgICAgICAgICBzd2lwZXIsXG4gICAgICAgICAgdGFyZ2V0UG9zaXRpb246IC1uZXdUcmFuc2xhdGUsXG4gICAgICAgICAgc2lkZTogaXNIID8gJ2xlZnQnIDogJ3RvcCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgW2lzSCA/ICdsZWZ0JyA6ICd0b3AnXTogLW5ld1RyYW5zbGF0ZSxcbiAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuICAgIGlmIChydW5DYWxsYmFja3MpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcbiAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XG4gICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uU3RhcnQnKTtcbiAgICB9XG4gICAgaWYgKCFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIGlmICghc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xuICAgICAgICBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChlKSB7XG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsO1xuICAgICAgICAgIGRlbGV0ZSBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kO1xuICAgICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvbkVuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN3aXBlci53cmFwcGVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHRyYW5zbGF0ZSA9IHtcbiAgZ2V0VHJhbnNsYXRlOiBnZXRTd2lwZXJUcmFuc2xhdGUsXG4gIHNldFRyYW5zbGF0ZSxcbiAgbWluVHJhbnNsYXRlLFxuICBtYXhUcmFuc2xhdGUsXG4gIHRyYW5zbGF0ZVRvXG59O1xuXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGR1cmF0aW9uID09PSAwID8gYDBtc2AgOiAnJztcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNpdGlvbicsIGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW1pdChfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIHJ1bkNhbGxiYWNrcyxcbiAgICBkaXJlY3Rpb24sXG4gICAgc3RlcFxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIHByZXZpb3VzSW5kZXhcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IGRpciA9IGRpcmVjdGlvbjtcbiAgaWYgKCFkaXIpIHtcbiAgICBpZiAoYWN0aXZlSW5kZXggPiBwcmV2aW91c0luZGV4KSBkaXIgPSAnbmV4dCc7ZWxzZSBpZiAoYWN0aXZlSW5kZXggPCBwcmV2aW91c0luZGV4KSBkaXIgPSAncHJldic7ZWxzZSBkaXIgPSAncmVzZXQnO1xuICB9XG4gIHN3aXBlci5lbWl0KGB0cmFuc2l0aW9uJHtzdGVwfWApO1xuICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgaWYgKGRpciA9PT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlUmVzZXRUcmFuc2l0aW9uJHtzdGVwfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdChgc2xpZGVDaGFuZ2VUcmFuc2l0aW9uJHtzdGVwfWApO1xuICAgIGlmIChkaXIgPT09ICduZXh0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlTmV4dFRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbWl0KGBzbGlkZVByZXZUcmFuc2l0aW9uJHtzdGVwfWApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICB9XG4gIHRyYW5zaXRpb25FbWl0KHtcbiAgICBzd2lwZXIsXG4gICAgcnVuQ2FsbGJhY2tzLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGVwOiAnU3RhcnQnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKSB7XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBzd2lwZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgdHJhbnNpdGlvbkVtaXQoe1xuICAgIHN3aXBlcixcbiAgICBydW5DYWxsYmFja3MsXG4gICAgZGlyZWN0aW9uLFxuICAgIHN0ZXA6ICdFbmQnXG4gIH0pO1xufVxuXG52YXIgdHJhbnNpdGlvbiA9IHtcbiAgc2V0VHJhbnNpdGlvbixcbiAgdHJhbnNpdGlvblN0YXJ0LFxuICB0cmFuc2l0aW9uRW5kXG59O1xuXG5mdW5jdGlvbiBzbGlkZVRvKGluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCwgaW5pdGlhbCkge1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgaW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGxldCBzbGlkZUluZGV4ID0gaW5kZXg7XG4gIGlmIChzbGlkZUluZGV4IDwgMCkgc2xpZGVJbmRleCA9IDA7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgc25hcEdyaWQsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBwcmV2aW91c0luZGV4LFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHdyYXBwZXJFbCxcbiAgICBlbmFibGVkXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCAmJiAhaW50ZXJuYWwgJiYgIWluaXRpYWwgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCBzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgY29uc3Qgc2tpcCA9IE1hdGgubWluKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBzbGlkZUluZGV4KTtcbiAgbGV0IHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChzbGlkZUluZGV4IC0gc2tpcCkgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IC1zbmFwR3JpZFtzbmFwSW5kZXhdO1xuICAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxuICBpZiAocGFyYW1zLm5vcm1hbGl6ZVNsaWRlSW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2xhdGUgPSAtTWF0aC5mbG9vcih0cmFuc2xhdGUgKiAxMDApO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEdyaWQgPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaV0gKiAxMDApO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEdyaWROZXh0ID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkW2kgKyAxXSAqIDEwMCk7XG4gICAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIDFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBub3JtYWxpemVkR3JpZCAmJiBub3JtYWxpemVkVHJhbnNsYXRlIDwgbm9ybWFsaXplZEdyaWROZXh0IC0gKG5vcm1hbGl6ZWRHcmlkTmV4dCAtIG5vcm1hbGl6ZWRHcmlkKSAvIDIpIHtcbiAgICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQpIHtcbiAgICAgICAgICBzbGlkZUluZGV4ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBub3JtYWxpemVkR3JpZCkge1xuICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGlyZWN0aW9ucyBsb2Nrc1xuICBpZiAoc3dpcGVyLmluaXRpYWxpemVkICYmIHNsaWRlSW5kZXggIT09IGFjdGl2ZUluZGV4KSB7XG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZU5leHQgJiYgKHJ0bCA/IHRyYW5zbGF0ZSA+IHN3aXBlci50cmFuc2xhdGUgJiYgdHJhbnNsYXRlID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIDogdHJhbnNsYXRlIDwgc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPCBzd2lwZXIubWluVHJhbnNsYXRlKCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHRyYW5zbGF0ZSA+IHN3aXBlci50cmFuc2xhdGUgJiYgdHJhbnNsYXRlID4gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgICBpZiAoKGFjdGl2ZUluZGV4IHx8IDApICE9PSBzbGlkZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNsaWRlSW5kZXggIT09IChwcmV2aW91c0luZGV4IHx8IDApICYmIHJ1bkNhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVTbGlkZUNoYW5nZVN0YXJ0Jyk7XG4gIH1cblxuICAvLyBVcGRhdGUgcHJvZ3Jlc3NcbiAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7XG4gIGxldCBkaXJlY3Rpb247XG4gIGlmIChzbGlkZUluZGV4ID4gYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICduZXh0JztlbHNlIGlmIChzbGlkZUluZGV4IDwgYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICdwcmV2JztlbHNlIGRpcmVjdGlvbiA9ICdyZXNldCc7XG5cbiAgLy8gVXBkYXRlIEluZGV4XG4gIGlmIChydGwgJiYgLXRyYW5zbGF0ZSA9PT0gc3dpcGVyLnRyYW5zbGF0ZSB8fCAhcnRsICYmIHRyYW5zbGF0ZSA9PT0gc3dpcGVyLnRyYW5zbGF0ZSkge1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgICAvLyBVcGRhdGUgSGVpZ2h0XG4gICAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgIH1cbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIGlmIChwYXJhbXMuZWZmZWN0ICE9PSAnc2xpZGUnKSB7XG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gIT09ICdyZXNldCcpIHtcbiAgICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgY29uc3QgaXNIID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHQgPSBydGwgPyB0cmFuc2xhdGUgOiAtdHJhbnNsYXRlO1xuICAgIGlmIChzcGVlZCA9PT0gMCkge1xuICAgICAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnbm9uZSc7XG4gICAgICAgIHN3aXBlci5faW1tZWRpYXRlVmlydHVhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNWaXJ0dWFsICYmICFzd2lwZXIuX2Nzc01vZGVWaXJ0dWFsSW5pdGlhbFNldCAmJiBzd2lwZXIucGFyYW1zLmluaXRpYWxTbGlkZSA+IDApIHtcbiAgICAgICAgc3dpcGVyLl9jc3NNb2RlVmlydHVhbEluaXRpYWxTZXQgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHdyYXBwZXJFbFtpc0ggPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSB0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZXJFbFtpc0ggPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSB0O1xuICAgICAgfVxuICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnJztcbiAgICAgICAgICBzd2lwZXIuX2ltbWVkaWF0ZVZpcnR1YWwgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc3dpcGVyLnN1cHBvcnQuc21vb3RoU2Nyb2xsKSB7XG4gICAgICAgIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKHtcbiAgICAgICAgICBzd2lwZXIsXG4gICAgICAgICAgdGFyZ2V0UG9zaXRpb246IHQsXG4gICAgICAgICAgc2lkZTogaXNIID8gJ2xlZnQnIDogJ3RvcCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgW2lzSCA/ICdsZWZ0JyA6ICd0b3AnXTogdCxcbiAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XG4gIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gIH0gZWxzZSBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xuICAgICAgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChlKSB7XG4gICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgIHN3aXBlci53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XG4gICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHN3aXBlci53cmFwcGVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNsaWRlVG9Mb29wKGluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCkge1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgaW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgaW5kZXhBc051bWJlciA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgaW5kZXggPSBpbmRleEFzTnVtYmVyO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3BlZWQgPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICB9XG4gIGNvbnN0IGdyaWRFbmFibGVkID0gc3dpcGVyLmdyaWQgJiYgc3dpcGVyLnBhcmFtcy5ncmlkICYmIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzID4gMTtcbiAgbGV0IG5ld0luZGV4ID0gaW5kZXg7XG4gIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIHN3aXBlci52aXJ0dWFsLnNsaWRlc0JlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldFNsaWRlSW5kZXg7XG4gICAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IG5ld0luZGV4ICogc3dpcGVyLnBhcmFtcy5ncmlkLnJvd3M7XG4gICAgICAgIHRhcmdldFNsaWRlSW5kZXggPSBzd2lwZXIuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICogMSA9PT0gc2xpZGVJbmRleClbMF0uY29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0U2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKG5ld0luZGV4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHMgPSBncmlkRW5hYmxlZCA/IE1hdGguY2VpbChzd2lwZXIuc2xpZGVzLmxlbmd0aCAvIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzKSA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZW50ZXJlZFNsaWRlc1xuICAgICAgfSA9IHN3aXBlci5wYXJhbXM7XG4gICAgICBsZXQgc2xpZGVzUGVyVmlldyA9IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgICAgIGlmIChzbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgICAgc2xpZGVzUGVyVmlldyA9IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGVzUGVyVmlldyA9IE1hdGguY2VpbChwYXJzZUZsb2F0KHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKTtcbiAgICAgICAgaWYgKGNlbnRlcmVkU2xpZGVzICYmIHNsaWRlc1BlclZpZXcgJSAyID09PSAwKSB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldyA9IHNsaWRlc1BlclZpZXcgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbmVlZExvb3BGaXggPSBjb2xzIC0gdGFyZ2V0U2xpZGVJbmRleCA8IHNsaWRlc1BlclZpZXc7XG4gICAgICBpZiAoY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgbmVlZExvb3BGaXggPSBuZWVkTG9vcEZpeCB8fCB0YXJnZXRTbGlkZUluZGV4IDwgTWF0aC5jZWlsKHNsaWRlc1BlclZpZXcgLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcm5hbCAmJiBjZW50ZXJlZFNsaWRlcyAmJiBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiAhZ3JpZEVuYWJsZWQpIHtcbiAgICAgICAgbmVlZExvb3BGaXggPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTG9vcEZpeCkge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBjZW50ZXJlZFNsaWRlcyA/IHRhcmdldFNsaWRlSW5kZXggPCBzd2lwZXIuYWN0aXZlSW5kZXggPyAncHJldicgOiAnbmV4dCcgOiB0YXJnZXRTbGlkZUluZGV4IC0gc3dpcGVyLmFjdGl2ZUluZGV4IC0gMSA8IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA/ICduZXh0JyA6ICdwcmV2JztcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICBzbGlkZVRvOiB0cnVlLFxuICAgICAgICAgIGFjdGl2ZVNsaWRlSW5kZXg6IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gdGFyZ2V0U2xpZGVJbmRleCArIDEgOiB0YXJnZXRTbGlkZUluZGV4IC0gY29scyArIDEsXG4gICAgICAgICAgc2xpZGVSZWFsSW5kZXg6IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gc3dpcGVyLnJlYWxJbmRleCA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBzbGlkZUluZGV4ID0gbmV3SW5kZXggKiBzd2lwZXIucGFyYW1zLmdyaWQucm93cztcbiAgICAgICAgbmV3SW5kZXggPSBzd2lwZXIuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICogMSA9PT0gc2xpZGVJbmRleClbMF0uY29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SW5kZXggPSBzd2lwZXIuZ2V0U2xpZGVJbmRleEJ5RGF0YShuZXdJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgc3dpcGVyLnNsaWRlVG8obmV3SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgfSk7XG4gIHJldHVybiBzd2lwZXI7XG59XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuZnVuY3Rpb24gc2xpZGVOZXh0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQsXG4gICAgcGFyYW1zLFxuICAgIGFuaW1hdGluZ1xuICB9ID0gc3dpcGVyO1xuICBpZiAoIWVuYWJsZWQgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuIHN3aXBlcjtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgbGV0IHBlckdyb3VwID0gcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDEgJiYgcGFyYW1zLnNsaWRlc1Blckdyb3VwQXV0bykge1xuICAgIHBlckdyb3VwID0gTWF0aC5tYXgoc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCdjdXJyZW50JywgdHJ1ZSksIDEpO1xuICB9XG4gIGNvbnN0IGluY3JlbWVudCA9IHN3aXBlci5hY3RpdmVJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgPyAxIDogcGVyR3JvdXA7XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGlmIChhbmltYXRpbmcgJiYgIWlzVmlydHVhbCAmJiBwYXJhbXMubG9vcFByZXZlbnRzU2xpZGluZykgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXBlci5sb29wRml4KHtcbiAgICAgIGRpcmVjdGlvbjogJ25leHQnXG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLndyYXBwZXJFbC5jbGllbnRMZWZ0O1xuICAgIGlmIChzd2lwZXIuYWN0aXZlSW5kZXggPT09IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSAmJiBwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4ICsgaW5jcmVtZW50LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAocGFyYW1zLnJld2luZCAmJiBzd2lwZXIuaXNFbmQpIHtcbiAgICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oMCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICB9XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZVByZXYoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHNuYXBHcmlkLFxuICAgIHNsaWRlc0dyaWQsXG4gICAgcnRsVHJhbnNsYXRlLFxuICAgIGVuYWJsZWQsXG4gICAgYW5pbWF0aW5nXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm4gc3dpcGVyO1xuICBpZiAodHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJykge1xuICAgIHNwZWVkID0gc3dpcGVyLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoYW5pbWF0aW5nICYmICFpc1ZpcnR1YWwgJiYgcGFyYW1zLmxvb3BQcmV2ZW50c1NsaWRpbmcpIHJldHVybiBmYWxzZTtcbiAgICBzd2lwZXIubG9vcEZpeCh7XG4gICAgICBkaXJlY3Rpb246ICdwcmV2J1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci53cmFwcGVyRWwuY2xpZW50TGVmdDtcbiAgfVxuICBjb25zdCB0cmFuc2xhdGUgPSBydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWwpIHtcbiAgICBpZiAodmFsIDwgMCkgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGguYWJzKHZhbCkpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKHZhbCk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZFRyYW5zbGF0ZSA9IG5vcm1hbGl6ZSh0cmFuc2xhdGUpO1xuICBjb25zdCBub3JtYWxpemVkU25hcEdyaWQgPSBzbmFwR3JpZC5tYXAodmFsID0+IG5vcm1hbGl6ZSh2YWwpKTtcbiAgbGV0IHByZXZTbmFwID0gc25hcEdyaWRbbm9ybWFsaXplZFNuYXBHcmlkLmluZGV4T2Yobm9ybWFsaXplZFRyYW5zbGF0ZSkgLSAxXTtcbiAgaWYgKHR5cGVvZiBwcmV2U25hcCA9PT0gJ3VuZGVmaW5lZCcgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICBsZXQgcHJldlNuYXBJbmRleDtcbiAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IHNuYXApIHtcbiAgICAgICAgLy8gcHJldlNuYXAgPSBzbmFwO1xuICAgICAgICBwcmV2U25hcEluZGV4ID0gc25hcEluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgcHJldlNuYXBJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHByZXZTbmFwID0gc25hcEdyaWRbcHJldlNuYXBJbmRleCA+IDAgPyBwcmV2U25hcEluZGV4IC0gMSA6IHByZXZTbmFwSW5kZXhdO1xuICAgIH1cbiAgfVxuICBsZXQgcHJldkluZGV4ID0gMDtcbiAgaWYgKHR5cGVvZiBwcmV2U25hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBwcmV2SW5kZXggPSBzbGlkZXNHcmlkLmluZGV4T2YocHJldlNuYXApO1xuICAgIGlmIChwcmV2SW5kZXggPCAwKSBwcmV2SW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggLSAxO1xuICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvKSB7XG4gICAgICBwcmV2SW5kZXggPSBwcmV2SW5kZXggLSBzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoJ3ByZXZpb3VzJywgdHJ1ZSkgKyAxO1xuICAgICAgcHJldkluZGV4ID0gTWF0aC5tYXgocHJldkluZGV4LCAwKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5yZXdpbmQgJiYgc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHN3aXBlci52aXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKGxhc3RJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICB9IGVsc2UgaWYgKHBhcmFtcy5sb29wICYmIHN3aXBlci5hY3RpdmVJbmRleCA9PT0gMCAmJiBwYXJhbXMuY3NzTW9kZSkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhwcmV2SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8ocHJldkluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG59XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuZnVuY3Rpb24gc2xpZGVSZXNldChzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCkge1xuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3BlZWQgPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICB9XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZVRvQ2xvc2VzdChzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCwgdGhyZXNob2xkKSB7XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyZXNob2xkID0gMC41O1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3BlZWQgPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICB9XG4gIGxldCBpbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcbiAgY29uc3Qgc2tpcCA9IE1hdGgubWluKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBpbmRleCk7XG4gIGNvbnN0IHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChpbmRleCAtIHNraXApIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGlmICh0cmFuc2xhdGUgPj0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF0pIHtcbiAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgb24gb3IgYWZ0ZXIgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxuICAgIC8vIGlzIGJldHdlZW4gdGhlIGN1cnJlbnQgaW5kZXggYW5kIHRoZSBvbmUgYWZ0ZXIgaXQuXG4gICAgY29uc3QgY3VycmVudFNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XTtcbiAgICBjb25zdCBuZXh0U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXggKyAxXTtcbiAgICBpZiAodHJhbnNsYXRlIC0gY3VycmVudFNuYXAgPiAobmV4dFNuYXAgLSBjdXJyZW50U25hcCkgKiB0aHJlc2hvbGQpIHtcbiAgICAgIGluZGV4ICs9IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBjdXJyZW50IHRyYW5zbGF0ZSBpcyBiZWZvcmUgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxuICAgIC8vIGlzIGJldHdlZW4gdGhlIGN1cnJlbnQgaW5kZXggYW5kIHRoZSBvbmUgYmVmb3JlIGl0LlxuICAgIGNvbnN0IHByZXZTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCAtIDFdO1xuICAgIGNvbnN0IGN1cnJlbnRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF07XG4gICAgaWYgKHRyYW5zbGF0ZSAtIHByZXZTbmFwIDw9IChjdXJyZW50U25hcCAtIHByZXZTbmFwKSAqIHRocmVzaG9sZCkge1xuICAgICAgaW5kZXggLT0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICB9XG4gIH1cbiAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuZnVuY3Rpb24gc2xpZGVUb0NsaWNrZWRTbGlkZSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBzbGlkZXNQZXJWaWV3ID0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gIGxldCBzbGlkZVRvSW5kZXggPSBzd2lwZXIuY2xpY2tlZEluZGV4O1xuICBsZXQgcmVhbEluZGV4O1xuICBjb25zdCBzbGlkZVNlbGVjdG9yID0gc3dpcGVyLmlzRWxlbWVudCA/IGBzd2lwZXItc2xpZGVgIDogYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWA7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nKSByZXR1cm47XG4gICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoc3dpcGVyLmNsaWNrZWRTbGlkZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBpZiAoc2xpZGVUb0luZGV4IDwgc3dpcGVyLmxvb3BlZFNsaWRlcyAtIHNsaWRlc1BlclZpZXcgLyAyIHx8IHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcyArIHNsaWRlc1BlclZpZXcgLyAyKSB7XG4gICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgIHNsaWRlVG9JbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4KGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYCR7c2xpZGVTZWxlY3Rvcn1bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKVswXSk7XG4gICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbGlkZVRvSW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIHNsaWRlc1BlclZpZXcpIHtcbiAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICBzbGlkZVRvSW5kZXggPSBzd2lwZXIuZ2V0U2xpZGVJbmRleChlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAke3NsaWRlU2VsZWN0b3J9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdYClbMF0pO1xuICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gIH1cbn1cblxudmFyIHNsaWRlID0ge1xuICBzbGlkZVRvLFxuICBzbGlkZVRvTG9vcCxcbiAgc2xpZGVOZXh0LFxuICBzbGlkZVByZXYsXG4gIHNsaWRlUmVzZXQsXG4gIHNsaWRlVG9DbG9zZXN0LFxuICBzbGlkZVRvQ2xpY2tlZFNsaWRlXG59O1xuXG5mdW5jdGlvbiBsb29wQ3JlYXRlKHNsaWRlUmVhbEluZGV4KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgc2xpZGVzRWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFwYXJhbXMubG9vcCB8fCBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xuICBjb25zdCBpbml0U2xpZGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IHNsaWRlcyA9IGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCk7XG4gICAgc2xpZGVzLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGluZGV4KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZ3JpZEVuYWJsZWQgPSBzd2lwZXIuZ3JpZCAmJiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMTtcbiAgY29uc3Qgc2xpZGVzUGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgKiAoZ3JpZEVuYWJsZWQgPyBwYXJhbXMuZ3JpZC5yb3dzIDogMSk7XG4gIGNvbnN0IHNob3VsZEZpbGxHcm91cCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoICUgc2xpZGVzUGVyR3JvdXAgIT09IDA7XG4gIGNvbnN0IHNob3VsZEZpbGxHcmlkID0gZ3JpZEVuYWJsZWQgJiYgc3dpcGVyLnNsaWRlcy5sZW5ndGggJSBwYXJhbXMuZ3JpZC5yb3dzICE9PSAwO1xuICBjb25zdCBhZGRCbGFua1NsaWRlcyA9IGFtb3VudE9mU2xpZGVzID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudE9mU2xpZGVzOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHNsaWRlRWwgPSBzd2lwZXIuaXNFbGVtZW50ID8gY3JlYXRlRWxlbWVudCgnc3dpcGVyLXNsaWRlJywgW3BhcmFtcy5zbGlkZUJsYW5rQ2xhc3NdKSA6IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIFtwYXJhbXMuc2xpZGVDbGFzcywgcGFyYW1zLnNsaWRlQmxhbmtDbGFzc10pO1xuICAgICAgc3dpcGVyLnNsaWRlc0VsLmFwcGVuZChzbGlkZUVsKTtcbiAgICB9XG4gIH07XG4gIGlmIChzaG91bGRGaWxsR3JvdXApIHtcbiAgICBpZiAocGFyYW1zLmxvb3BBZGRCbGFua1NsaWRlcykge1xuICAgICAgY29uc3Qgc2xpZGVzVG9BZGQgPSBzbGlkZXNQZXJHcm91cCAtIHN3aXBlci5zbGlkZXMubGVuZ3RoICUgc2xpZGVzUGVyR3JvdXA7XG4gICAgICBhZGRCbGFua1NsaWRlcyhzbGlkZXNUb0FkZCk7XG4gICAgICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBUaGUgbnVtYmVyIG9mIHNsaWRlcyBpcyBub3QgZXZlbiB0byBzbGlkZXNQZXJHcm91cCwgbG9vcCBtb2RlIG1heSBub3QgZnVuY3Rpb24gcHJvcGVybHkuIFlvdSBuZWVkIHRvIGFkZCBtb3JlIHNsaWRlcyAob3IgbWFrZSBkdXBsaWNhdGVzLCBvciBlbXB0eSBzbGlkZXMpJyk7XG4gICAgfVxuICAgIGluaXRTbGlkZXMoKTtcbiAgfSBlbHNlIGlmIChzaG91bGRGaWxsR3JpZCkge1xuICAgIGlmIChwYXJhbXMubG9vcEFkZEJsYW5rU2xpZGVzKSB7XG4gICAgICBjb25zdCBzbGlkZXNUb0FkZCA9IHBhcmFtcy5ncmlkLnJvd3MgLSBzd2lwZXIuc2xpZGVzLmxlbmd0aCAlIHBhcmFtcy5ncmlkLnJvd3M7XG4gICAgICBhZGRCbGFua1NsaWRlcyhzbGlkZXNUb0FkZCk7XG4gICAgICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBUaGUgbnVtYmVyIG9mIHNsaWRlcyBpcyBub3QgZXZlbiB0byBncmlkLnJvd3MsIGxvb3AgbW9kZSBtYXkgbm90IGZ1bmN0aW9uIHByb3Blcmx5LiBZb3UgbmVlZCB0byBhZGQgbW9yZSBzbGlkZXMgKG9yIG1ha2UgZHVwbGljYXRlcywgb3IgZW1wdHkgc2xpZGVzKScpO1xuICAgIH1cbiAgICBpbml0U2xpZGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgaW5pdFNsaWRlcygpO1xuICB9XG4gIHN3aXBlci5sb29wRml4KHtcbiAgICBzbGlkZVJlYWxJbmRleCxcbiAgICBkaXJlY3Rpb246IHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHVuZGVmaW5lZCA6ICduZXh0J1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbG9vcEZpeChfdGVtcCkge1xuICBsZXQge1xuICAgIHNsaWRlUmVhbEluZGV4LFxuICAgIHNsaWRlVG8gPSB0cnVlLFxuICAgIGRpcmVjdGlvbixcbiAgICBzZXRUcmFuc2xhdGUsXG4gICAgYWN0aXZlU2xpZGVJbmRleCxcbiAgICBieUNvbnRyb2xsZXIsXG4gICAgYnlNb3VzZXdoZWVsXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgc3dpcGVyLmVtaXQoJ2JlZm9yZUxvb3BGaXgnKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlcyxcbiAgICBhbGxvd1NsaWRlUHJldixcbiAgICBhbGxvd1NsaWRlTmV4dCxcbiAgICBzbGlkZXNFbCxcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3Qge1xuICAgIGNlbnRlcmVkU2xpZGVzXG4gIH0gPSBwYXJhbXM7XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gIGlmIChzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgaWYgKHNsaWRlVG8pIHtcbiAgICAgIGlmICghcGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHN3aXBlci5zbmFwSW5kZXggPT09IDApIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgc3dpcGVyLnNuYXBJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJWaWV3KSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggKyBzd2lwZXIuc25hcEluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN3aXBlci5zbmFwSW5kZXggPT09IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggLSAxKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci52aXJ0dWFsLnNsaWRlc0JlZm9yZSwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcbiAgICBzd2lwZXIuZW1pdCgnbG9vcEZpeCcpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2xpZGVzUGVyVmlldyA9IHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICBpZiAoc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nKSB7XG4gICAgc2xpZGVzUGVyVmlldyA9IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpO1xuICB9IGVsc2Uge1xuICAgIHNsaWRlc1BlclZpZXcgPSBNYXRoLmNlaWwocGFyc2VGbG9hdChwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKTtcbiAgICBpZiAoY2VudGVyZWRTbGlkZXMgJiYgc2xpZGVzUGVyVmlldyAlIDIgPT09IDApIHtcbiAgICAgIHNsaWRlc1BlclZpZXcgPSBzbGlkZXNQZXJWaWV3ICsgMTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2xpZGVzUGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvID8gc2xpZGVzUGVyVmlldyA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgbGV0IGxvb3BlZFNsaWRlcyA9IHNsaWRlc1Blckdyb3VwO1xuICBpZiAobG9vcGVkU2xpZGVzICUgc2xpZGVzUGVyR3JvdXAgIT09IDApIHtcbiAgICBsb29wZWRTbGlkZXMgKz0gc2xpZGVzUGVyR3JvdXAgLSBsb29wZWRTbGlkZXMgJSBzbGlkZXNQZXJHcm91cDtcbiAgfVxuICBsb29wZWRTbGlkZXMgKz0gcGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzO1xuICBzd2lwZXIubG9vcGVkU2xpZGVzID0gbG9vcGVkU2xpZGVzO1xuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBpZiAoc2xpZGVzLmxlbmd0aCA8IHNsaWRlc1BlclZpZXcgKyBsb29wZWRTbGlkZXMpIHtcbiAgICBzaG93V2FybmluZygnU3dpcGVyIExvb3AgV2FybmluZzogVGhlIG51bWJlciBvZiBzbGlkZXMgaXMgbm90IGVub3VnaCBmb3IgbG9vcCBtb2RlLCBpdCB3aWxsIGJlIGRpc2FibGVkIGFuZCBub3QgZnVuY3Rpb24gcHJvcGVybHkuIFlvdSBuZWVkIHRvIGFkZCBtb3JlIHNsaWRlcyAob3IgbWFrZSBkdXBsaWNhdGVzKSBvciBsb3dlciB0aGUgdmFsdWVzIG9mIHNsaWRlc1BlclZpZXcgYW5kIHNsaWRlc1Blckdyb3VwIHBhcmFtZXRlcnMnKTtcbiAgfSBlbHNlIGlmIChncmlkRW5hYmxlZCAmJiBwYXJhbXMuZ3JpZC5maWxsID09PSAncm93Jykge1xuICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBMb29wIG1vZGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBncmlkLmZpbGwgPSBgcm93YCcpO1xuICB9XG4gIGNvbnN0IHByZXBlbmRTbGlkZXNJbmRleGVzID0gW107XG4gIGNvbnN0IGFwcGVuZFNsaWRlc0luZGV4ZXMgPSBbXTtcbiAgbGV0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICBpZiAodHlwZW9mIGFjdGl2ZVNsaWRlSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWN0aXZlU2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4KHNsaWRlcy5maWx0ZXIoZWwgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKSlbMF0pO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUluZGV4ID0gYWN0aXZlU2xpZGVJbmRleDtcbiAgfVxuICBjb25zdCBpc05leHQgPSBkaXJlY3Rpb24gPT09ICduZXh0JyB8fCAhZGlyZWN0aW9uO1xuICBjb25zdCBpc1ByZXYgPSBkaXJlY3Rpb24gPT09ICdwcmV2JyB8fCAhZGlyZWN0aW9uO1xuICBsZXQgc2xpZGVzUHJlcGVuZGVkID0gMDtcbiAgbGV0IHNsaWRlc0FwcGVuZGVkID0gMDtcbiAgY29uc3QgY29scyA9IGdyaWRFbmFibGVkID8gTWF0aC5jZWlsKHNsaWRlcy5sZW5ndGggLyBwYXJhbXMuZ3JpZC5yb3dzKSA6IHNsaWRlcy5sZW5ndGg7XG4gIGNvbnN0IGFjdGl2ZUNvbEluZGV4ID0gZ3JpZEVuYWJsZWQgPyBzbGlkZXNbYWN0aXZlU2xpZGVJbmRleF0uY29sdW1uIDogYWN0aXZlU2xpZGVJbmRleDtcbiAgY29uc3QgYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQgPSBhY3RpdmVDb2xJbmRleCArIChjZW50ZXJlZFNsaWRlcyAmJiB0eXBlb2Ygc2V0VHJhbnNsYXRlID09PSAndW5kZWZpbmVkJyA/IC1zbGlkZXNQZXJWaWV3IC8gMiArIDAuNSA6IDApO1xuICAvLyBwcmVwZW5kIGxhc3Qgc2xpZGVzIGJlZm9yZSBzdGFydFxuICBpZiAoYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQgPCBsb29wZWRTbGlkZXMpIHtcbiAgICBzbGlkZXNQcmVwZW5kZWQgPSBNYXRoLm1heChsb29wZWRTbGlkZXMgLSBhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCwgc2xpZGVzUGVyR3JvdXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9vcGVkU2xpZGVzIC0gYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaW5kZXggPSBpIC0gTWF0aC5mbG9vcihpIC8gY29scykgKiBjb2xzO1xuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGNvbEluZGV4VG9QcmVwZW5kID0gY29scyAtIGluZGV4IC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNsaWRlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgIGlmIChzbGlkZXNbaV0uY29sdW1uID09PSBjb2xJbmRleFRvUHJlcGVuZCkgcHJlcGVuZFNsaWRlc0luZGV4ZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgLy8gICBpZiAoc2xpZGUuY29sdW1uID09PSBjb2xJbmRleFRvUHJlcGVuZCkgcHJlcGVuZFNsaWRlc0luZGV4ZXMucHVzaChzbGlkZUluZGV4KTtcbiAgICAgICAgLy8gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKGNvbHMgLSBpbmRleCAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCArIHNsaWRlc1BlclZpZXcgPiBjb2xzIC0gbG9vcGVkU2xpZGVzKSB7XG4gICAgc2xpZGVzQXBwZW5kZWQgPSBNYXRoLm1heChhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCAtIChjb2xzIC0gbG9vcGVkU2xpZGVzICogMiksIHNsaWRlc1Blckdyb3VwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0FwcGVuZGVkOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAtIE1hdGguZmxvb3IoaSAvIGNvbHMpICogY29scztcbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoc2xpZGUuY29sdW1uID09PSBpbmRleCkgYXBwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKHNsaWRlSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZFNsaWRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gdHJ1ZTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IGZhbHNlO1xuICB9KTtcbiAgaWYgKGlzUHJldikge1xuICAgIHByZXBlbmRTbGlkZXNJbmRleGVzLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgc2xpZGVzW2luZGV4XS5zd2lwZXJMb29wTW92ZURPTSA9IHRydWU7XG4gICAgICBzbGlkZXNFbC5wcmVwZW5kKHNsaWRlc1tpbmRleF0pO1xuICAgICAgc2xpZGVzW2luZGV4XS5zd2lwZXJMb29wTW92ZURPTSA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc05leHQpIHtcbiAgICBhcHBlbmRTbGlkZXNJbmRleGVzLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgc2xpZGVzW2luZGV4XS5zd2lwZXJMb29wTW92ZURPTSA9IHRydWU7XG4gICAgICBzbGlkZXNFbC5hcHBlbmQoc2xpZGVzW2luZGV4XSk7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgc3dpcGVyLnJlY2FsY1NsaWRlcygpO1xuICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgfSBlbHNlIGlmIChncmlkRW5hYmxlZCAmJiAocHJlcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoID4gMCAmJiBpc1ByZXYgfHwgYXBwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggPiAwICYmIGlzTmV4dCkpIHtcbiAgICBzd2lwZXIuc2xpZGVzLmZvckVhY2goKHNsaWRlLCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICBzd2lwZXIuZ3JpZC51cGRhdGVTbGlkZShzbGlkZUluZGV4LCBzbGlkZSwgc3dpcGVyLnNsaWRlcyk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICB9XG4gIGlmIChzbGlkZVRvKSB7XG4gICAgaWYgKHByZXBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCA+IDAgJiYgaXNQcmV2KSB7XG4gICAgICBpZiAodHlwZW9mIHNsaWRlUmVhbEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBjdXJyZW50U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFthY3RpdmVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbYWN0aXZlSW5kZXggKyBzbGlkZXNQcmVwZW5kZWRdO1xuICAgICAgICBjb25zdCBkaWZmID0gbmV3U2xpZGVUcmFuc2xhdGUgLSBjdXJyZW50U2xpZGVUcmFuc2xhdGU7XG4gICAgICAgIGlmIChieU1vdXNld2hlZWwpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHN3aXBlci50cmFuc2xhdGUgLSBkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCArIE1hdGguY2VpbChzbGlkZXNQcmVwZW5kZWQpLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHNldFRyYW5zbGF0ZSkge1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5zdGFydFRyYW5zbGF0ZSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGEuc3RhcnRUcmFuc2xhdGUgLSBkaWZmO1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlIC0gZGlmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZXRUcmFuc2xhdGUpIHtcbiAgICAgICAgICBjb25zdCBzaGlmdCA9IGdyaWRFbmFibGVkID8gcHJlcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoIC8gcGFyYW1zLmdyaWQucm93cyA6IHByZXBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aDtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBzaGlmdCwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c0RhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFwcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoID4gMCAmJiBpc05leHQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVSZWFsSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZVRyYW5zbGF0ZSA9IHN3aXBlci5zbGlkZXNHcmlkW2FjdGl2ZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmV3U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFthY3RpdmVJbmRleCAtIHNsaWRlc0FwcGVuZGVkXTtcbiAgICAgICAgY29uc3QgZGlmZiA9IG5ld1NsaWRlVHJhbnNsYXRlIC0gY3VycmVudFNsaWRlVHJhbnNsYXRlO1xuICAgICAgICBpZiAoYnlNb3VzZXdoZWVsKSB7XG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShzd2lwZXIudHJhbnNsYXRlIC0gZGlmZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oYWN0aXZlSW5kZXggLSBzbGlkZXNBcHBlbmRlZCwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGlmIChzZXRUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c0RhdGEuc3RhcnRUcmFuc2xhdGUgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZjtcbiAgICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c0RhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGEuY3VycmVudFRyYW5zbGF0ZSAtIGRpZmY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaGlmdCA9IGdyaWRFbmFibGVkID8gYXBwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggLyBwYXJhbXMuZ3JpZC5yb3dzIDogYXBwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCAtIHNoaWZ0LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcbiAgaWYgKHN3aXBlci5jb250cm9sbGVyICYmIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgJiYgIWJ5Q29udHJvbGxlcikge1xuICAgIGNvbnN0IGxvb3BQYXJhbXMgPSB7XG4gICAgICBzbGlkZVJlYWxJbmRleCxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHNldFRyYW5zbGF0ZSxcbiAgICAgIGFjdGl2ZVNsaWRlSW5kZXgsXG4gICAgICBieUNvbnRyb2xsZXI6IHRydWVcbiAgICB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wpKSB7XG4gICAgICBzd2lwZXIuY29udHJvbGxlci5jb250cm9sLmZvckVhY2goYyA9PiB7XG4gICAgICAgIGlmICghYy5kZXN0cm95ZWQgJiYgYy5wYXJhbXMubG9vcCkgYy5sb29wRml4KHtcbiAgICAgICAgICAuLi5sb29wUGFyYW1zLFxuICAgICAgICAgIHNsaWRlVG86IGMucGFyYW1zLnNsaWRlc1BlclZpZXcgPT09IHBhcmFtcy5zbGlkZXNQZXJWaWV3ID8gc2xpZGVUbyA6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzd2lwZXIuY29udHJvbGxlci5jb250cm9sIGluc3RhbmNlb2Ygc3dpcGVyLmNvbnN0cnVjdG9yICYmIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wucGFyYW1zLmxvb3ApIHtcbiAgICAgIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wubG9vcEZpeCh7XG4gICAgICAgIC4uLmxvb3BQYXJhbXMsXG4gICAgICAgIHNsaWRlVG86IHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wucGFyYW1zLnNsaWRlc1BlclZpZXcgPT09IHBhcmFtcy5zbGlkZXNQZXJWaWV3ID8gc2xpZGVUbyA6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ2xvb3BGaXgnKTtcbn1cblxuZnVuY3Rpb24gbG9vcERlc3Ryb3koKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgc2xpZGVzRWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFwYXJhbXMubG9vcCB8fCBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xuICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gIGNvbnN0IG5ld1NsaWRlc09yZGVyID0gW107XG4gIHN3aXBlci5zbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICBjb25zdCBpbmRleCA9IHR5cGVvZiBzbGlkZUVsLnN3aXBlclNsaWRlSW5kZXggPT09ICd1bmRlZmluZWQnID8gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKiAxIDogc2xpZGVFbC5zd2lwZXJTbGlkZUluZGV4O1xuICAgIG5ld1NsaWRlc09yZGVyW2luZGV4XSA9IHNsaWRlRWw7XG4gIH0pO1xuICBzd2lwZXIuc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgc2xpZGVFbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gIH0pO1xuICBuZXdTbGlkZXNPcmRlci5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIHNsaWRlc0VsLmFwcGVuZChzbGlkZUVsKTtcbiAgfSk7XG4gIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnJlYWxJbmRleCwgMCk7XG59XG5cbnZhciBsb29wID0ge1xuICBsb29wQ3JlYXRlLFxuICBsb29wRml4LFxuICBsb29wRGVzdHJveVxufTtcblxuZnVuY3Rpb24gc2V0R3JhYkN1cnNvcihtb3ZpbmcpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIucGFyYW1zLnNpbXVsYXRlVG91Y2ggfHwgc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCB8fCBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHJldHVybjtcbiAgY29uc3QgZWwgPSBzd2lwZXIucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID09PSAnY29udGFpbmVyJyA/IHN3aXBlci5lbCA6IHN3aXBlci53cmFwcGVyRWw7XG4gIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgc3dpcGVyLl9fcHJldmVudE9ic2VydmVyX18gPSB0cnVlO1xuICB9XG4gIGVsLnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgZWwuc3R5bGUuY3Vyc29yID0gbW92aW5nID8gJ2dyYWJiaW5nJyA6ICdncmFiJztcbiAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgc3dpcGVyLl9fcHJldmVudE9ic2VydmVyX18gPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnNldEdyYWJDdXJzb3IoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkIHx8IHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gdHJ1ZTtcbiAgfVxuICBzd2lwZXJbc3dpcGVyLnBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA9PT0gJ2NvbnRhaW5lcicgPyAnZWwnIDogJ3dyYXBwZXJFbCddLnN0eWxlLmN1cnNvciA9ICcnO1xuICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBncmFiQ3Vyc29yID0ge1xuICBzZXRHcmFiQ3Vyc29yLFxuICB1bnNldEdyYWJDdXJzb3Jcbn07XG5cbi8vIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTQ1MjA1NTQvY3VzdG9tLWVsZW1lbnQtZ2V0cm9vdG5vZGUtY2xvc2VzdC1mdW5jdGlvbi1jcm9zc2luZy1tdWx0aXBsZS1wYXJlbnQtc2hhZG93ZFxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnQoc2VsZWN0b3IsIGJhc2UpIHtcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgIGJhc2UgPSB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIF9fY2xvc2VzdEZyb20oZWwpIHtcbiAgICBpZiAoIWVsIHx8IGVsID09PSBnZXREb2N1bWVudCgpIHx8IGVsID09PSBnZXRXaW5kb3coKSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKGVsLmFzc2lnbmVkU2xvdCkgZWwgPSBlbC5hc3NpZ25lZFNsb3Q7XG4gICAgY29uc3QgZm91bmQgPSBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICBpZiAoIWZvdW5kICYmICFlbC5nZXRSb290Tm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZCB8fCBfX2Nsb3Nlc3RGcm9tKGVsLmdldFJvb3ROb2RlKCkuaG9zdCk7XG4gIH1cbiAgcmV0dXJuIF9fY2xvc2VzdEZyb20oYmFzZSk7XG59XG5mdW5jdGlvbiBwcmV2ZW50RWRnZVN3aXBlKHN3aXBlciwgZXZlbnQsIHN0YXJ0WCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3Qge1xuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBjb25zdCBlZGdlU3dpcGVEZXRlY3Rpb24gPSBwYXJhbXMuZWRnZVN3aXBlRGV0ZWN0aW9uO1xuICBjb25zdCBlZGdlU3dpcGVUaHJlc2hvbGQgPSBwYXJhbXMuZWRnZVN3aXBlVGhyZXNob2xkO1xuICBpZiAoZWRnZVN3aXBlRGV0ZWN0aW9uICYmIChzdGFydFggPD0gZWRnZVN3aXBlVGhyZXNob2xkIHx8IHN0YXJ0WCA+PSB3aW5kb3cuaW5uZXJXaWR0aCAtIGVkZ2VTd2lwZVRocmVzaG9sZCkpIHtcbiAgICBpZiAoZWRnZVN3aXBlRGV0ZWN0aW9uID09PSAncHJldmVudCcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgbGV0IGUgPSBldmVudDtcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gIGlmIChlLnR5cGUgPT09ICdwb2ludGVyZG93bicpIHtcbiAgICBpZiAoZGF0YS5wb2ludGVySWQgIT09IG51bGwgJiYgZGF0YS5wb2ludGVySWQgIT09IGUucG9pbnRlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEucG9pbnRlcklkID0gZS5wb2ludGVySWQ7XG4gIH0gZWxzZSBpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRhdGEudG91Y2hJZCA9IGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICB9XG4gIGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgIC8vIGRvbid0IHByb2NlZWQgdG91Y2ggZXZlbnRcbiAgICBwcmV2ZW50RWRnZVN3aXBlKHN3aXBlciwgZSwgZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICB0b3VjaGVzLFxuICAgIGVuYWJsZWRcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gIGlmICghcGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgcmV0dXJuO1xuICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wRml4KCk7XG4gIH1cbiAgbGV0IHRhcmdldEVsID0gZS50YXJnZXQ7XG4gIGlmIChwYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICd3cmFwcGVyJykge1xuICAgIGlmICghc3dpcGVyLndyYXBwZXJFbC5jb250YWlucyh0YXJnZXRFbCkpIHJldHVybjtcbiAgfVxuICBpZiAoJ3doaWNoJyBpbiBlICYmIGUud2hpY2ggPT09IDMpIHJldHVybjtcbiAgaWYgKCdidXR0b24nIGluIGUgJiYgZS5idXR0b24gPiAwKSByZXR1cm47XG4gIGlmIChkYXRhLmlzVG91Y2hlZCAmJiBkYXRhLmlzTW92ZWQpIHJldHVybjtcblxuICAvLyBjaGFuZ2UgdGFyZ2V0IGVsIGZvciBzaGFkb3cgcm9vdCBjb21wb25lbnRcbiAgY29uc3Qgc3dpcGluZ0NsYXNzSGFzVmFsdWUgPSAhIXBhcmFtcy5ub1N3aXBpbmdDbGFzcyAmJiBwYXJhbXMubm9Td2lwaW5nQ2xhc3MgIT09ICcnO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgY29uc3QgZXZlbnRQYXRoID0gZS5jb21wb3NlZFBhdGggPyBlLmNvbXBvc2VkUGF0aCgpIDogZS5wYXRoO1xuICBpZiAoc3dpcGluZ0NsYXNzSGFzVmFsdWUgJiYgZS50YXJnZXQgJiYgZS50YXJnZXQuc2hhZG93Um9vdCAmJiBldmVudFBhdGgpIHtcbiAgICB0YXJnZXRFbCA9IGV2ZW50UGF0aFswXTtcbiAgfVxuICBjb25zdCBub1N3aXBpbmdTZWxlY3RvciA9IHBhcmFtcy5ub1N3aXBpbmdTZWxlY3RvciA/IHBhcmFtcy5ub1N3aXBpbmdTZWxlY3RvciA6IGAuJHtwYXJhbXMubm9Td2lwaW5nQ2xhc3N9YDtcbiAgY29uc3QgaXNUYXJnZXRTaGFkb3cgPSAhIShlLnRhcmdldCAmJiBlLnRhcmdldC5zaGFkb3dSb290KTtcblxuICAvLyB1c2UgY2xvc2VzdEVsZW1lbnQgZm9yIHNoYWRvdyByb290IGVsZW1lbnQgdG8gZ2V0IHRoZSBhY3R1YWwgY2xvc2VzdCBmb3IgbmVzdGVkIHNoYWRvdyByb290IGVsZW1lbnRcbiAgaWYgKHBhcmFtcy5ub1N3aXBpbmcgJiYgKGlzVGFyZ2V0U2hhZG93ID8gY2xvc2VzdEVsZW1lbnQobm9Td2lwaW5nU2VsZWN0b3IsIHRhcmdldEVsKSA6IHRhcmdldEVsLmNsb3Nlc3Qobm9Td2lwaW5nU2VsZWN0b3IpKSkge1xuICAgIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy5zd2lwZUhhbmRsZXIpIHtcbiAgICBpZiAoIXRhcmdldEVsLmNsb3Nlc3QocGFyYW1zLnN3aXBlSGFuZGxlcikpIHJldHVybjtcbiAgfVxuICB0b3VjaGVzLmN1cnJlbnRYID0gZS5wYWdlWDtcbiAgdG91Y2hlcy5jdXJyZW50WSA9IGUucGFnZVk7XG4gIGNvbnN0IHN0YXJ0WCA9IHRvdWNoZXMuY3VycmVudFg7XG4gIGNvbnN0IHN0YXJ0WSA9IHRvdWNoZXMuY3VycmVudFk7XG5cbiAgLy8gRG8gTk9UIHN0YXJ0IGlmIGlPUyBlZGdlIHN3aXBlIGlzIGRldGVjdGVkLiBPdGhlcndpc2UgaU9TIGFwcCBjYW5ub3Qgc3dpcGUtdG8tZ28tYmFjayBhbnltb3JlXG5cbiAgaWYgKCFwcmV2ZW50RWRnZVN3aXBlKHN3aXBlciwgZSwgc3RhcnRYKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICBpc1RvdWNoZWQ6IHRydWUsXG4gICAgaXNNb3ZlZDogZmFsc2UsXG4gICAgYWxsb3dUb3VjaENhbGxiYWNrczogdHJ1ZSxcbiAgICBpc1Njcm9sbGluZzogdW5kZWZpbmVkLFxuICAgIHN0YXJ0TW92aW5nOiB1bmRlZmluZWRcbiAgfSk7XG4gIHRvdWNoZXMuc3RhcnRYID0gc3RhcnRYO1xuICB0b3VjaGVzLnN0YXJ0WSA9IHN0YXJ0WTtcbiAgZGF0YS50b3VjaFN0YXJ0VGltZSA9IG5vdygpO1xuICBzd2lwZXIuYWxsb3dDbGljayA9IHRydWU7XG4gIHN3aXBlci51cGRhdGVTaXplKCk7XG4gIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgaWYgKHBhcmFtcy50aHJlc2hvbGQgPiAwKSBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSA9IGZhbHNlO1xuICBsZXQgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICBpZiAodGFyZ2V0RWwubWF0Y2hlcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgaWYgKHRhcmdldEVsLm5vZGVOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5tYXRjaGVzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsKSB7XG4gICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gIH1cbiAgY29uc3Qgc2hvdWxkUHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdCAmJiBzd2lwZXIuYWxsb3dUb3VjaE1vdmUgJiYgcGFyYW1zLnRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDtcbiAgaWYgKChwYXJhbXMudG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQgfHwgc2hvdWxkUHJldmVudERlZmF1bHQpICYmICF0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmIHN3aXBlci5mcmVlTW9kZSAmJiBzd2lwZXIuYW5pbWF0aW5nICYmICFwYXJhbXMuY3NzTW9kZSkge1xuICAgIHN3aXBlci5mcmVlTW9kZS5vblRvdWNoU3RhcnQoKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgndG91Y2hTdGFydCcsIGUpO1xufVxuXG5mdW5jdGlvbiBvblRvdWNoTW92ZShldmVudCkge1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHRvdWNoZXMsXG4gICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgZW5hYmxlZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgaWYgKCFwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgcmV0dXJuO1xuICBsZXQgZSA9IGV2ZW50O1xuICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICBpZiAoZS50eXBlID09PSAncG9pbnRlcm1vdmUnKSB7XG4gICAgaWYgKGRhdGEudG91Y2hJZCAhPT0gbnVsbCkgcmV0dXJuOyAvLyByZXR1cm4gZnJvbSBwb2ludGVyIGlmIHdlIHVzZSB0b3VjaFxuICAgIGNvbnN0IGlkID0gZS5wb2ludGVySWQ7XG4gICAgaWYgKGlkICE9PSBkYXRhLnBvaW50ZXJJZCkgcmV0dXJuO1xuICB9XG4gIGxldCB0YXJnZXRUb3VjaDtcbiAgaWYgKGUudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICB0YXJnZXRUb3VjaCA9IFsuLi5lLmNoYW5nZWRUb3VjaGVzXS5maWx0ZXIodCA9PiB0LmlkZW50aWZpZXIgPT09IGRhdGEudG91Y2hJZClbMF07XG4gICAgaWYgKCF0YXJnZXRUb3VjaCB8fCB0YXJnZXRUb3VjaC5pZGVudGlmaWVyICE9PSBkYXRhLnRvdWNoSWQpIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRUb3VjaCA9IGU7XG4gIH1cbiAgaWYgKCFkYXRhLmlzVG91Y2hlZCkge1xuICAgIGlmIChkYXRhLnN0YXJ0TW92aW5nICYmIGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFnZVggPSB0YXJnZXRUb3VjaC5wYWdlWDtcbiAgY29uc3QgcGFnZVkgPSB0YXJnZXRUb3VjaC5wYWdlWTtcbiAgaWYgKGUucHJldmVudGVkQnlOZXN0ZWRTd2lwZXIpIHtcbiAgICB0b3VjaGVzLnN0YXJ0WCA9IHBhZ2VYO1xuICAgIHRvdWNoZXMuc3RhcnRZID0gcGFnZVk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghc3dpcGVyLmFsbG93VG91Y2hNb3ZlKSB7XG4gICAgaWYgKCFlLnRhcmdldC5tYXRjaGVzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpKSB7XG4gICAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGF0YS5pc1RvdWNoZWQpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odG91Y2hlcywge1xuICAgICAgICBzdGFydFg6IHBhZ2VYLFxuICAgICAgICBzdGFydFk6IHBhZ2VZLFxuICAgICAgICBjdXJyZW50WDogcGFnZVgsXG4gICAgICAgIGN1cnJlbnRZOiBwYWdlWVxuICAgICAgfSk7XG4gICAgICBkYXRhLnRvdWNoU3RhcnRUaW1lID0gbm93KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgIXBhcmFtcy5sb29wKSB7XG4gICAgaWYgKHN3aXBlci5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIC8vIFZlcnRpY2FsXG4gICAgICBpZiAocGFnZVkgPCB0b3VjaGVzLnN0YXJ0WSAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSB8fCBwYWdlWSA+IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYWdlWCA8IHRvdWNoZXMuc3RhcnRYICYmIHN3aXBlci50cmFuc2xhdGUgPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIHx8IHBhZ2VYID4gdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA+PSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZS50YXJnZXQubWF0Y2hlcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgICAgZGF0YS5pc01vdmVkID0gdHJ1ZTtcbiAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MpIHtcbiAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlJywgZSk7XG4gIH1cbiAgdG91Y2hlcy5wcmV2aW91c1ggPSB0b3VjaGVzLmN1cnJlbnRYO1xuICB0b3VjaGVzLnByZXZpb3VzWSA9IHRvdWNoZXMuY3VycmVudFk7XG4gIHRvdWNoZXMuY3VycmVudFggPSBwYWdlWDtcbiAgdG91Y2hlcy5jdXJyZW50WSA9IHBhZ2VZO1xuICBjb25zdCBkaWZmWCA9IHRvdWNoZXMuY3VycmVudFggLSB0b3VjaGVzLnN0YXJ0WDtcbiAgY29uc3QgZGlmZlkgPSB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XG4gIGlmIChzd2lwZXIucGFyYW1zLnRocmVzaG9sZCAmJiBNYXRoLnNxcnQoZGlmZlggKiogMiArIGRpZmZZICoqIDIpIDwgc3dpcGVyLnBhcmFtcy50aHJlc2hvbGQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBkYXRhLmlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGxldCB0b3VjaEFuZ2xlO1xuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgdG91Y2hlcy5jdXJyZW50WSA9PT0gdG91Y2hlcy5zdGFydFkgfHwgc3dpcGVyLmlzVmVydGljYWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRYID09PSB0b3VjaGVzLnN0YXJ0WCkge1xuICAgICAgZGF0YS5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGlmIChkaWZmWCAqIGRpZmZYICsgZGlmZlkgKiBkaWZmWSA+PSAyNSkge1xuICAgICAgICB0b3VjaEFuZ2xlID0gTWF0aC5hdGFuMihNYXRoLmFicyhkaWZmWSksIE1hdGguYWJzKGRpZmZYKSkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlIDogOTAgLSB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZU9wcG9zaXRlJywgZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhLnN0YXJ0TW92aW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0b3VjaGVzLmN1cnJlbnRYICE9PSB0b3VjaGVzLnN0YXJ0WCB8fCB0b3VjaGVzLmN1cnJlbnRZICE9PSB0b3VjaGVzLnN0YXJ0WSkge1xuICAgICAgZGF0YS5zdGFydE1vdmluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChkYXRhLmlzU2Nyb2xsaW5nIHx8IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZGF0YS5wcmV2ZW50VG91Y2hNb3ZlRnJvbVBvaW50ZXJNb3ZlKSB7XG4gICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkYXRhLnN0YXJ0TW92aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gIGlmICghcGFyYW1zLmNzc01vZGUgJiYgZS5jYW5jZWxhYmxlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGlmIChwYXJhbXMudG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uICYmICFwYXJhbXMubmVzdGVkKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBsZXQgZGlmZiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IGRpZmZYIDogZGlmZlk7XG4gIGxldCB0b3VjaGVzRGlmZiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHRvdWNoZXMuY3VycmVudFggLSB0b3VjaGVzLnByZXZpb3VzWCA6IHRvdWNoZXMuY3VycmVudFkgLSB0b3VjaGVzLnByZXZpb3VzWTtcbiAgaWYgKHBhcmFtcy5vbmVXYXlNb3ZlbWVudCkge1xuICAgIGRpZmYgPSBNYXRoLmFicyhkaWZmKSAqIChydGwgPyAxIDogLTEpO1xuICAgIHRvdWNoZXNEaWZmID0gTWF0aC5hYnModG91Y2hlc0RpZmYpICogKHJ0bCA/IDEgOiAtMSk7XG4gIH1cbiAgdG91Y2hlcy5kaWZmID0gZGlmZjtcbiAgZGlmZiAqPSBwYXJhbXMudG91Y2hSYXRpbztcbiAgaWYgKHJ0bCkge1xuICAgIGRpZmYgPSAtZGlmZjtcbiAgICB0b3VjaGVzRGlmZiA9IC10b3VjaGVzRGlmZjtcbiAgfVxuICBjb25zdCBwcmV2VG91Y2hlc0RpcmVjdGlvbiA9IHN3aXBlci50b3VjaGVzRGlyZWN0aW9uO1xuICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSBkaWZmID4gMCA/ICdwcmV2JyA6ICduZXh0JztcbiAgc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb24gPSB0b3VjaGVzRGlmZiA+IDAgPyAncHJldicgOiAnbmV4dCc7XG4gIGNvbnN0IGlzTG9vcCA9IHN3aXBlci5wYXJhbXMubG9vcCAmJiAhcGFyYW1zLmNzc01vZGU7XG4gIGNvbnN0IGFsbG93TG9vcEZpeCA9IHN3aXBlci50b3VjaGVzRGlyZWN0aW9uID09PSAnbmV4dCcgJiYgc3dpcGVyLmFsbG93U2xpZGVOZXh0IHx8IHN3aXBlci50b3VjaGVzRGlyZWN0aW9uID09PSAncHJldicgJiYgc3dpcGVyLmFsbG93U2xpZGVQcmV2O1xuICBpZiAoIWRhdGEuaXNNb3ZlZCkge1xuICAgIGlmIChpc0xvb3AgJiYgYWxsb3dMb29wRml4KSB7XG4gICAgICBzd2lwZXIubG9vcEZpeCh7XG4gICAgICAgIGRpcmVjdGlvbjogc3dpcGVyLnN3aXBlRGlyZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGF0YS5zdGFydFRyYW5zbGF0ZSA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgICBpZiAoc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgY29uc3QgZXZ0ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudCgndHJhbnNpdGlvbmVuZCcsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG4gICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gZmFsc2U7XG4gICAgLy8gR3JhYiBDdXJzb3JcbiAgICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgKHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9PT0gdHJ1ZSB8fCBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPT09IHRydWUpKSB7XG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcih0cnVlKTtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlckZpcnN0TW92ZScsIGUpO1xuICB9XG4gIGxldCBsb29wRml4ZWQ7XG4gIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAoZGF0YS5pc01vdmVkICYmIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlICYmIHByZXZUb3VjaGVzRGlyZWN0aW9uICE9PSBzd2lwZXIudG91Y2hlc0RpcmVjdGlvbiAmJiBpc0xvb3AgJiYgYWxsb3dMb29wRml4ICYmIE1hdGguYWJzKGRpZmYpID49IDEpIHtcbiAgICBPYmplY3QuYXNzaWduKHRvdWNoZXMsIHtcbiAgICAgIHN0YXJ0WDogcGFnZVgsXG4gICAgICBzdGFydFk6IHBhZ2VZLFxuICAgICAgY3VycmVudFg6IHBhZ2VYLFxuICAgICAgY3VycmVudFk6IHBhZ2VZLFxuICAgICAgc3RhcnRUcmFuc2xhdGU6IGRhdGEuY3VycmVudFRyYW5zbGF0ZVxuICAgIH0pO1xuICAgIGRhdGEubG9vcFN3YXBSZXNldCA9IHRydWU7XG4gICAgZGF0YS5zdGFydFRyYW5zbGF0ZSA9IGRhdGEuY3VycmVudFRyYW5zbGF0ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ3NsaWRlck1vdmUnLCBlKTtcbiAgZGF0YS5pc01vdmVkID0gdHJ1ZTtcbiAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGlmZiArIGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gIGxldCBkaXNhYmxlUGFyZW50U3dpcGVyID0gdHJ1ZTtcbiAgbGV0IHJlc2lzdGFuY2VSYXRpbyA9IHBhcmFtcy5yZXNpc3RhbmNlUmF0aW87XG4gIGlmIChwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcykge1xuICAgIHJlc2lzdGFuY2VSYXRpbyA9IDA7XG4gIH1cbiAgaWYgKGRpZmYgPiAwKSB7XG4gICAgaWYgKGlzTG9vcCAmJiBhbGxvd0xvb3BGaXggJiYgIWxvb3BGaXhlZCAmJiBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIC0gc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtzd2lwZXIuYWN0aXZlSW5kZXggKyAxXSA6IHN3aXBlci5taW5UcmFuc2xhdGUoKSkpIHtcbiAgICAgIHN3aXBlci5sb29wRml4KHtcbiAgICAgICAgZGlyZWN0aW9uOiAncHJldicsXG4gICAgICAgIHNldFRyYW5zbGF0ZTogdHJ1ZSxcbiAgICAgICAgYWN0aXZlU2xpZGVJbmRleDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgIGRpc2FibGVQYXJlbnRTd2lwZXIgPSBmYWxzZTtcbiAgICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkge1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgLSAxICsgKC1zd2lwZXIubWluVHJhbnNsYXRlKCkgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlICsgZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgIGlmIChpc0xvb3AgJiYgYWxsb3dMb29wRml4ICYmICFsb29wRml4ZWQgJiYgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlIDwgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5tYXhUcmFuc2xhdGUoKSArIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbc3dpcGVyLnNsaWRlc1NpemVzR3JpZC5sZW5ndGggLSAxXSA6IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkpIHtcbiAgICAgIHN3aXBlci5sb29wRml4KHtcbiAgICAgICAgZGlyZWN0aW9uOiAnbmV4dCcsXG4gICAgICAgIHNldFRyYW5zbGF0ZTogdHJ1ZSxcbiAgICAgICAgYWN0aXZlU2xpZGVJbmRleDogc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogTWF0aC5jZWlsKHBhcnNlRmxvYXQocGFyYW1zLnNsaWRlc1BlclZpZXcsIDEwKSkpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xuICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgICAgaWYgKHBhcmFtcy5yZXNpc3RhbmNlKSB7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSArIDEgLSAoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gZGF0YS5zdGFydFRyYW5zbGF0ZSAtIGRpZmYpICoqIHJlc2lzdGFuY2VSYXRpbztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRpc2FibGVQYXJlbnRTd2lwZXIpIHtcbiAgICBlLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIERpcmVjdGlvbnMgbG9ja3NcbiAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZU5leHQgJiYgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlIDwgZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xuICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gIH1cbiAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xuICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gIH1cbiAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgIXN3aXBlci5hbGxvd1NsaWRlTmV4dCkge1xuICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gIH1cblxuICAvLyBUaHJlc2hvbGRcbiAgaWYgKHBhcmFtcy50aHJlc2hvbGQgPiAwKSB7XG4gICAgaWYgKE1hdGguYWJzKGRpZmYpID4gcGFyYW1zLnRocmVzaG9sZCB8fCBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgaWYgKCFkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgICBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSA9IHRydWU7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgICAgICAgdG91Y2hlcy5zdGFydFkgPSB0b3VjaGVzLmN1cnJlbnRZO1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgICB0b3VjaGVzLmRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKCFwYXJhbXMuZm9sbG93RmluZ2VyIHx8IHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG5cbiAgLy8gVXBkYXRlIGFjdGl2ZSBpbmRleCBpbiBmcmVlIG1vZGVcbiAgaWYgKHBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiBzd2lwZXIuZnJlZU1vZGUgfHwgcGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MpIHtcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICB9XG4gIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlKSB7XG4gICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hNb3ZlKCk7XG4gIH1cbiAgLy8gVXBkYXRlIHByb2dyZXNzXG4gIHN3aXBlci51cGRhdGVQcm9ncmVzcyhkYXRhLmN1cnJlbnRUcmFuc2xhdGUpO1xuICAvLyBVcGRhdGUgdHJhbnNsYXRlXG4gIHN3aXBlci5zZXRUcmFuc2xhdGUoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTtcbn1cblxuZnVuY3Rpb24gb25Ub3VjaEVuZChldmVudCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgbGV0IGUgPSBldmVudDtcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgbGV0IHRhcmdldFRvdWNoO1xuICBjb25zdCBpc1RvdWNoRXZlbnQgPSBlLnR5cGUgPT09ICd0b3VjaGVuZCcgfHwgZS50eXBlID09PSAndG91Y2hjYW5jZWwnO1xuICBpZiAoIWlzVG91Y2hFdmVudCkge1xuICAgIGlmIChkYXRhLnRvdWNoSWQgIT09IG51bGwpIHJldHVybjsgLy8gcmV0dXJuIGZyb20gcG9pbnRlciBpZiB3ZSB1c2UgdG91Y2hcbiAgICBpZiAoZS5wb2ludGVySWQgIT09IGRhdGEucG9pbnRlcklkKSByZXR1cm47XG4gICAgdGFyZ2V0VG91Y2ggPSBlO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFRvdWNoID0gWy4uLmUuY2hhbmdlZFRvdWNoZXNdLmZpbHRlcih0ID0+IHQuaWRlbnRpZmllciA9PT0gZGF0YS50b3VjaElkKVswXTtcbiAgICBpZiAoIXRhcmdldFRvdWNoIHx8IHRhcmdldFRvdWNoLmlkZW50aWZpZXIgIT09IGRhdGEudG91Y2hJZCkgcmV0dXJuO1xuICB9XG4gIGlmIChbJ3BvaW50ZXJjYW5jZWwnLCAncG9pbnRlcm91dCcsICdwb2ludGVybGVhdmUnLCAnY29udGV4dG1lbnUnXS5pbmNsdWRlcyhlLnR5cGUpKSB7XG4gICAgY29uc3QgcHJvY2VlZCA9IFsncG9pbnRlcmNhbmNlbCcsICdjb250ZXh0bWVudSddLmluY2x1ZGVzKGUudHlwZSkgJiYgKHN3aXBlci5icm93c2VyLmlzU2FmYXJpIHx8IHN3aXBlci5icm93c2VyLmlzV2ViVmlldyk7XG4gICAgaWYgKCFwcm9jZWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGRhdGEucG9pbnRlcklkID0gbnVsbDtcbiAgZGF0YS50b3VjaElkID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICB0b3VjaGVzLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHNsaWRlc0dyaWQsXG4gICAgZW5hYmxlZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgaWYgKCFwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSByZXR1cm47XG4gIGlmIChkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MpIHtcbiAgICBzd2lwZXIuZW1pdCgndG91Y2hFbmQnLCBlKTtcbiAgfVxuICBkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MgPSBmYWxzZTtcbiAgaWYgKCFkYXRhLmlzVG91Y2hlZCkge1xuICAgIGlmIChkYXRhLmlzTW92ZWQgJiYgcGFyYW1zLmdyYWJDdXJzb3IpIHtcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKGZhbHNlKTtcbiAgICB9XG4gICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJldHVybiBHcmFiIEN1cnNvclxuICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgZGF0YS5pc01vdmVkICYmIGRhdGEuaXNUb3VjaGVkICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xuICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKGZhbHNlKTtcbiAgfVxuXG4gIC8vIFRpbWUgZGlmZlxuICBjb25zdCB0b3VjaEVuZFRpbWUgPSBub3coKTtcbiAgY29uc3QgdGltZURpZmYgPSB0b3VjaEVuZFRpbWUgLSBkYXRhLnRvdWNoU3RhcnRUaW1lO1xuXG4gIC8vIFRhcCwgZG91YmxlVGFwLCBDbGlja1xuICBpZiAoc3dpcGVyLmFsbG93Q2xpY2spIHtcbiAgICBjb25zdCBwYXRoVHJlZSA9IGUucGF0aCB8fCBlLmNvbXBvc2VkUGF0aCAmJiBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHN3aXBlci51cGRhdGVDbGlja2VkU2xpZGUocGF0aFRyZWUgJiYgcGF0aFRyZWVbMF0gfHwgZS50YXJnZXQsIHBhdGhUcmVlKTtcbiAgICBzd2lwZXIuZW1pdCgndGFwIGNsaWNrJywgZSk7XG4gICAgaWYgKHRpbWVEaWZmIDwgMzAwICYmIHRvdWNoRW5kVGltZSAtIGRhdGEubGFzdENsaWNrVGltZSA8IDMwMCkge1xuICAgICAgc3dpcGVyLmVtaXQoJ2RvdWJsZVRhcCBkb3VibGVDbGljaycsIGUpO1xuICAgIH1cbiAgfVxuICBkYXRhLmxhc3RDbGlja1RpbWUgPSBub3coKTtcbiAgbmV4dFRpY2soKCkgPT4ge1xuICAgIGlmICghc3dpcGVyLmRlc3Ryb3llZCkgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICB9KTtcbiAgaWYgKCFkYXRhLmlzVG91Y2hlZCB8fCAhZGF0YS5pc01vdmVkIHx8ICFzd2lwZXIuc3dpcGVEaXJlY3Rpb24gfHwgdG91Y2hlcy5kaWZmID09PSAwICYmICFkYXRhLmxvb3BTd2FwUmVzZXQgfHwgZGF0YS5jdXJyZW50VHJhbnNsYXRlID09PSBkYXRhLnN0YXJ0VHJhbnNsYXRlICYmICFkYXRhLmxvb3BTd2FwUmVzZXQpIHtcbiAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbiAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcbiAgbGV0IGN1cnJlbnRQb3M7XG4gIGlmIChwYXJhbXMuZm9sbG93RmluZ2VyKSB7XG4gICAgY3VycmVudFBvcyA9IHJ0bCA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50UG9zID0gLWRhdGEuY3VycmVudFRyYW5zbGF0ZTtcbiAgfVxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCkge1xuICAgIHN3aXBlci5mcmVlTW9kZS5vblRvdWNoRW5kKHtcbiAgICAgIGN1cnJlbnRQb3NcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaW5kIGN1cnJlbnQgc2xpZGVcbiAgY29uc3Qgc3dpcGVUb0xhc3QgPSBjdXJyZW50UG9zID49IC1zd2lwZXIubWF4VHJhbnNsYXRlKCkgJiYgIXN3aXBlci5wYXJhbXMubG9vcDtcbiAgbGV0IHN0b3BJbmRleCA9IDA7XG4gIGxldCBncm91cFNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkWzBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IGkgPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cCkge1xuICAgIGNvbnN0IGluY3JlbWVudCA9IGkgPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHN3aXBlVG9MYXN0IHx8IGN1cnJlbnRQb3MgPj0gc2xpZGVzR3JpZFtpXSAmJiBjdXJyZW50UG9zIDwgc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSkge1xuICAgICAgICBzdG9wSW5kZXggPSBpO1xuICAgICAgICBncm91cFNpemUgPSBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdIC0gc2xpZGVzR3JpZFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN3aXBlVG9MYXN0IHx8IGN1cnJlbnRQb3MgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgc3RvcEluZGV4ID0gaTtcbiAgICAgIGdyb3VwU2l6ZSA9IHNsaWRlc0dyaWRbc2xpZGVzR3JpZC5sZW5ndGggLSAxXSAtIHNsaWRlc0dyaWRbc2xpZGVzR3JpZC5sZW5ndGggLSAyXTtcbiAgICB9XG4gIH1cbiAgbGV0IHJld2luZEZpcnN0SW5kZXggPSBudWxsO1xuICBsZXQgcmV3aW5kTGFzdEluZGV4ID0gbnVsbDtcbiAgaWYgKHBhcmFtcy5yZXdpbmQpIHtcbiAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICByZXdpbmRMYXN0SW5kZXggPSBwYXJhbXMudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHN3aXBlci52aXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIGlmIChzd2lwZXIuaXNFbmQpIHtcbiAgICAgIHJld2luZEZpcnN0SW5kZXggPSAwO1xuICAgIH1cbiAgfVxuICAvLyBGaW5kIGN1cnJlbnQgc2xpZGUgc2l6ZVxuICBjb25zdCByYXRpbyA9IChjdXJyZW50UG9zIC0gc2xpZGVzR3JpZFtzdG9wSW5kZXhdKSAvIGdyb3VwU2l6ZTtcbiAgY29uc3QgaW5jcmVtZW50ID0gc3RvcEluZGV4IDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICBpZiAodGltZURpZmYgPiBwYXJhbXMubG9uZ1N3aXBlc01zKSB7XG4gICAgLy8gTG9uZyB0b3VjaGVzXG4gICAgaWYgKCFwYXJhbXMubG9uZ1N3aXBlcykge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICBpZiAocmF0aW8gPj0gcGFyYW1zLmxvbmdTd2lwZXNSYXRpbykgc3dpcGVyLnNsaWRlVG8ocGFyYW1zLnJld2luZCAmJiBzd2lwZXIuaXNFbmQgPyByZXdpbmRGaXJzdEluZGV4IDogc3RvcEluZGV4ICsgaW5jcmVtZW50KTtlbHNlIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgaWYgKHJhdGlvID4gMSAtIHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAocmV3aW5kTGFzdEluZGV4ICE9PSBudWxsICYmIHJhdGlvIDwgMCAmJiBNYXRoLmFicyhyYXRpbykgPiBwYXJhbXMubG9uZ1N3aXBlc1JhdGlvKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHJld2luZExhc3RJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTaG9ydCBzd2lwZXNcbiAgICBpZiAoIXBhcmFtcy5zaG9ydFN3aXBlcykge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNOYXZCdXR0b25UYXJnZXQgPSBzd2lwZXIubmF2aWdhdGlvbiAmJiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCB8fCBlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsKTtcbiAgICBpZiAoIWlzTmF2QnV0dG9uVGFyZ2V0KSB7XG4gICAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kRmlyc3RJbmRleCAhPT0gbnVsbCA/IHJld2luZEZpcnN0SW5kZXggOiBzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHJld2luZExhc3RJbmRleCAhPT0gbnVsbCA/IHJld2luZExhc3RJbmRleCA6IHN0b3BJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBlbFxuICB9ID0gc3dpcGVyO1xuICBpZiAoZWwgJiYgZWwub2Zmc2V0V2lkdGggPT09IDApIHJldHVybjtcblxuICAvLyBCcmVha3BvaW50c1xuICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgfVxuXG4gIC8vIFNhdmUgbG9ja3NcbiAgY29uc3Qge1xuICAgIGFsbG93U2xpZGVOZXh0LFxuICAgIGFsbG93U2xpZGVQcmV2LFxuICAgIHNuYXBHcmlkXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuXG4gIC8vIERpc2FibGUgbG9ja3Mgb24gcmVzaXplXG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XG4gIHN3aXBlci51cGRhdGVTaXplKCk7XG4gIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgY29uc3QgaXNWaXJ0dWFsTG9vcCA9IGlzVmlydHVhbCAmJiBwYXJhbXMubG9vcDtcbiAgaWYgKChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nIHx8IHBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIuaXNCZWdpbm5pbmcgJiYgIXN3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgIWlzVmlydHVhbExvb3ApIHtcbiAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDEsIDAsIGZhbHNlLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wICYmICFpc1ZpcnR1YWwpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvTG9vcChzd2lwZXIucmVhbEluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAoc3dpcGVyLmF1dG9wbGF5ICYmIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHtcbiAgICBjbGVhclRpbWVvdXQoc3dpcGVyLmF1dG9wbGF5LnJlc2l6ZVRpbWVvdXQpO1xuICAgIHN3aXBlci5hdXRvcGxheS5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5ICYmIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHtcbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnJlc3VtZSgpO1xuICAgICAgfVxuICAgIH0sIDUwMCk7XG4gIH1cbiAgLy8gUmV0dXJuIGxvY2tzIGFmdGVyIHJlc2l6ZVxuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gYWxsb3dTbGlkZU5leHQ7XG4gIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc25hcEdyaWQgIT09IHN3aXBlci5zbmFwR3JpZCkge1xuICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25DbGljayhlKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgaWYgKCFzd2lwZXIuYWxsb3dDbGljaykge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3MpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24gJiYgc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU2Nyb2xsKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgd3JhcHBlckVsLFxuICAgIHJ0bFRyYW5zbGF0ZSxcbiAgICBlbmFibGVkXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICBzd2lwZXIucHJldmlvdXNUcmFuc2xhdGUgPSBzd2lwZXIudHJhbnNsYXRlO1xuICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgc3dpcGVyLnRyYW5zbGF0ZSA9IC13cmFwcGVyRWwuc2Nyb2xsTGVmdDtcbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxUb3A7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGlmIChzd2lwZXIudHJhbnNsYXRlID09PSAwKSBzd2lwZXIudHJhbnNsYXRlID0gMDtcbiAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIGxldCBuZXdQcm9ncmVzcztcbiAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgIG5ld1Byb2dyZXNzID0gMDtcbiAgfSBlbHNlIHtcbiAgICBuZXdQcm9ncmVzcyA9IChzd2lwZXIudHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICB9XG4gIGlmIChuZXdQcm9ncmVzcyAhPT0gc3dpcGVyLnByb2dyZXNzKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHJ0bFRyYW5zbGF0ZSA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSk7XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zbGF0ZScsIHN3aXBlci50cmFuc2xhdGUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gb25Mb2FkKGUpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgcHJvY2Vzc0xhenlQcmVsb2FkZXIoc3dpcGVyLCBlLnRhcmdldCk7XG4gIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUgfHwgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgIXN3aXBlci5wYXJhbXMuYXV0b0hlaWdodCkge1xuICAgIHJldHVybjtcbiAgfVxuICBzd2lwZXIudXBkYXRlKCk7XG59XG5cbmZ1bmN0aW9uIG9uRG9jdW1lbnRUb3VjaFN0YXJ0KCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoc3dpcGVyLmRvY3VtZW50VG91Y2hIYW5kbGVyUHJvY2VlZGVkKSByZXR1cm47XG4gIHN3aXBlci5kb2N1bWVudFRvdWNoSGFuZGxlclByb2NlZWRlZCA9IHRydWU7XG4gIGlmIChzd2lwZXIucGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMpIHtcbiAgICBzd2lwZXIuZWwuc3R5bGUudG91Y2hBY3Rpb24gPSAnYXV0byc7XG4gIH1cbn1cblxuY29uc3QgZXZlbnRzID0gKHN3aXBlciwgbWV0aG9kKSA9PiB7XG4gIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBlbCxcbiAgICB3cmFwcGVyRWwsXG4gICAgZGV2aWNlXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGNhcHR1cmUgPSAhIXBhcmFtcy5uZXN0ZWQ7XG4gIGNvbnN0IGRvbU1ldGhvZCA9IG1ldGhvZCA9PT0gJ29uJyA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgY29uc3Qgc3dpcGVyTWV0aG9kID0gbWV0aG9kO1xuXG4gIC8vIFRvdWNoIEV2ZW50c1xuICBkb2N1bWVudFtkb21NZXRob2RdKCd0b3VjaHN0YXJ0Jywgc3dpcGVyLm9uRG9jdW1lbnRUb3VjaFN0YXJ0LCB7XG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgY2FwdHVyZVxuICB9KTtcbiAgZWxbZG9tTWV0aG9kXSgndG91Y2hzdGFydCcsIHN3aXBlci5vblRvdWNoU3RhcnQsIHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9KTtcbiAgZWxbZG9tTWV0aG9kXSgncG9pbnRlcmRvd24nLCBzd2lwZXIub25Ub3VjaFN0YXJ0LCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3RvdWNobW92ZScsIHN3aXBlci5vblRvdWNoTW92ZSwge1xuICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgIGNhcHR1cmVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJtb3ZlJywgc3dpcGVyLm9uVG91Y2hNb3ZlLCB7XG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgY2FwdHVyZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgndG91Y2hlbmQnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJ1cCcsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgncG9pbnRlcmNhbmNlbCcsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgndG91Y2hjYW5jZWwnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJvdXQnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJsZWF2ZScsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgnY29udGV4dG1lbnUnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG5cbiAgLy8gUHJldmVudCBMaW5rcyBDbGlja3NcbiAgaWYgKHBhcmFtcy5wcmV2ZW50Q2xpY2tzIHx8IHBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pIHtcbiAgICBlbFtkb21NZXRob2RdKCdjbGljaycsIHN3aXBlci5vbkNsaWNrLCB0cnVlKTtcbiAgfVxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICB3cmFwcGVyRWxbZG9tTWV0aG9kXSgnc2Nyb2xsJywgc3dpcGVyLm9uU2Nyb2xsKTtcbiAgfVxuXG4gIC8vIFJlc2l6ZSBoYW5kbGVyXG4gIGlmIChwYXJhbXMudXBkYXRlT25XaW5kb3dSZXNpemUpIHtcbiAgICBzd2lwZXJbc3dpcGVyTWV0aG9kXShkZXZpY2UuaW9zIHx8IGRldmljZS5hbmRyb2lkID8gJ3Jlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZSBvYnNlcnZlclVwZGF0ZScgOiAncmVzaXplIG9ic2VydmVyVXBkYXRlJywgb25SZXNpemUsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN3aXBlcltzd2lwZXJNZXRob2RdKCdvYnNlcnZlclVwZGF0ZScsIG9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEltYWdlcyBsb2FkZXJcbiAgZWxbZG9tTWV0aG9kXSgnbG9hZCcsIHN3aXBlci5vbkxvYWQsIHtcbiAgICBjYXB0dXJlOiB0cnVlXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBzd2lwZXIub25Ub3VjaFN0YXJ0ID0gb25Ub3VjaFN0YXJ0LmJpbmQoc3dpcGVyKTtcbiAgc3dpcGVyLm9uVG91Y2hNb3ZlID0gb25Ub3VjaE1vdmUuYmluZChzd2lwZXIpO1xuICBzd2lwZXIub25Ub3VjaEVuZCA9IG9uVG91Y2hFbmQuYmluZChzd2lwZXIpO1xuICBzd2lwZXIub25Eb2N1bWVudFRvdWNoU3RhcnQgPSBvbkRvY3VtZW50VG91Y2hTdGFydC5iaW5kKHN3aXBlcik7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHN3aXBlci5vblNjcm9sbCA9IG9uU2Nyb2xsLmJpbmQoc3dpcGVyKTtcbiAgfVxuICBzd2lwZXIub25DbGljayA9IG9uQ2xpY2suYmluZChzd2lwZXIpO1xuICBzd2lwZXIub25Mb2FkID0gb25Mb2FkLmJpbmQoc3dpcGVyKTtcbiAgZXZlbnRzKHN3aXBlciwgJ29uJyk7XG59XG5mdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGV2ZW50cyhzd2lwZXIsICdvZmYnKTtcbn1cbnZhciBldmVudHMkMSA9IHtcbiAgYXR0YWNoRXZlbnRzLFxuICBkZXRhY2hFdmVudHNcbn07XG5cbmNvbnN0IGlzR3JpZEVuYWJsZWQgPSAoc3dpcGVyLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xufTtcbmZ1bmN0aW9uIHNldEJyZWFrcG9pbnQoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICByZWFsSW5kZXgsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgcGFyYW1zLFxuICAgIGVsXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGJyZWFrcG9pbnRzID0gcGFyYW1zLmJyZWFrcG9pbnRzO1xuICBpZiAoIWJyZWFrcG9pbnRzIHx8IGJyZWFrcG9pbnRzICYmIE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAvLyBHZXQgYnJlYWtwb2ludCBmb3Igd2luZG93IHdpZHRoIGFuZCB1cGRhdGUgcGFyYW1ldGVyc1xuICBjb25zdCBicmVha3BvaW50ID0gc3dpcGVyLmdldEJyZWFrcG9pbnQoYnJlYWtwb2ludHMsIHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHNCYXNlLCBzd2lwZXIuZWwpO1xuICBpZiAoIWJyZWFrcG9pbnQgfHwgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ID09PSBicmVha3BvaW50KSByZXR1cm47XG4gIGNvbnN0IGJyZWFrcG9pbnRPbmx5UGFyYW1zID0gYnJlYWtwb2ludCBpbiBicmVha3BvaW50cyA/IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBicmVha3BvaW50UGFyYW1zID0gYnJlYWtwb2ludE9ubHlQYXJhbXMgfHwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zO1xuICBjb25zdCB3YXNNdWx0aVJvdyA9IGlzR3JpZEVuYWJsZWQoc3dpcGVyLCBwYXJhbXMpO1xuICBjb25zdCBpc011bHRpUm93ID0gaXNHcmlkRW5hYmxlZChzd2lwZXIsIGJyZWFrcG9pbnRQYXJhbXMpO1xuICBjb25zdCB3YXNHcmFiQ3Vyc29yID0gc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yO1xuICBjb25zdCBpc0dyYWJDdXJzb3IgPSBicmVha3BvaW50UGFyYW1zLmdyYWJDdXJzb3I7XG4gIGNvbnN0IHdhc0VuYWJsZWQgPSBwYXJhbXMuZW5hYmxlZDtcbiAgaWYgKHdhc011bHRpUm93ICYmICFpc011bHRpUm93KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkYCwgYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbiAgfSBlbHNlIGlmICghd2FzTXVsdGlSb3cgJiYgaXNNdWx0aVJvdykge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZGApO1xuICAgIGlmIChicmVha3BvaW50UGFyYW1zLmdyaWQuZmlsbCAmJiBicmVha3BvaW50UGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicgfHwgIWJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdjb2x1bW4nKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWQtY29sdW1uYCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICB9XG4gIGlmICh3YXNHcmFiQ3Vyc29yICYmICFpc0dyYWJDdXJzb3IpIHtcbiAgICBzd2lwZXIudW5zZXRHcmFiQ3Vyc29yKCk7XG4gIH0gZWxzZSBpZiAoIXdhc0dyYWJDdXJzb3IgJiYgaXNHcmFiQ3Vyc29yKSB7XG4gICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoKTtcbiAgfVxuXG4gIC8vIFRvZ2dsZSBuYXZpZ2F0aW9uLCBwYWdpbmF0aW9uLCBzY3JvbGxiYXJcbiAgWyduYXZpZ2F0aW9uJywgJ3BhZ2luYXRpb24nLCAnc2Nyb2xsYmFyJ10uZm9yRWFjaChwcm9wID0+IHtcbiAgICBpZiAodHlwZW9mIGJyZWFrcG9pbnRQYXJhbXNbcHJvcF0gPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgY29uc3Qgd2FzTW9kdWxlRW5hYmxlZCA9IHBhcmFtc1twcm9wXSAmJiBwYXJhbXNbcHJvcF0uZW5hYmxlZDtcbiAgICBjb25zdCBpc01vZHVsZUVuYWJsZWQgPSBicmVha3BvaW50UGFyYW1zW3Byb3BdICYmIGJyZWFrcG9pbnRQYXJhbXNbcHJvcF0uZW5hYmxlZDtcbiAgICBpZiAod2FzTW9kdWxlRW5hYmxlZCAmJiAhaXNNb2R1bGVFbmFibGVkKSB7XG4gICAgICBzd2lwZXJbcHJvcF0uZGlzYWJsZSgpO1xuICAgIH1cbiAgICBpZiAoIXdhc01vZHVsZUVuYWJsZWQgJiYgaXNNb2R1bGVFbmFibGVkKSB7XG4gICAgICBzd2lwZXJbcHJvcF0uZW5hYmxlKCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZGlyZWN0aW9uQ2hhbmdlZCA9IGJyZWFrcG9pbnRQYXJhbXMuZGlyZWN0aW9uICYmIGJyZWFrcG9pbnRQYXJhbXMuZGlyZWN0aW9uICE9PSBwYXJhbXMuZGlyZWN0aW9uO1xuICBjb25zdCBuZWVkc1JlTG9vcCA9IHBhcmFtcy5sb29wICYmIChicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlclZpZXcgIT09IHBhcmFtcy5zbGlkZXNQZXJWaWV3IHx8IGRpcmVjdGlvbkNoYW5nZWQpO1xuICBjb25zdCB3YXNMb29wID0gcGFyYW1zLmxvb3A7XG4gIGlmIChkaXJlY3Rpb25DaGFuZ2VkICYmIGluaXRpYWxpemVkKSB7XG4gICAgc3dpcGVyLmNoYW5nZURpcmVjdGlvbigpO1xuICB9XG4gIGV4dGVuZChzd2lwZXIucGFyYW1zLCBicmVha3BvaW50UGFyYW1zKTtcbiAgY29uc3QgaXNFbmFibGVkID0gc3dpcGVyLnBhcmFtcy5lbmFibGVkO1xuICBjb25zdCBoYXNMb29wID0gc3dpcGVyLnBhcmFtcy5sb29wO1xuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIGFsbG93VG91Y2hNb3ZlOiBzd2lwZXIucGFyYW1zLmFsbG93VG91Y2hNb3ZlLFxuICAgIGFsbG93U2xpZGVOZXh0OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVOZXh0LFxuICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2XG4gIH0pO1xuICBpZiAod2FzRW5hYmxlZCAmJiAhaXNFbmFibGVkKSB7XG4gICAgc3dpcGVyLmRpc2FibGUoKTtcbiAgfSBlbHNlIGlmICghd2FzRW5hYmxlZCAmJiBpc0VuYWJsZWQpIHtcbiAgICBzd2lwZXIuZW5hYmxlKCk7XG4gIH1cbiAgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ID0gYnJlYWtwb2ludDtcbiAgc3dpcGVyLmVtaXQoJ19iZWZvcmVCcmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIGlmIChuZWVkc1JlTG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgICBzd2lwZXIubG9vcENyZWF0ZShyZWFsSW5kZXgpO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgIH0gZWxzZSBpZiAoIXdhc0xvb3AgJiYgaGFzTG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUocmVhbEluZGV4KTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICB9IGVsc2UgaWYgKHdhc0xvb3AgJiYgIWhhc0xvb3ApIHtcbiAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBzd2lwZXIuZW1pdCgnYnJlYWtwb2ludCcsIGJyZWFrcG9pbnRQYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBnZXRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCBiYXNlLCBjb250YWluZXJFbCkge1xuICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZSA9ICd3aW5kb3cnO1xuICB9XG4gIGlmICghYnJlYWtwb2ludHMgfHwgYmFzZSA9PT0gJ2NvbnRhaW5lcicgJiYgIWNvbnRhaW5lckVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICBsZXQgYnJlYWtwb2ludCA9IGZhbHNlO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgY3VycmVudEhlaWdodCA9IGJhc2UgPT09ICd3aW5kb3cnID8gd2luZG93LmlubmVySGVpZ2h0IDogY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICBjb25zdCBwb2ludHMgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykubWFwKHBvaW50ID0+IHtcbiAgICBpZiAodHlwZW9mIHBvaW50ID09PSAnc3RyaW5nJyAmJiBwb2ludC5pbmRleE9mKCdAJykgPT09IDApIHtcbiAgICAgIGNvbnN0IG1pblJhdGlvID0gcGFyc2VGbG9hdChwb2ludC5zdWJzdHIoMSkpO1xuICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50SGVpZ2h0ICogbWluUmF0aW87XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcG9pbnRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogcG9pbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH0pO1xuICBwb2ludHMuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYS52YWx1ZSwgMTApIC0gcGFyc2VJbnQoYi52YWx1ZSwgMTApKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb2ludCxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHBvaW50c1tpXTtcbiAgICBpZiAoYmFzZSA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShgKG1pbi13aWR0aDogJHt2YWx1ZX1weClgKS5tYXRjaGVzKSB7XG4gICAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IGNvbnRhaW5lckVsLmNsaWVudFdpZHRoKSB7XG4gICAgICBicmVha3BvaW50ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBicmVha3BvaW50IHx8ICdtYXgnO1xufVxuXG52YXIgYnJlYWtwb2ludHMgPSB7XG4gIHNldEJyZWFrcG9pbnQsXG4gIGdldEJyZWFrcG9pbnRcbn07XG5cbmZ1bmN0aW9uIHByZXBhcmVDbGFzc2VzKGVudHJpZXMsIHByZWZpeCkge1xuICBjb25zdCByZXN1bHRDbGFzc2VzID0gW107XG4gIGVudHJpZXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyhpdGVtKS5mb3JFYWNoKGNsYXNzTmFtZXMgPT4ge1xuICAgICAgICBpZiAoaXRlbVtjbGFzc05hbWVzXSkge1xuICAgICAgICAgIHJlc3VsdENsYXNzZXMucHVzaChwcmVmaXggKyBjbGFzc05hbWVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlc3VsdENsYXNzZXMucHVzaChwcmVmaXggKyBpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0Q2xhc3Nlcztcbn1cbmZ1bmN0aW9uIGFkZENsYXNzZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBjbGFzc05hbWVzLFxuICAgIHBhcmFtcyxcbiAgICBydGwsXG4gICAgZWwsXG4gICAgZGV2aWNlXG4gIH0gPSBzd2lwZXI7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBjb25zdCBzdWZmaXhlcyA9IHByZXBhcmVDbGFzc2VzKFsnaW5pdGlhbGl6ZWQnLCBwYXJhbXMuZGlyZWN0aW9uLCB7XG4gICAgJ2ZyZWUtbW9kZSc6IHN3aXBlci5wYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWRcbiAgfSwge1xuICAgICdhdXRvaGVpZ2h0JzogcGFyYW1zLmF1dG9IZWlnaHRcbiAgfSwge1xuICAgICdydGwnOiBydGxcbiAgfSwge1xuICAgICdncmlkJzogcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDFcbiAgfSwge1xuICAgICdncmlkLWNvbHVtbic6IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdjb2x1bW4nXG4gIH0sIHtcbiAgICAnYW5kcm9pZCc6IGRldmljZS5hbmRyb2lkXG4gIH0sIHtcbiAgICAnaW9zJzogZGV2aWNlLmlvc1xuICB9LCB7XG4gICAgJ2Nzcy1tb2RlJzogcGFyYW1zLmNzc01vZGVcbiAgfSwge1xuICAgICdjZW50ZXJlZCc6IHBhcmFtcy5jc3NNb2RlICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlc1xuICB9LCB7XG4gICAgJ3dhdGNoLXByb2dyZXNzJzogcGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3NcbiAgfV0sIHBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzKTtcbiAgY2xhc3NOYW1lcy5wdXNoKC4uLnN1ZmZpeGVzKTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBlbCxcbiAgICBjbGFzc05hbWVzXG4gIH0gPSBzd2lwZXI7XG4gIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xufVxuXG52YXIgY2xhc3NlcyA9IHtcbiAgYWRkQ2xhc3NlcyxcbiAgcmVtb3ZlQ2xhc3Nlc1xufTtcblxuZnVuY3Rpb24gY2hlY2tPdmVyZmxvdygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIGlzTG9ja2VkOiB3YXNMb2NrZWQsXG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IHtcbiAgICBzbGlkZXNPZmZzZXRCZWZvcmVcbiAgfSA9IHBhcmFtcztcbiAgaWYgKHNsaWRlc09mZnNldEJlZm9yZSkge1xuICAgIGNvbnN0IGxhc3RTbGlkZUluZGV4ID0gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGxhc3RTbGlkZVJpZ2h0RWRnZSA9IHN3aXBlci5zbGlkZXNHcmlkW2xhc3RTbGlkZUluZGV4XSArIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbbGFzdFNsaWRlSW5kZXhdICsgc2xpZGVzT2Zmc2V0QmVmb3JlICogMjtcbiAgICBzd2lwZXIuaXNMb2NrZWQgPSBzd2lwZXIuc2l6ZSA+IGxhc3RTbGlkZVJpZ2h0RWRnZTtcbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuaXNMb2NrZWQgPSBzd2lwZXIuc25hcEdyaWQubGVuZ3RoID09PSAxO1xuICB9XG4gIGlmIChwYXJhbXMuYWxsb3dTbGlkZU5leHQgPT09IHRydWUpIHtcbiAgICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSAhc3dpcGVyLmlzTG9ja2VkO1xuICB9XG4gIGlmIChwYXJhbXMuYWxsb3dTbGlkZVByZXYgPT09IHRydWUpIHtcbiAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSAhc3dpcGVyLmlzTG9ja2VkO1xuICB9XG4gIGlmICh3YXNMb2NrZWQgJiYgd2FzTG9ja2VkICE9PSBzd2lwZXIuaXNMb2NrZWQpIHtcbiAgICBzd2lwZXIuaXNFbmQgPSBmYWxzZTtcbiAgfVxuICBpZiAod2FzTG9ja2VkICE9PSBzd2lwZXIuaXNMb2NrZWQpIHtcbiAgICBzd2lwZXIuZW1pdChzd2lwZXIuaXNMb2NrZWQgPyAnbG9jaycgOiAndW5sb2NrJyk7XG4gIH1cbn1cbnZhciBjaGVja092ZXJmbG93JDEgPSB7XG4gIGNoZWNrT3ZlcmZsb3dcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgaW5pdDogdHJ1ZSxcbiAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gIG9uZVdheU1vdmVtZW50OiBmYWxzZSxcbiAgc3dpcGVyRWxlbWVudE5vZGVOYW1lOiAnU1dJUEVSLUNPTlRBSU5FUicsXG4gIHRvdWNoRXZlbnRzVGFyZ2V0OiAnd3JhcHBlcicsXG4gIGluaXRpYWxTbGlkZTogMCxcbiAgc3BlZWQ6IDMwMCxcbiAgY3NzTW9kZTogZmFsc2UsXG4gIHVwZGF0ZU9uV2luZG93UmVzaXplOiB0cnVlLFxuICByZXNpemVPYnNlcnZlcjogdHJ1ZSxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgY3JlYXRlRWxlbWVudHM6IGZhbHNlLFxuICBldmVudHNQcmVmaXg6ICdzd2lwZXInLFxuICBlbmFibGVkOiB0cnVlLFxuICBmb2N1c2FibGVFbGVtZW50czogJ2lucHV0LCBzZWxlY3QsIG9wdGlvbiwgdGV4dGFyZWEsIGJ1dHRvbiwgdmlkZW8sIGxhYmVsJyxcbiAgLy8gT3ZlcnJpZGVzXG4gIHdpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIC8vXG4gIHByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbjogZmFsc2UsXG4gIC8vIHNzclxuICB1c2VyQWdlbnQ6IG51bGwsXG4gIHVybDogbnVsbCxcbiAgLy8gVG8gc3VwcG9ydCBpT1MncyBzd2lwZS10by1nby1iYWNrIGdlc3R1cmUgKHdoZW4gYmVpbmcgdXNlZCBpbi1hcHApLlxuICBlZGdlU3dpcGVEZXRlY3Rpb246IGZhbHNlLFxuICBlZGdlU3dpcGVUaHJlc2hvbGQ6IDIwLFxuICAvLyBBdXRvaGVpZ2h0XG4gIGF1dG9IZWlnaHQ6IGZhbHNlLFxuICAvLyBTZXQgd3JhcHBlciB3aWR0aFxuICBzZXRXcmFwcGVyU2l6ZTogZmFsc2UsXG4gIC8vIFZpcnR1YWwgVHJhbnNsYXRlXG4gIHZpcnR1YWxUcmFuc2xhdGU6IGZhbHNlLFxuICAvLyBFZmZlY3RzXG4gIGVmZmVjdDogJ3NsaWRlJyxcbiAgLy8gJ3NsaWRlJyBvciAnZmFkZScgb3IgJ2N1YmUnIG9yICdjb3ZlcmZsb3cnIG9yICdmbGlwJ1xuXG4gIC8vIEJyZWFrcG9pbnRzXG4gIGJyZWFrcG9pbnRzOiB1bmRlZmluZWQsXG4gIGJyZWFrcG9pbnRzQmFzZTogJ3dpbmRvdycsXG4gIC8vIFNsaWRlcyBncmlkXG4gIHNwYWNlQmV0d2VlbjogMCxcbiAgc2xpZGVzUGVyVmlldzogMSxcbiAgc2xpZGVzUGVyR3JvdXA6IDEsXG4gIHNsaWRlc1Blckdyb3VwU2tpcDogMCxcbiAgc2xpZGVzUGVyR3JvdXBBdXRvOiBmYWxzZSxcbiAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxuICBjZW50ZXJlZFNsaWRlc0JvdW5kczogZmFsc2UsXG4gIHNsaWRlc09mZnNldEJlZm9yZTogMCxcbiAgLy8gaW4gcHhcbiAgc2xpZGVzT2Zmc2V0QWZ0ZXI6IDAsXG4gIC8vIGluIHB4XG4gIG5vcm1hbGl6ZVNsaWRlSW5kZXg6IHRydWUsXG4gIGNlbnRlckluc3VmZmljaWVudFNsaWRlczogZmFsc2UsXG4gIC8vIERpc2FibGUgc3dpcGVyIGFuZCBoaWRlIG5hdmlnYXRpb24gd2hlbiBjb250YWluZXIgbm90IG92ZXJmbG93XG4gIHdhdGNoT3ZlcmZsb3c6IHRydWUsXG4gIC8vIFJvdW5kIGxlbmd0aFxuICByb3VuZExlbmd0aHM6IGZhbHNlLFxuICAvLyBUb3VjaGVzXG4gIHRvdWNoUmF0aW86IDEsXG4gIHRvdWNoQW5nbGU6IDQ1LFxuICBzaW11bGF0ZVRvdWNoOiB0cnVlLFxuICBzaG9ydFN3aXBlczogdHJ1ZSxcbiAgbG9uZ1N3aXBlczogdHJ1ZSxcbiAgbG9uZ1N3aXBlc1JhdGlvOiAwLjUsXG4gIGxvbmdTd2lwZXNNczogMzAwLFxuICBmb2xsb3dGaW5nZXI6IHRydWUsXG4gIGFsbG93VG91Y2hNb3ZlOiB0cnVlLFxuICB0aHJlc2hvbGQ6IDUsXG4gIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gIHRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgdG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICB0b3VjaFJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgLy8gVW5pcXVlIE5hdmlnYXRpb24gRWxlbWVudHNcbiAgdW5pcXVlTmF2RWxlbWVudHM6IHRydWUsXG4gIC8vIFJlc2lzdGFuY2VcbiAgcmVzaXN0YW5jZTogdHJ1ZSxcbiAgcmVzaXN0YW5jZVJhdGlvOiAwLjg1LFxuICAvLyBQcm9ncmVzc1xuICB3YXRjaFNsaWRlc1Byb2dyZXNzOiBmYWxzZSxcbiAgLy8gQ3Vyc29yXG4gIGdyYWJDdXJzb3I6IGZhbHNlLFxuICAvLyBDbGlja3NcbiAgcHJldmVudENsaWNrczogdHJ1ZSxcbiAgcHJldmVudENsaWNrc1Byb3BhZ2F0aW9uOiB0cnVlLFxuICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZSxcbiAgLy8gbG9vcFxuICBsb29wOiBmYWxzZSxcbiAgbG9vcEFkZEJsYW5rU2xpZGVzOiB0cnVlLFxuICBsb29wQWRkaXRpb25hbFNsaWRlczogMCxcbiAgbG9vcFByZXZlbnRzU2xpZGluZzogdHJ1ZSxcbiAgLy8gcmV3aW5kXG4gIHJld2luZDogZmFsc2UsXG4gIC8vIFN3aXBpbmcvbm8gc3dpcGluZ1xuICBhbGxvd1NsaWRlUHJldjogdHJ1ZSxcbiAgYWxsb3dTbGlkZU5leHQ6IHRydWUsXG4gIHN3aXBlSGFuZGxlcjogbnVsbCxcbiAgLy8gJy5zd2lwZS1oYW5kbGVyJyxcbiAgbm9Td2lwaW5nOiB0cnVlLFxuICBub1N3aXBpbmdDbGFzczogJ3N3aXBlci1uby1zd2lwaW5nJyxcbiAgbm9Td2lwaW5nU2VsZWN0b3I6IG51bGwsXG4gIC8vIFBhc3NpdmUgTGlzdGVuZXJzXG4gIHBhc3NpdmVMaXN0ZW5lcnM6IHRydWUsXG4gIG1heEJhY2tmYWNlSGlkZGVuU2xpZGVzOiAxMCxcbiAgLy8gTlNcbiAgY29udGFpbmVyTW9kaWZpZXJDbGFzczogJ3N3aXBlci0nLFxuICAvLyBORVdcbiAgc2xpZGVDbGFzczogJ3N3aXBlci1zbGlkZScsXG4gIHNsaWRlQmxhbmtDbGFzczogJ3N3aXBlci1zbGlkZS1ibGFuaycsXG4gIHNsaWRlQWN0aXZlQ2xhc3M6ICdzd2lwZXItc2xpZGUtYWN0aXZlJyxcbiAgc2xpZGVWaXNpYmxlQ2xhc3M6ICdzd2lwZXItc2xpZGUtdmlzaWJsZScsXG4gIHNsaWRlRnVsbHlWaXNpYmxlQ2xhc3M6ICdzd2lwZXItc2xpZGUtZnVsbHktdmlzaWJsZScsXG4gIHNsaWRlTmV4dENsYXNzOiAnc3dpcGVyLXNsaWRlLW5leHQnLFxuICBzbGlkZVByZXZDbGFzczogJ3N3aXBlci1zbGlkZS1wcmV2JyxcbiAgd3JhcHBlckNsYXNzOiAnc3dpcGVyLXdyYXBwZXInLFxuICBsYXp5UHJlbG9hZGVyQ2xhc3M6ICdzd2lwZXItbGF6eS1wcmVsb2FkZXInLFxuICBsYXp5UHJlbG9hZFByZXZOZXh0OiAwLFxuICAvLyBDYWxsYmFja3NcbiAgcnVuQ2FsbGJhY2tzT25Jbml0OiB0cnVlLFxuICAvLyBJbnRlcm5hbHNcbiAgX2VtaXRDbGFzc2VzOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gbW9kdWxlRXh0ZW5kUGFyYW1zKHBhcmFtcywgYWxsTW9kdWxlc1BhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gZXh0ZW5kUGFyYW1zKG9iaikge1xuICAgIGlmIChvYmogPT09IHZvaWQgMCkge1xuICAgICAgb2JqID0ge307XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZVBhcmFtTmFtZSA9IE9iamVjdC5rZXlzKG9iailbMF07XG4gICAgY29uc3QgbW9kdWxlUGFyYW1zID0gb2JqW21vZHVsZVBhcmFtTmFtZV07XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVQYXJhbXMgIT09ICdvYmplY3QnIHx8IG1vZHVsZVBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgZXh0ZW5kKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtb2R1bGVQYXJhbU5hbWUgPT09ICduYXZpZ2F0aW9uJyAmJiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSAmJiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkICYmICFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5wcmV2RWwgJiYgIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLm5leHRFbCkge1xuICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uYXV0byA9IHRydWU7XG4gICAgfVxuICAgIGlmIChbJ3BhZ2luYXRpb24nLCAnc2Nyb2xsYmFyJ10uaW5kZXhPZihtb2R1bGVQYXJhbU5hbWUpID49IDAgJiYgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gJiYgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uZW5hYmxlZCAmJiAhcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uZWwpIHtcbiAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmF1dG8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIShtb2R1bGVQYXJhbU5hbWUgaW4gcGFyYW1zICYmICdlbmFibGVkJyBpbiBtb2R1bGVQYXJhbXMpKSB7XG4gICAgICBleHRlbmQoYWxsTW9kdWxlc1BhcmFtcywgb2JqKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gJ29iamVjdCcgJiYgISgnZW5hYmxlZCcgaW4gcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0pKSB7XG4gICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSkgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH07XG4gICAgZXh0ZW5kKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gIH07XG59XG5cbi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXCJvZmZcIiAqL1xuY29uc3QgcHJvdG90eXBlcyA9IHtcbiAgZXZlbnRzRW1pdHRlcixcbiAgdXBkYXRlLFxuICB0cmFuc2xhdGUsXG4gIHRyYW5zaXRpb24sXG4gIHNsaWRlLFxuICBsb29wLFxuICBncmFiQ3Vyc29yLFxuICBldmVudHM6IGV2ZW50cyQxLFxuICBicmVha3BvaW50cyxcbiAgY2hlY2tPdmVyZmxvdzogY2hlY2tPdmVyZmxvdyQxLFxuICBjbGFzc2VzXG59O1xuY29uc3QgZXh0ZW5kZWREZWZhdWx0cyA9IHt9O1xuY2xhc3MgU3dpcGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IGVsO1xuICAgIGxldCBwYXJhbXM7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXS5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnc1swXSkuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0Jykge1xuICAgICAgcGFyYW1zID0gYXJnc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgW2VsLCBwYXJhbXNdID0gYXJncztcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgcGFyYW1zKTtcbiAgICBpZiAoZWwgJiYgIXBhcmFtcy5lbCkgcGFyYW1zLmVsID0gZWw7XG4gICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgIGlmIChwYXJhbXMuZWwgJiYgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwYXJhbXMuZWwpLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHN3aXBlcnMgPSBbXTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGFyYW1zLmVsKS5mb3JFYWNoKGNvbnRhaW5lckVsID0+IHtcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gZXh0ZW5kKHt9LCBwYXJhbXMsIHtcbiAgICAgICAgICBlbDogY29udGFpbmVyRWxcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlcnMucHVzaChuZXcgU3dpcGVyKG5ld1BhcmFtcykpO1xuICAgICAgfSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgICByZXR1cm4gc3dpcGVycztcbiAgICB9XG5cbiAgICAvLyBTd2lwZXIgSW5zdGFuY2VcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIHN3aXBlci5fX3N3aXBlcl9fID0gdHJ1ZTtcbiAgICBzd2lwZXIuc3VwcG9ydCA9IGdldFN1cHBvcnQoKTtcbiAgICBzd2lwZXIuZGV2aWNlID0gZ2V0RGV2aWNlKHtcbiAgICAgIHVzZXJBZ2VudDogcGFyYW1zLnVzZXJBZ2VudFxuICAgIH0pO1xuICAgIHN3aXBlci5icm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgIHN3aXBlci5ldmVudHNMaXN0ZW5lcnMgPSB7fTtcbiAgICBzd2lwZXIuZXZlbnRzQW55TGlzdGVuZXJzID0gW107XG4gICAgc3dpcGVyLm1vZHVsZXMgPSBbLi4uc3dpcGVyLl9fbW9kdWxlc19fXTtcbiAgICBpZiAocGFyYW1zLm1vZHVsZXMgJiYgQXJyYXkuaXNBcnJheShwYXJhbXMubW9kdWxlcykpIHtcbiAgICAgIHN3aXBlci5tb2R1bGVzLnB1c2goLi4ucGFyYW1zLm1vZHVsZXMpO1xuICAgIH1cbiAgICBjb25zdCBhbGxNb2R1bGVzUGFyYW1zID0ge307XG4gICAgc3dpcGVyLm1vZHVsZXMuZm9yRWFjaChtb2QgPT4ge1xuICAgICAgbW9kKHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBzd2lwZXIsXG4gICAgICAgIGV4dGVuZFBhcmFtczogbW9kdWxlRXh0ZW5kUGFyYW1zKHBhcmFtcywgYWxsTW9kdWxlc1BhcmFtcyksXG4gICAgICAgIG9uOiBzd2lwZXIub24uYmluZChzd2lwZXIpLFxuICAgICAgICBvbmNlOiBzd2lwZXIub25jZS5iaW5kKHN3aXBlciksXG4gICAgICAgIG9mZjogc3dpcGVyLm9mZi5iaW5kKHN3aXBlciksXG4gICAgICAgIGVtaXQ6IHN3aXBlci5lbWl0LmJpbmQoc3dpcGVyKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIGNvbnN0IHN3aXBlclBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIGFsbE1vZHVsZXNQYXJhbXMpO1xuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggcGFzc2VkIHBhcmFtc1xuICAgIHN3aXBlci5wYXJhbXMgPSBleHRlbmQoe30sIHN3aXBlclBhcmFtcywgZXh0ZW5kZWREZWZhdWx0cywgcGFyYW1zKTtcbiAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMgPSBleHRlbmQoe30sIHN3aXBlci5wYXJhbXMpO1xuICAgIHN3aXBlci5wYXNzZWRQYXJhbXMgPSBleHRlbmQoe30sIHBhcmFtcyk7XG5cbiAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKHN3aXBlci5wYXJhbXMgJiYgc3dpcGVyLnBhcmFtcy5vbikge1xuICAgICAgT2JqZWN0LmtleXMoc3dpcGVyLnBhcmFtcy5vbikuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgICBzd2lwZXIub24oZXZlbnROYW1lLCBzd2lwZXIucGFyYW1zLm9uW2V2ZW50TmFtZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zICYmIHN3aXBlci5wYXJhbXMub25BbnkpIHtcbiAgICAgIHN3aXBlci5vbkFueShzd2lwZXIucGFyYW1zLm9uQW55KTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgU3dpcGVyXG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgIGVuYWJsZWQ6IHN3aXBlci5wYXJhbXMuZW5hYmxlZCxcbiAgICAgIGVsLFxuICAgICAgLy8gQ2xhc3Nlc1xuICAgICAgY2xhc3NOYW1lczogW10sXG4gICAgICAvLyBTbGlkZXNcbiAgICAgIHNsaWRlczogW10sXG4gICAgICBzbGlkZXNHcmlkOiBbXSxcbiAgICAgIHNuYXBHcmlkOiBbXSxcbiAgICAgIHNsaWRlc1NpemVzR3JpZDogW10sXG4gICAgICAvLyBpc0RpcmVjdGlvblxuICAgICAgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgIH0sXG4gICAgICBpc1ZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgICB9LFxuICAgICAgLy8gSW5kZXhlc1xuICAgICAgYWN0aXZlSW5kZXg6IDAsXG4gICAgICByZWFsSW5kZXg6IDAsXG4gICAgICAvL1xuICAgICAgaXNCZWdpbm5pbmc6IHRydWUsXG4gICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAvLyBQcm9wc1xuICAgICAgdHJhbnNsYXRlOiAwLFxuICAgICAgcHJldmlvdXNUcmFuc2xhdGU6IDAsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHZlbG9jaXR5OiAwLFxuICAgICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgIGNzc092ZXJmbG93QWRqdXN0bWVudCgpIHtcbiAgICAgICAgLy8gUmV0dXJucyAwIHVubGVzcyBgdHJhbnNsYXRlYCBpcyA+IDIqKjIzXG4gICAgICAgIC8vIFNob3VsZCBiZSBzdWJ0cmFjdGVkIGZyb20gY3NzIHZhbHVlcyB0byBwcmV2ZW50IG92ZXJmbG93XG4gICAgICAgIHJldHVybiBNYXRoLnRydW5jKHRoaXMudHJhbnNsYXRlIC8gMiAqKiAyMykgKiAyICoqIDIzO1xuICAgICAgfSxcbiAgICAgIC8vIExvY2tzXG4gICAgICBhbGxvd1NsaWRlTmV4dDogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxcbiAgICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2LFxuICAgICAgLy8gVG91Y2ggRXZlbnRzXG4gICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcbiAgICAgICAgaXNUb3VjaGVkOiB1bmRlZmluZWQsXG4gICAgICAgIGlzTW92ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdW5kZWZpbmVkLFxuICAgICAgICB0b3VjaFN0YXJ0VGltZTogdW5kZWZpbmVkLFxuICAgICAgICBpc1Njcm9sbGluZzogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIGFsbG93VGhyZXNob2xkTW92ZTogdW5kZWZpbmVkLFxuICAgICAgICAvLyBGb3JtIGVsZW1lbnRzIHRvIG1hdGNoXG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRzOiBzd2lwZXIucGFyYW1zLmZvY3VzYWJsZUVsZW1lbnRzLFxuICAgICAgICAvLyBMYXN0IGNsaWNrIHRpbWVcbiAgICAgICAgbGFzdENsaWNrVGltZTogMCxcbiAgICAgICAgY2xpY2tUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgIC8vIFZlbG9jaXRpZXNcbiAgICAgICAgdmVsb2NpdGllczogW10sXG4gICAgICAgIGFsbG93TW9tZW50dW1Cb3VuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9pbnRlcklkOiBudWxsLFxuICAgICAgICB0b3VjaElkOiBudWxsXG4gICAgICB9LFxuICAgICAgLy8gQ2xpY2tzXG4gICAgICBhbGxvd0NsaWNrOiB0cnVlLFxuICAgICAgLy8gVG91Y2hlc1xuICAgICAgYWxsb3dUb3VjaE1vdmU6IHN3aXBlci5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsXG4gICAgICB0b3VjaGVzOiB7XG4gICAgICAgIHN0YXJ0WDogMCxcbiAgICAgICAgc3RhcnRZOiAwLFxuICAgICAgICBjdXJyZW50WDogMCxcbiAgICAgICAgY3VycmVudFk6IDAsXG4gICAgICAgIGRpZmY6IDBcbiAgICAgIH0sXG4gICAgICAvLyBJbWFnZXNcbiAgICAgIGltYWdlc1RvTG9hZDogW10sXG4gICAgICBpbWFnZXNMb2FkZWQ6IDBcbiAgICB9KTtcbiAgICBzd2lwZXIuZW1pdCgnX3N3aXBlcicpO1xuXG4gICAgLy8gSW5pdFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmluaXQpIHtcbiAgICAgIHN3aXBlci5pbml0KCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFwcCBpbnN0YW5jZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICByZXR1cm4gc3dpcGVyO1xuICB9XG4gIGdldERpcmVjdGlvbkxhYmVsKHByb3BlcnR5KSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgcmV0dXJuIHtcbiAgICAgICd3aWR0aCc6ICdoZWlnaHQnLFxuICAgICAgJ21hcmdpbi10b3AnOiAnbWFyZ2luLWxlZnQnLFxuICAgICAgJ21hcmdpbi1ib3R0b20gJzogJ21hcmdpbi1yaWdodCcsXG4gICAgICAnbWFyZ2luLWxlZnQnOiAnbWFyZ2luLXRvcCcsXG4gICAgICAnbWFyZ2luLXJpZ2h0JzogJ21hcmdpbi1ib3R0b20nLFxuICAgICAgJ3BhZGRpbmctbGVmdCc6ICdwYWRkaW5nLXRvcCcsXG4gICAgICAncGFkZGluZy1yaWdodCc6ICdwYWRkaW5nLWJvdHRvbScsXG4gICAgICAnbWFyZ2luUmlnaHQnOiAnbWFyZ2luQm90dG9tJ1xuICAgIH1bcHJvcGVydHldO1xuICB9XG4gIGdldFNsaWRlSW5kZXgoc2xpZGVFbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlc0VsLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2xpZGVzID0gZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgICBjb25zdCBmaXJzdFNsaWRlSW5kZXggPSBlbGVtZW50SW5kZXgoc2xpZGVzWzBdKTtcbiAgICByZXR1cm4gZWxlbWVudEluZGV4KHNsaWRlRWwpIC0gZmlyc3RTbGlkZUluZGV4O1xuICB9XG4gIGdldFNsaWRlSW5kZXhCeURhdGEoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTbGlkZUluZGV4KHRoaXMuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICogMSA9PT0gaW5kZXgpWzBdKTtcbiAgfVxuICByZWNhbGNTbGlkZXMoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXNFbCxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSBzd2lwZXI7XG4gICAgc3dpcGVyLnNsaWRlcyA9IGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHN3aXBlci5lbmFibGVkKSByZXR1cm47XG4gICAgc3dpcGVyLmVuYWJsZWQgPSB0cnVlO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmdyYWJDdXJzb3IpIHtcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdlbmFibGUnKTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHN3aXBlci5lbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgc3dpcGVyLnVuc2V0R3JhYkN1cnNvcigpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnZGlzYWJsZScpO1xuICB9XG4gIHNldFByb2dyZXNzKHByb2dyZXNzLCBzcGVlZCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgcHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChwcm9ncmVzcywgMCksIDEpO1xuICAgIGNvbnN0IG1pbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgICBjb25zdCBtYXggPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgY29uc3QgY3VycmVudCA9IChtYXggLSBtaW4pICogcHJvZ3Jlc3MgKyBtaW47XG4gICAgc3dpcGVyLnRyYW5zbGF0ZVRvKGN1cnJlbnQsIHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogc3BlZWQpO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIH1cbiAgZW1pdENvbnRhaW5lckNsYXNzZXMoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFzd2lwZXIuZWwpIHJldHVybjtcbiAgICBjb25zdCBjbHMgPSBzd2lwZXIuZWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlcicpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcykgPT09IDA7XG4gICAgfSk7XG4gICAgc3dpcGVyLmVtaXQoJ19jb250YWluZXJDbGFzc2VzJywgY2xzLmpvaW4oJyAnKSk7XG4gIH1cbiAgZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWwpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIuZGVzdHJveWVkKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIHNsaWRlRWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlci1zbGlkZScpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuc2xpZGVDbGFzcykgPT09IDA7XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIGVtaXRTbGlkZXNDbGFzc2VzKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhc3dpcGVyLmVsKSByZXR1cm47XG4gICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBzd2lwZXIuZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWwpO1xuICAgICAgdXBkYXRlcy5wdXNoKHtcbiAgICAgICAgc2xpZGVFbCxcbiAgICAgICAgY2xhc3NOYW1lc1xuICAgICAgfSk7XG4gICAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3MnLCBzbGlkZUVsLCBjbGFzc05hbWVzKTtcbiAgICB9KTtcbiAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3NlcycsIHVwZGF0ZXMpO1xuICB9XG4gIHNsaWRlc1BlclZpZXdEeW5hbWljKHZpZXcsIGV4YWN0KSB7XG4gICAgaWYgKHZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgdmlldyA9ICdjdXJyZW50JztcbiAgICB9XG4gICAgaWYgKGV4YWN0ID09PSB2b2lkIDApIHtcbiAgICAgIGV4YWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFyYW1zLFxuICAgICAgc2xpZGVzLFxuICAgICAgc2xpZGVzR3JpZCxcbiAgICAgIHNsaWRlc1NpemVzR3JpZCxcbiAgICAgIHNpemU6IHN3aXBlclNpemUsXG4gICAgICBhY3RpdmVJbmRleFxuICAgIH0gPSBzd2lwZXI7XG4gICAgbGV0IHNwdiA9IDE7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ251bWJlcicpIHJldHVybiBwYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBsZXQgc2xpZGVTaXplID0gc2xpZGVzW2FjdGl2ZUluZGV4XSA/IE1hdGguY2VpbChzbGlkZXNbYWN0aXZlSW5kZXhdLnN3aXBlclNsaWRlU2l6ZSkgOiAwO1xuICAgICAgbGV0IGJyZWFrTG9vcDtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCArIDE7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XG4gICAgICAgICAgc2xpZGVTaXplICs9IE1hdGguY2VpbChzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplKTtcbiAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICBpZiAoc2xpZGVTaXplID4gc3dpcGVyU2l6ZSkgYnJlYWtMb29wID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XG4gICAgICAgICAgc2xpZGVTaXplICs9IHNsaWRlc1tpXS5zd2lwZXJTbGlkZVNpemU7XG4gICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpZiAodmlldyA9PT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCArIDE7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBzbGlkZUluVmlldyA9IGV4YWN0ID8gc2xpZGVzR3JpZFtpXSArIHNsaWRlc1NpemVzR3JpZFtpXSAtIHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIDwgc3dpcGVyU2l6ZSA6IHNsaWRlc0dyaWRbaV0gLSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSA8IHN3aXBlclNpemU7XG4gICAgICAgICAgaWYgKHNsaWRlSW5WaWV3KSB7XG4gICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHByZXZpb3VzXG4gICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVJblZpZXcgPSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSAtIHNsaWRlc0dyaWRbaV0gPCBzd2lwZXJTaXplO1xuICAgICAgICAgIGlmIChzbGlkZUluVmlldykge1xuICAgICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcHY7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHNuYXBHcmlkLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHN3aXBlcjtcbiAgICAvLyBCcmVha3BvaW50c1xuICAgIGlmIChwYXJhbXMuYnJlYWtwb2ludHMpIHtcbiAgICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gICAgfVxuICAgIFsuLi5zd2lwZXIuZWwucXVlcnlTZWxlY3RvckFsbCgnW2xvYWRpbmc9XCJsYXp5XCJdJyldLmZvckVhY2goaW1hZ2VFbCA9PiB7XG4gICAgICBpZiAoaW1hZ2VFbC5jb21wbGV0ZSkge1xuICAgICAgICBwcm9jZXNzTGF6eVByZWxvYWRlcihzd2lwZXIsIGltYWdlRWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlKCkge1xuICAgICAgY29uc3QgdHJhbnNsYXRlVmFsdWUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSAqIC0xIDogc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgIGNvbnN0IG5ld1RyYW5zbGF0ZSA9IE1hdGgubWluKE1hdGgubWF4KHRyYW5zbGF0ZVZhbHVlLCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpLCBzd2lwZXIubWluVHJhbnNsYXRlKCkpO1xuICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIH1cbiAgICBsZXQgdHJhbnNsYXRlZDtcbiAgICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmICFwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nIHx8IHBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgc3dpcGVyLmlzRW5kICYmICFwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgY29uc3Qgc2xpZGVzID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcyA6IHN3aXBlci5zbGlkZXM7XG4gICAgICAgIHRyYW5zbGF0ZWQgPSBzd2lwZXIuc2xpZGVUbyhzbGlkZXMubGVuZ3RoIC0gMSwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNsYXRlZCA9IHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc2xhdGVkKSB7XG4gICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc25hcEdyaWQgIT09IHN3aXBlci5zbmFwR3JpZCkge1xuICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXQoJ3VwZGF0ZScpO1xuICB9XG4gIGNoYW5nZURpcmVjdGlvbihuZXdEaXJlY3Rpb24sIG5lZWRVcGRhdGUpIHtcbiAgICBpZiAobmVlZFVwZGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50RGlyZWN0aW9uID0gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb247XG4gICAgaWYgKCFuZXdEaXJlY3Rpb24pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgbmV3RGlyZWN0aW9uID0gY3VycmVudERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICB9XG4gICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gY3VycmVudERpcmVjdGlvbiB8fCBuZXdEaXJlY3Rpb24gIT09ICdob3Jpem9udGFsJyAmJiBuZXdEaXJlY3Rpb24gIT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiBzd2lwZXI7XG4gICAgfVxuICAgIHN3aXBlci5lbC5jbGFzc0xpc3QucmVtb3ZlKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke2N1cnJlbnREaXJlY3Rpb259YCk7XG4gICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5hZGQoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7bmV3RGlyZWN0aW9ufWApO1xuICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgIHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID0gbmV3RGlyZWN0aW9uO1xuICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgIGlmIChuZXdEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgc2xpZGVFbC5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGVFbC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzd2lwZXIuZW1pdCgnY2hhbmdlRGlyZWN0aW9uJyk7XG4gICAgaWYgKG5lZWRVcGRhdGUpIHN3aXBlci51cGRhdGUoKTtcbiAgICByZXR1cm4gc3dpcGVyO1xuICB9XG4gIGNoYW5nZUxhbmd1YWdlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHN3aXBlci5ydGwgJiYgZGlyZWN0aW9uID09PSAncnRsJyB8fCAhc3dpcGVyLnJ0bCAmJiBkaXJlY3Rpb24gPT09ICdsdHInKSByZXR1cm47XG4gICAgc3dpcGVyLnJ0bCA9IGRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgc3dpcGVyLnJ0bFRyYW5zbGF0ZSA9IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgc3dpcGVyLnJ0bDtcbiAgICBpZiAoc3dpcGVyLnJ0bCkge1xuICAgICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5hZGQoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXJ0bGApO1xuICAgICAgc3dpcGVyLmVsLmRpciA9ICdydGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LnJlbW92ZShgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9cnRsYCk7XG4gICAgICBzd2lwZXIuZWwuZGlyID0gJ2x0cic7XG4gICAgfVxuICAgIHN3aXBlci51cGRhdGUoKTtcbiAgfVxuICBtb3VudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLm1vdW50ZWQpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gRmluZCBlbFxuICAgIGxldCBlbCA9IGVsZW1lbnQgfHwgc3dpcGVyLnBhcmFtcy5lbDtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICB9XG4gICAgaWYgKCFlbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbC5zd2lwZXIgPSBzd2lwZXI7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5ob3N0ICYmIGVsLnBhcmVudE5vZGUuaG9zdC5ub2RlTmFtZSA9PT0gc3dpcGVyLnBhcmFtcy5zd2lwZXJFbGVtZW50Tm9kZU5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgc3dpcGVyLmlzRWxlbWVudCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGdldFdyYXBwZXJTZWxlY3RvciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBgLiR7KHN3aXBlci5wYXJhbXMud3JhcHBlckNsYXNzIHx8ICcnKS50cmltKCkuc3BsaXQoJyAnKS5qb2luKCcuJyl9YDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFdyYXBwZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoZWwgJiYgZWwuc2hhZG93Um9vdCAmJiBlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzID0gZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGdldFdyYXBwZXJTZWxlY3RvcigpKTtcbiAgICAgICAgLy8gQ2hpbGRyZW4gbmVlZHMgdG8gcmV0dXJuIHNsb3QgaXRlbXNcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50Q2hpbGRyZW4oZWwsIGdldFdyYXBwZXJTZWxlY3RvcigpKVswXTtcbiAgICB9O1xuICAgIC8vIEZpbmQgV3JhcHBlclxuICAgIGxldCB3cmFwcGVyRWwgPSBnZXRXcmFwcGVyKCk7XG4gICAgaWYgKCF3cmFwcGVyRWwgJiYgc3dpcGVyLnBhcmFtcy5jcmVhdGVFbGVtZW50cykge1xuICAgICAgd3JhcHBlckVsID0gY3JlYXRlRWxlbWVudCgnZGl2Jywgc3dpcGVyLnBhcmFtcy53cmFwcGVyQ2xhc3MpO1xuICAgICAgZWwuYXBwZW5kKHdyYXBwZXJFbCk7XG4gICAgICBlbGVtZW50Q2hpbGRyZW4oZWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YCkuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgd3JhcHBlckVsLmFwcGVuZChzbGlkZUVsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgZWwsXG4gICAgICB3cmFwcGVyRWwsXG4gICAgICBzbGlkZXNFbDogc3dpcGVyLmlzRWxlbWVudCAmJiAhZWwucGFyZW50Tm9kZS5ob3N0LnNsaWRlU2xvdHMgPyBlbC5wYXJlbnROb2RlLmhvc3QgOiB3cmFwcGVyRWwsXG4gICAgICBob3N0RWw6IHN3aXBlci5pc0VsZW1lbnQgPyBlbC5wYXJlbnROb2RlLmhvc3QgOiBlbCxcbiAgICAgIG1vdW50ZWQ6IHRydWUsXG4gICAgICAvLyBSVExcbiAgICAgIHJ0bDogZWwuZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnIHx8IGVsZW1lbnRTdHlsZShlbCwgJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgIHJ0bFRyYW5zbGF0ZTogc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAoZWwuZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnIHx8IGVsZW1lbnRTdHlsZShlbCwgJ2RpcmVjdGlvbicpID09PSAncnRsJyksXG4gICAgICB3cm9uZ1JUTDogZWxlbWVudFN0eWxlKHdyYXBwZXJFbCwgJ2Rpc3BsYXknKSA9PT0gJy13ZWJraXQtYm94J1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGluaXQoZWwpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybiBzd2lwZXI7XG4gICAgY29uc3QgbW91bnRlZCA9IHN3aXBlci5tb3VudChlbCk7XG4gICAgaWYgKG1vdW50ZWQgPT09IGZhbHNlKSByZXR1cm4gc3dpcGVyO1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVJbml0Jyk7XG5cbiAgICAvLyBTZXQgYnJlYWtwb2ludFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICAgIH1cblxuICAgIC8vIEFkZCBDbGFzc2VzXG4gICAgc3dpcGVyLmFkZENsYXNzZXMoKTtcblxuICAgIC8vIFVwZGF0ZSBzaXplXG4gICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcblxuICAgIC8vIFVwZGF0ZSBzbGlkZXNcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykge1xuICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgR3JhYiBDdXJzb3JcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yICYmIHN3aXBlci5lbmFibGVkKSB7XG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcigpO1xuICAgIH1cblxuICAgIC8vIFNsaWRlIFRvIEluaXRpYWwgU2xpZGVcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wICYmIHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIucGFyYW1zLmluaXRpYWxTbGlkZSArIHN3aXBlci52aXJ0dWFsLnNsaWRlc0JlZm9yZSwgMCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUsIDAsIHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGxvb3BcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCBldmVudHNcbiAgICBzd2lwZXIuYXR0YWNoRXZlbnRzKCk7XG4gICAgY29uc3QgbGF6eUVsZW1lbnRzID0gWy4uLnN3aXBlci5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbbG9hZGluZz1cImxhenlcIl0nKV07XG4gICAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIGxhenlFbGVtZW50cy5wdXNoKC4uLnN3aXBlci5ob3N0RWwucXVlcnlTZWxlY3RvckFsbCgnW2xvYWRpbmc9XCJsYXp5XCJdJykpO1xuICAgIH1cbiAgICBsYXp5RWxlbWVudHMuZm9yRWFjaChpbWFnZUVsID0+IHtcbiAgICAgIGlmIChpbWFnZUVsLmNvbXBsZXRlKSB7XG4gICAgICAgIHByb2Nlc3NMYXp5UHJlbG9hZGVyKHN3aXBlciwgaW1hZ2VFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBlID0+IHtcbiAgICAgICAgICBwcm9jZXNzTGF6eVByZWxvYWRlcihzd2lwZXIsIGUudGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJlbG9hZChzd2lwZXIpO1xuXG4gICAgLy8gSW5pdCBGbGFnXG4gICAgc3dpcGVyLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBwcmVsb2FkKHN3aXBlcik7XG5cbiAgICAvLyBFbWl0XG4gICAgc3dpcGVyLmVtaXQoJ2luaXQnKTtcbiAgICBzd2lwZXIuZW1pdCgnYWZ0ZXJJbml0Jyk7XG4gICAgcmV0dXJuIHN3aXBlcjtcbiAgfVxuICBkZXN0cm95KGRlbGV0ZUluc3RhbmNlLCBjbGVhblN0eWxlcykge1xuICAgIGlmIChkZWxldGVJbnN0YW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGVJbnN0YW5jZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjbGVhblN0eWxlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGVhblN0eWxlcyA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFyYW1zLFxuICAgICAgZWwsXG4gICAgICB3cmFwcGVyRWwsXG4gICAgICBzbGlkZXNcbiAgICB9ID0gc3dpcGVyO1xuICAgIGlmICh0eXBlb2Ygc3dpcGVyLnBhcmFtcyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3dpcGVyLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVEZXN0cm95Jyk7XG5cbiAgICAvLyBJbml0IEZsYWdcbiAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIC8vIERldGFjaCBldmVudHNcbiAgICBzd2lwZXIuZGV0YWNoRXZlbnRzKCk7XG5cbiAgICAvLyBEZXN0cm95IGxvb3BcbiAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8vIENsZWFudXAgc3R5bGVzXG4gICAgaWYgKGNsZWFuU3R5bGVzKSB7XG4gICAgICBzd2lwZXIucmVtb3ZlQ2xhc3NlcygpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgd3JhcHBlckVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIGlmIChzbGlkZXMgJiYgc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICBzbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgICBzbGlkZUVsLmNsYXNzTGlzdC5yZW1vdmUocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzLCBwYXJhbXMuc2xpZGVGdWxseVZpc2libGVDbGFzcywgcGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MsIHBhcmFtcy5zbGlkZU5leHRDbGFzcywgcGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcbiAgICAgICAgICBzbGlkZUVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICBzbGlkZUVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdkZXN0cm95Jyk7XG5cbiAgICAvLyBEZXRhY2ggZW1pdHRlciBldmVudHNcbiAgICBPYmplY3Qua2V5cyhzd2lwZXIuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBzd2lwZXIub2ZmKGV2ZW50TmFtZSk7XG4gICAgfSk7XG4gICAgaWYgKGRlbGV0ZUluc3RhbmNlICE9PSBmYWxzZSkge1xuICAgICAgc3dpcGVyLmVsLnN3aXBlciA9IG51bGw7XG4gICAgICBkZWxldGVQcm9wcyhzd2lwZXIpO1xuICAgIH1cbiAgICBzd2lwZXIuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICBleHRlbmQoZXh0ZW5kZWREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICB9XG4gIHN0YXRpYyBnZXQgZXh0ZW5kZWREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gZXh0ZW5kZWREZWZhdWx0cztcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuICBzdGF0aWMgaW5zdGFsbE1vZHVsZShtb2QpIHtcbiAgICBpZiAoIVN3aXBlci5wcm90b3R5cGUuX19tb2R1bGVzX18pIFN3aXBlci5wcm90b3R5cGUuX19tb2R1bGVzX18gPSBbXTtcbiAgICBjb25zdCBtb2R1bGVzID0gU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXztcbiAgICBpZiAodHlwZW9mIG1vZCA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGVzLmluZGV4T2YobW9kKSA8IDApIHtcbiAgICAgIG1vZHVsZXMucHVzaChtb2QpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdXNlKG1vZHVsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1vZHVsZSkpIHtcbiAgICAgIG1vZHVsZS5mb3JFYWNoKG0gPT4gU3dpcGVyLmluc3RhbGxNb2R1bGUobSkpO1xuICAgICAgcmV0dXJuIFN3aXBlcjtcbiAgICB9XG4gICAgU3dpcGVyLmluc3RhbGxNb2R1bGUobW9kdWxlKTtcbiAgICByZXR1cm4gU3dpcGVyO1xuICB9XG59XG5PYmplY3Qua2V5cyhwcm90b3R5cGVzKS5mb3JFYWNoKHByb3RvdHlwZUdyb3VwID0+IHtcbiAgT2JqZWN0LmtleXMocHJvdG90eXBlc1twcm90b3R5cGVHcm91cF0pLmZvckVhY2gocHJvdG9NZXRob2QgPT4ge1xuICAgIFN3aXBlci5wcm90b3R5cGVbcHJvdG9NZXRob2RdID0gcHJvdG90eXBlc1twcm90b3R5cGVHcm91cF1bcHJvdG9NZXRob2RdO1xuICB9KTtcbn0pO1xuU3dpcGVyLnVzZShbUmVzaXplLCBPYnNlcnZlcl0pO1xuXG5leHBvcnQgeyBTd2lwZXIgYXMgUywgZGVmYXVsdHMgYXMgZCB9O1xuIl0sIm5hbWVzIjpbImEiLCJnZXRXaW5kb3ciLCJnIiwiZ2V0RG9jdW1lbnQiLCJlbGVtZW50UGFyZW50cyIsIm8iLCJlbGVtZW50U3R5bGUiLCJlIiwiZWxlbWVudENoaWxkcmVuIiwicyIsInNldENTU1Byb3BlcnR5IiwiZiIsImVsZW1lbnRPdXRlclNpemUiLCJwIiwiZWxlbWVudE5leHRBbGwiLCJxIiwiZWxlbWVudFByZXZBbGwiLCJqIiwiZ2V0VHJhbnNsYXRlIiwiciIsImFuaW1hdGVDU1NNb2RlU2Nyb2xsIiwibiIsIm5leHRUaWNrIiwidCIsInNob3dXYXJuaW5nIiwiYyIsImNyZWF0ZUVsZW1lbnQiLCJkIiwibm93IiwidSIsImV4dGVuZCIsImgiLCJlbGVtZW50SW5kZXgiLCJ2IiwiZGVsZXRlUHJvcHMiLCJzdXBwb3J0IiwiY2FsY1N1cHBvcnQiLCJ3aW5kb3ciLCJkb2N1bWVudCIsInNtb290aFNjcm9sbCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwidG91Y2giLCJEb2N1bWVudFRvdWNoIiwiZ2V0U3VwcG9ydCIsImRldmljZUNhY2hlZCIsImNhbGNEZXZpY2UiLCJfdGVtcCIsInVzZXJBZ2VudCIsInBsYXRmb3JtIiwibmF2aWdhdG9yIiwidWEiLCJkZXZpY2UiLCJpb3MiLCJhbmRyb2lkIiwic2NyZWVuV2lkdGgiLCJzY3JlZW4iLCJ3aWR0aCIsInNjcmVlbkhlaWdodCIsImhlaWdodCIsIm1hdGNoIiwiaXBhZCIsImlwb2QiLCJpcGhvbmUiLCJ3aW5kb3dzIiwibWFjb3MiLCJpUGFkU2NyZWVucyIsImluZGV4T2YiLCJvcyIsImdldERldmljZSIsIm92ZXJyaWRlcyIsImJyb3dzZXIiLCJjYWxjQnJvd3NlciIsIm5lZWRQZXJzcGVjdGl2ZUZpeCIsImlzU2FmYXJpIiwidG9Mb3dlckNhc2UiLCJTdHJpbmciLCJpbmNsdWRlcyIsIm1ham9yIiwibWlub3IiLCJzcGxpdCIsIm1hcCIsIm51bSIsIk51bWJlciIsImlzV2ViVmlldyIsInRlc3QiLCJpc1NhZmFyaUJyb3dzZXIiLCJuZWVkM2RGaXgiLCJnZXRCcm93c2VyIiwiUmVzaXplIiwiX3JlZiIsInN3aXBlciIsIm9uIiwiZW1pdCIsIm9ic2VydmVyIiwiYW5pbWF0aW9uRnJhbWUiLCJyZXNpemVIYW5kbGVyIiwiZGVzdHJveWVkIiwiaW5pdGlhbGl6ZWQiLCJjcmVhdGVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiZW50cmllcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiZm9yRWFjaCIsIl9yZWYyIiwiY29udGVudEJveFNpemUiLCJjb250ZW50UmVjdCIsInRhcmdldCIsImVsIiwiaW5saW5lU2l6ZSIsImJsb2NrU2l6ZSIsIm9ic2VydmUiLCJyZW1vdmVPYnNlcnZlciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidW5vYnNlcnZlIiwib3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyIiwicGFyYW1zIiwicmVzaXplT2JzZXJ2ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIk9ic2VydmVyIiwiZXh0ZW5kUGFyYW1zIiwib2JzZXJ2ZXJzIiwiYXR0YWNoIiwib3B0aW9ucyIsIk9ic2VydmVyRnVuYyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJraXRNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwiX19wcmV2ZW50T2JzZXJ2ZXJfXyIsImxlbmd0aCIsIm9ic2VydmVyVXBkYXRlIiwic2V0VGltZW91dCIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwicHVzaCIsImluaXQiLCJvYnNlcnZlUGFyZW50cyIsImNvbnRhaW5lclBhcmVudHMiLCJob3N0RWwiLCJpIiwib2JzZXJ2ZVNsaWRlQ2hpbGRyZW4iLCJ3cmFwcGVyRWwiLCJkZXN0cm95IiwiZGlzY29ubmVjdCIsInNwbGljZSIsImV2ZW50c0VtaXR0ZXIiLCJldmVudHMiLCJoYW5kbGVyIiwicHJpb3JpdHkiLCJzZWxmIiwiZXZlbnRzTGlzdGVuZXJzIiwibWV0aG9kIiwiZXZlbnQiLCJvbmNlIiwib25jZUhhbmRsZXIiLCJvZmYiLCJfX2VtaXR0ZXJQcm94eSIsIl9sZW4iLCJhcmd1bWVudHMiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiYXBwbHkiLCJvbkFueSIsImV2ZW50c0FueUxpc3RlbmVycyIsIm9mZkFueSIsImluZGV4IiwiZXZlbnRIYW5kbGVyIiwiZGF0YSIsImNvbnRleHQiLCJfbGVuMiIsIl9rZXkyIiwiaXNBcnJheSIsInNsaWNlIiwidW5zaGlmdCIsImV2ZW50c0FycmF5IiwidXBkYXRlU2l6ZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiaXNIb3Jpem9udGFsIiwiaXNWZXJ0aWNhbCIsInBhcnNlSW50IiwiaXNOYU4iLCJPYmplY3QiLCJhc3NpZ24iLCJzaXplIiwidXBkYXRlU2xpZGVzIiwiZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZSIsIm5vZGUiLCJsYWJlbCIsInBhcnNlRmxvYXQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0RGlyZWN0aW9uTGFiZWwiLCJzbGlkZXNFbCIsInN3aXBlclNpemUiLCJydGxUcmFuc2xhdGUiLCJydGwiLCJ3cm9uZ1JUTCIsImlzVmlydHVhbCIsInZpcnR1YWwiLCJlbmFibGVkIiwicHJldmlvdXNTbGlkZXNMZW5ndGgiLCJzbGlkZXMiLCJzbGlkZUNsYXNzIiwic2xpZGVzTGVuZ3RoIiwic25hcEdyaWQiLCJzbGlkZXNHcmlkIiwic2xpZGVzU2l6ZXNHcmlkIiwib2Zmc2V0QmVmb3JlIiwic2xpZGVzT2Zmc2V0QmVmb3JlIiwiY2FsbCIsIm9mZnNldEFmdGVyIiwic2xpZGVzT2Zmc2V0QWZ0ZXIiLCJwcmV2aW91c1NuYXBHcmlkTGVuZ3RoIiwicHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoIiwic3BhY2VCZXR3ZWVuIiwic2xpZGVQb3NpdGlvbiIsInByZXZTbGlkZVNpemUiLCJyZXBsYWNlIiwidmlydHVhbFNpemUiLCJzbGlkZUVsIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luVG9wIiwiY2VudGVyZWRTbGlkZXMiLCJjc3NNb2RlIiwiZ3JpZEVuYWJsZWQiLCJncmlkIiwicm93cyIsImluaXRTbGlkZXMiLCJ1bnNldFNsaWRlcyIsInNsaWRlU2l6ZSIsInNob3VsZFJlc2V0U2xpZGVTaXplIiwic2xpZGVzUGVyVmlldyIsImJyZWFrcG9pbnRzIiwia2V5cyIsImZpbHRlciIsImtleSIsInNsaWRlIiwidXBkYXRlU2xpZGUiLCJzbGlkZVN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJjdXJyZW50VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwiY3VycmVudFdlYktpdFRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsInJvdW5kTGVuZ3RocyIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiYm94U2l6aW5nIiwib2Zmc2V0V2lkdGgiLCJNYXRoIiwiZmxvb3IiLCJzd2lwZXJTbGlkZVNpemUiLCJhYnMiLCJzbGlkZXNQZXJHcm91cCIsIm1pbiIsInNsaWRlc1Blckdyb3VwU2tpcCIsIm1heCIsImVmZmVjdCIsInNldFdyYXBwZXJTaXplIiwidXBkYXRlV3JhcHBlclNpemUiLCJuZXdTbGlkZXNHcmlkIiwic2xpZGVzR3JpZEl0ZW0iLCJsb29wIiwiZ3JvdXBzIiwiY2VpbCIsInNsaWRlc0JlZm9yZSIsInNsaWRlc0FmdGVyIiwiZ3JvdXBTaXplIiwiXyIsInNsaWRlSW5kZXgiLCJjZW50ZXJlZFNsaWRlc0JvdW5kcyIsImFsbFNsaWRlc1NpemUiLCJzbGlkZVNpemVWYWx1ZSIsIm1heFNuYXAiLCJzbmFwIiwiY2VudGVySW5zdWZmaWNpZW50U2xpZGVzIiwiYWxsU2xpZGVzT2Zmc2V0Iiwic25hcEluZGV4IiwiYWRkVG9TbmFwR3JpZCIsImFkZFRvU2xpZGVzR3JpZCIsIndhdGNoT3ZlcmZsb3ciLCJjaGVja092ZXJmbG93Iiwid2F0Y2hTbGlkZXNQcm9ncmVzcyIsInVwZGF0ZVNsaWRlc09mZnNldCIsImJhY2tGYWNlSGlkZGVuQ2xhc3MiLCJjb250YWluZXJNb2RpZmllckNsYXNzIiwiaGFzQ2xhc3NCYWNrZmFjZUNsYXNzQWRkZWQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsIm1heEJhY2tmYWNlSGlkZGVuU2xpZGVzIiwiYWRkIiwicmVtb3ZlIiwidXBkYXRlQXV0b0hlaWdodCIsInNwZWVkIiwiYWN0aXZlU2xpZGVzIiwic2V0VHJhbnNpdGlvbiIsImdldFNsaWRlQnlJbmRleCIsImdldFNsaWRlSW5kZXhCeURhdGEiLCJ2aXNpYmxlU2xpZGVzIiwiYWN0aXZlSW5kZXgiLCJvZmZzZXRIZWlnaHQiLCJtaW51c09mZnNldCIsImlzRWxlbWVudCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzd2lwZXJTbGlkZU9mZnNldCIsImNzc092ZXJmbG93QWRqdXN0bWVudCIsInVwZGF0ZVNsaWRlc1Byb2dyZXNzIiwidHJhbnNsYXRlIiwib2Zmc2V0Q2VudGVyIiwic2xpZGVWaXNpYmxlQ2xhc3MiLCJzbGlkZUZ1bGx5VmlzaWJsZUNsYXNzIiwidmlzaWJsZVNsaWRlc0luZGV4ZXMiLCJzbGlkZU9mZnNldCIsInNsaWRlUHJvZ3Jlc3MiLCJtaW5UcmFuc2xhdGUiLCJvcmlnaW5hbFNsaWRlUHJvZ3Jlc3MiLCJzbGlkZUJlZm9yZSIsInNsaWRlQWZ0ZXIiLCJpc0Z1bGx5VmlzaWJsZSIsImlzVmlzaWJsZSIsInByb2dyZXNzIiwib3JpZ2luYWxQcm9ncmVzcyIsInVwZGF0ZVByb2dyZXNzIiwibXVsdGlwbGllciIsInRyYW5zbGF0ZXNEaWZmIiwibWF4VHJhbnNsYXRlIiwiaXNCZWdpbm5pbmciLCJpc0VuZCIsInByb2dyZXNzTG9vcCIsIndhc0JlZ2lubmluZyIsIndhc0VuZCIsImlzQmVnaW5uaW5nUm91bmRlZCIsImlzRW5kUm91bmRlZCIsImZpcnN0U2xpZGVJbmRleCIsImxhc3RTbGlkZUluZGV4IiwiZmlyc3RTbGlkZVRyYW5zbGF0ZSIsImxhc3RTbGlkZVRyYW5zbGF0ZSIsInRyYW5zbGF0ZU1heCIsInRyYW5zbGF0ZUFicyIsImF1dG9IZWlnaHQiLCJ0b2dnbGVTbGlkZUNsYXNzZXMiLCJjb25kaXRpb24iLCJjbGFzc05hbWUiLCJ1cGRhdGVTbGlkZXNDbGFzc2VzIiwiZ2V0RmlsdGVyZWRTbGlkZSIsInNlbGVjdG9yIiwiYWN0aXZlU2xpZGUiLCJwcmV2U2xpZGUiLCJuZXh0U2xpZGUiLCJjb2x1bW4iLCJzbGlkZUFjdGl2ZUNsYXNzIiwic2xpZGVOZXh0Q2xhc3MiLCJzbGlkZVByZXZDbGFzcyIsImVtaXRTbGlkZXNDbGFzc2VzIiwicHJvY2Vzc0xhenlQcmVsb2FkZXIiLCJpbWFnZUVsIiwic2xpZGVTZWxlY3RvciIsImNsb3Nlc3QiLCJsYXp5RWwiLCJxdWVyeVNlbGVjdG9yIiwibGF6eVByZWxvYWRlckNsYXNzIiwic2hhZG93Um9vdCIsInVubGF6eSIsInJlbW92ZUF0dHJpYnV0ZSIsInByZWxvYWQiLCJhbW91bnQiLCJsYXp5UHJlbG9hZFByZXZOZXh0IiwibGVuIiwic2xpZGVzUGVyVmlld0R5bmFtaWMiLCJhY3RpdmVDb2x1bW4iLCJwcmVsb2FkQ29sdW1ucyIsImZyb20iLCJzbGlkZUluZGV4TGFzdEluVmlldyIsInJld2luZCIsInJlYWxJbmRleCIsImdldEFjdGl2ZUluZGV4QnlUcmFuc2xhdGUiLCJub3JtYWxpemVTbGlkZUluZGV4IiwidXBkYXRlQWN0aXZlSW5kZXgiLCJuZXdBY3RpdmVJbmRleCIsInByZXZpb3VzSW5kZXgiLCJwcmV2aW91c1JlYWxJbmRleCIsInByZXZpb3VzU25hcEluZGV4IiwiZ2V0VmlydHVhbFJlYWxJbmRleCIsImFJbmRleCIsInNraXAiLCJmaXJzdFNsaWRlSW5Db2x1bW4iLCJhY3RpdmVTbGlkZUluZGV4IiwiZ2V0QXR0cmlidXRlIiwicnVuQ2FsbGJhY2tzT25Jbml0IiwidXBkYXRlQ2xpY2tlZFNsaWRlIiwicGF0aCIsInBhdGhFbCIsIm1hdGNoZXMiLCJzbGlkZUZvdW5kIiwiY2xpY2tlZFNsaWRlIiwiY2xpY2tlZEluZGV4IiwidW5kZWZpbmVkIiwic2xpZGVUb0NsaWNrZWRTbGlkZSIsInVwZGF0ZSIsImdldFN3aXBlclRyYW5zbGF0ZSIsImF4aXMiLCJ2aXJ0dWFsVHJhbnNsYXRlIiwiY3VycmVudFRyYW5zbGF0ZSIsInNldFRyYW5zbGF0ZSIsImJ5Q29udHJvbGxlciIsIngiLCJ5IiwieiIsInByZXZpb3VzVHJhbnNsYXRlIiwibmV3UHJvZ3Jlc3MiLCJ0cmFuc2xhdGVUbyIsInJ1bkNhbGxiYWNrcyIsInRyYW5zbGF0ZUJvdW5kcyIsImludGVybmFsIiwiYW5pbWF0aW5nIiwicHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uIiwibmV3VHJhbnNsYXRlIiwiaXNIIiwidGFyZ2V0UG9zaXRpb24iLCJzaWRlIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsIm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCIsInRyYW5zaXRpb25FbmQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsInRyYW5zaXRpb25FbWl0IiwiZGlyZWN0aW9uIiwic3RlcCIsImRpciIsInRyYW5zaXRpb25TdGFydCIsInRyYW5zaXRpb24iLCJzbGlkZVRvIiwiaW5pdGlhbCIsIm5vcm1hbGl6ZWRUcmFuc2xhdGUiLCJub3JtYWxpemVkR3JpZCIsIm5vcm1hbGl6ZWRHcmlkTmV4dCIsImFsbG93U2xpZGVOZXh0IiwiYWxsb3dTbGlkZVByZXYiLCJzY3JvbGxTbmFwVHlwZSIsIl9pbW1lZGlhdGVWaXJ0dWFsIiwiX2Nzc01vZGVWaXJ0dWFsSW5pdGlhbFNldCIsImluaXRpYWxTbGlkZSIsIm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kIiwic2xpZGVUb0xvb3AiLCJpbmRleEFzTnVtYmVyIiwibmV3SW5kZXgiLCJ0YXJnZXRTbGlkZUluZGV4IiwiY29scyIsIm5lZWRMb29wRml4IiwibG9vcEZpeCIsInNsaWRlUmVhbEluZGV4Iiwic2xpZGVOZXh0IiwicGVyR3JvdXAiLCJzbGlkZXNQZXJHcm91cEF1dG8iLCJpbmNyZW1lbnQiLCJsb29wUHJldmVudHNTbGlkaW5nIiwiX2NsaWVudExlZnQiLCJjbGllbnRMZWZ0Iiwic2xpZGVQcmV2Iiwibm9ybWFsaXplIiwidmFsIiwibm9ybWFsaXplZFNuYXBHcmlkIiwicHJldlNuYXAiLCJwcmV2U25hcEluZGV4IiwicHJldkluZGV4IiwibGFzdEluZGV4Iiwic2xpZGVSZXNldCIsInNsaWRlVG9DbG9zZXN0IiwidGhyZXNob2xkIiwiY3VycmVudFNuYXAiLCJuZXh0U25hcCIsInNsaWRlVG9JbmRleCIsImxvb3BlZFNsaWRlcyIsImdldFNsaWRlSW5kZXgiLCJsb29wQ3JlYXRlIiwic2V0QXR0cmlidXRlIiwic2hvdWxkRmlsbEdyb3VwIiwic2hvdWxkRmlsbEdyaWQiLCJhZGRCbGFua1NsaWRlcyIsImFtb3VudE9mU2xpZGVzIiwic2xpZGVCbGFua0NsYXNzIiwiYXBwZW5kIiwibG9vcEFkZEJsYW5rU2xpZGVzIiwic2xpZGVzVG9BZGQiLCJyZWNhbGNTbGlkZXMiLCJieU1vdXNld2hlZWwiLCJsb29wQWRkaXRpb25hbFNsaWRlcyIsImZpbGwiLCJwcmVwZW5kU2xpZGVzSW5kZXhlcyIsImFwcGVuZFNsaWRlc0luZGV4ZXMiLCJpc05leHQiLCJpc1ByZXYiLCJzbGlkZXNQcmVwZW5kZWQiLCJzbGlkZXNBcHBlbmRlZCIsImFjdGl2ZUNvbEluZGV4IiwiYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQiLCJjb2xJbmRleFRvUHJlcGVuZCIsInN3aXBlckxvb3BNb3ZlRE9NIiwicHJlcGVuZCIsImN1cnJlbnRTbGlkZVRyYW5zbGF0ZSIsIm5ld1NsaWRlVHJhbnNsYXRlIiwiZGlmZiIsInRvdWNoRXZlbnRzRGF0YSIsInN0YXJ0VHJhbnNsYXRlIiwic2hpZnQiLCJjb250cm9sbGVyIiwiY29udHJvbCIsImxvb3BQYXJhbXMiLCJjb25zdHJ1Y3RvciIsImxvb3BEZXN0cm95IiwibmV3U2xpZGVzT3JkZXIiLCJzd2lwZXJTbGlkZUluZGV4Iiwic2V0R3JhYkN1cnNvciIsIm1vdmluZyIsInNpbXVsYXRlVG91Y2giLCJpc0xvY2tlZCIsInRvdWNoRXZlbnRzVGFyZ2V0IiwiY3Vyc29yIiwidW5zZXRHcmFiQ3Vyc29yIiwiZ3JhYkN1cnNvciIsImNsb3Nlc3RFbGVtZW50IiwiYmFzZSIsIl9fY2xvc2VzdEZyb20iLCJhc3NpZ25lZFNsb3QiLCJmb3VuZCIsImdldFJvb3ROb2RlIiwiaG9zdCIsInByZXZlbnRFZGdlU3dpcGUiLCJzdGFydFgiLCJlZGdlU3dpcGVEZXRlY3Rpb24iLCJlZGdlU3dpcGVUaHJlc2hvbGQiLCJpbm5lcldpZHRoIiwicHJldmVudERlZmF1bHQiLCJvblRvdWNoU3RhcnQiLCJvcmlnaW5hbEV2ZW50IiwidHlwZSIsInBvaW50ZXJJZCIsInRhcmdldFRvdWNoZXMiLCJ0b3VjaElkIiwiaWRlbnRpZmllciIsInBhZ2VYIiwidG91Y2hlcyIsInBvaW50ZXJUeXBlIiwidGFyZ2V0RWwiLCJ3aGljaCIsImJ1dHRvbiIsImlzVG91Y2hlZCIsImlzTW92ZWQiLCJzd2lwaW5nQ2xhc3NIYXNWYWx1ZSIsIm5vU3dpcGluZ0NsYXNzIiwiZXZlbnRQYXRoIiwiY29tcG9zZWRQYXRoIiwibm9Td2lwaW5nU2VsZWN0b3IiLCJpc1RhcmdldFNoYWRvdyIsIm5vU3dpcGluZyIsImFsbG93Q2xpY2siLCJzd2lwZUhhbmRsZXIiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwicGFnZVkiLCJzdGFydFkiLCJhbGxvd1RvdWNoQ2FsbGJhY2tzIiwiaXNTY3JvbGxpbmciLCJzdGFydE1vdmluZyIsInRvdWNoU3RhcnRUaW1lIiwic3dpcGVEaXJlY3Rpb24iLCJhbGxvd1RocmVzaG9sZE1vdmUiLCJmb2N1c2FibGVFbGVtZW50cyIsIm5vZGVOYW1lIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJzaG91bGRQcmV2ZW50RGVmYXVsdCIsImFsbG93VG91Y2hNb3ZlIiwidG91Y2hTdGFydFByZXZlbnREZWZhdWx0IiwidG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImZyZWVNb2RlIiwib25Ub3VjaE1vdmUiLCJpZCIsInRhcmdldFRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJwcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciIsInRvdWNoUmVsZWFzZU9uRWRnZXMiLCJwcmV2aW91c1giLCJwcmV2aW91c1kiLCJkaWZmWCIsImRpZmZZIiwic3FydCIsInRvdWNoQW5nbGUiLCJhdGFuMiIsIlBJIiwicHJldmVudFRvdWNoTW92ZUZyb21Qb2ludGVyTW92ZSIsImNhbmNlbGFibGUiLCJ0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24iLCJuZXN0ZWQiLCJzdG9wUHJvcGFnYXRpb24iLCJ0b3VjaGVzRGlmZiIsIm9uZVdheU1vdmVtZW50IiwidG91Y2hSYXRpbyIsInByZXZUb3VjaGVzRGlyZWN0aW9uIiwidG91Y2hlc0RpcmVjdGlvbiIsImlzTG9vcCIsImFsbG93TG9vcEZpeCIsImV2dCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImRpc3BhdGNoRXZlbnQiLCJhbGxvd01vbWVudHVtQm91bmNlIiwibG9vcEZpeGVkIiwiRGF0ZSIsImdldFRpbWUiLCJsb29wU3dhcFJlc2V0IiwiZGlzYWJsZVBhcmVudFN3aXBlciIsInJlc2lzdGFuY2VSYXRpbyIsInJlc2lzdGFuY2UiLCJmb2xsb3dGaW5nZXIiLCJvblRvdWNoRW5kIiwiaXNUb3VjaEV2ZW50IiwicHJvY2VlZCIsInRvdWNoRW5kVGltZSIsInRpbWVEaWZmIiwicGF0aFRyZWUiLCJsYXN0Q2xpY2tUaW1lIiwiY3VycmVudFBvcyIsInN3aXBlVG9MYXN0Iiwic3RvcEluZGV4IiwicmV3aW5kRmlyc3RJbmRleCIsInJld2luZExhc3RJbmRleCIsInJhdGlvIiwibG9uZ1N3aXBlc01zIiwibG9uZ1N3aXBlcyIsImxvbmdTd2lwZXNSYXRpbyIsInNob3J0U3dpcGVzIiwiaXNOYXZCdXR0b25UYXJnZXQiLCJuYXZpZ2F0aW9uIiwibmV4dEVsIiwicHJldkVsIiwib25SZXNpemUiLCJzZXRCcmVha3BvaW50IiwiaXNWaXJ0dWFsTG9vcCIsImF1dG9wbGF5IiwicnVubmluZyIsInBhdXNlZCIsImNsZWFyVGltZW91dCIsInJlc2l6ZVRpbWVvdXQiLCJyZXN1bWUiLCJvbkNsaWNrIiwicHJldmVudENsaWNrcyIsInByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm9uU2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9uTG9hZCIsIm9uRG9jdW1lbnRUb3VjaFN0YXJ0IiwiZG9jdW1lbnRUb3VjaEhhbmRsZXJQcm9jZWVkZWQiLCJ0b3VjaEFjdGlvbiIsImNhcHR1cmUiLCJkb21NZXRob2QiLCJzd2lwZXJNZXRob2QiLCJwYXNzaXZlIiwidXBkYXRlT25XaW5kb3dSZXNpemUiLCJhdHRhY2hFdmVudHMiLCJiaW5kIiwiZGV0YWNoRXZlbnRzIiwiZXZlbnRzJDEiLCJpc0dyaWRFbmFibGVkIiwiYnJlYWtwb2ludCIsImdldEJyZWFrcG9pbnQiLCJicmVha3BvaW50c0Jhc2UiLCJjdXJyZW50QnJlYWtwb2ludCIsImJyZWFrcG9pbnRPbmx5UGFyYW1zIiwiYnJlYWtwb2ludFBhcmFtcyIsIm9yaWdpbmFsUGFyYW1zIiwid2FzTXVsdGlSb3ciLCJpc011bHRpUm93Iiwid2FzR3JhYkN1cnNvciIsImlzR3JhYkN1cnNvciIsIndhc0VuYWJsZWQiLCJlbWl0Q29udGFpbmVyQ2xhc3NlcyIsInByb3AiLCJ3YXNNb2R1bGVFbmFibGVkIiwiaXNNb2R1bGVFbmFibGVkIiwiZGlzYWJsZSIsImVuYWJsZSIsImRpcmVjdGlvbkNoYW5nZWQiLCJuZWVkc1JlTG9vcCIsIndhc0xvb3AiLCJjaGFuZ2VEaXJlY3Rpb24iLCJpc0VuYWJsZWQiLCJoYXNMb29wIiwiY29udGFpbmVyRWwiLCJjdXJyZW50SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJwb2ludHMiLCJwb2ludCIsIm1pblJhdGlvIiwic3Vic3RyIiwidmFsdWUiLCJzb3J0IiwiYiIsIm1hdGNoTWVkaWEiLCJwcmVwYXJlQ2xhc3NlcyIsInByZWZpeCIsInJlc3VsdENsYXNzZXMiLCJpdGVtIiwiY2xhc3NOYW1lcyIsImFkZENsYXNzZXMiLCJzdWZmaXhlcyIsInJlbW92ZUNsYXNzZXMiLCJjbGFzc2VzIiwid2FzTG9ja2VkIiwibGFzdFNsaWRlUmlnaHRFZGdlIiwiY2hlY2tPdmVyZmxvdyQxIiwiZGVmYXVsdHMiLCJzd2lwZXJFbGVtZW50Tm9kZU5hbWUiLCJjcmVhdGVFbGVtZW50cyIsImV2ZW50c1ByZWZpeCIsInVybCIsInVuaXF1ZU5hdkVsZW1lbnRzIiwicGFzc2l2ZUxpc3RlbmVycyIsIndyYXBwZXJDbGFzcyIsIl9lbWl0Q2xhc3NlcyIsIm1vZHVsZUV4dGVuZFBhcmFtcyIsImFsbE1vZHVsZXNQYXJhbXMiLCJvYmoiLCJtb2R1bGVQYXJhbU5hbWUiLCJtb2R1bGVQYXJhbXMiLCJhdXRvIiwicHJvdG90eXBlcyIsImV4dGVuZGVkRGVmYXVsdHMiLCJTd2lwZXIiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzd2lwZXJzIiwibmV3UGFyYW1zIiwiX19zd2lwZXJfXyIsIm1vZHVsZXMiLCJfX21vZHVsZXNfXyIsIm1vZCIsInN3aXBlclBhcmFtcyIsInBhc3NlZFBhcmFtcyIsImV2ZW50TmFtZSIsInZlbG9jaXR5IiwidHJ1bmMiLCJjbGlja1RpbWVvdXQiLCJ2ZWxvY2l0aWVzIiwiaW1hZ2VzVG9Mb2FkIiwiaW1hZ2VzTG9hZGVkIiwicHJvcGVydHkiLCJzZXRQcm9ncmVzcyIsImN1cnJlbnQiLCJjbHMiLCJqb2luIiwiZ2V0U2xpZGVDbGFzc2VzIiwidXBkYXRlcyIsInZpZXciLCJleGFjdCIsInNwdiIsImJyZWFrTG9vcCIsInNsaWRlSW5WaWV3IiwiY29tcGxldGUiLCJ0cmFuc2xhdGVWYWx1ZSIsInRyYW5zbGF0ZWQiLCJuZXdEaXJlY3Rpb24iLCJuZWVkVXBkYXRlIiwiY3VycmVudERpcmVjdGlvbiIsImNoYW5nZUxhbmd1YWdlRGlyZWN0aW9uIiwibW91bnQiLCJlbGVtZW50IiwibW91bnRlZCIsInBhcmVudE5vZGUiLCJ0b1VwcGVyQ2FzZSIsImdldFdyYXBwZXJTZWxlY3RvciIsInRyaW0iLCJnZXRXcmFwcGVyIiwicmVzIiwic2xpZGVTbG90cyIsImxhenlFbGVtZW50cyIsImRlbGV0ZUluc3RhbmNlIiwiY2xlYW5TdHlsZXMiLCJleHRlbmREZWZhdWx0cyIsIm5ld0RlZmF1bHRzIiwiaW5zdGFsbE1vZHVsZSIsInVzZSIsIm1vZHVsZSIsIm0iLCJwcm90b3R5cGVHcm91cCIsInByb3RvTWV0aG9kIiwiUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/swiper-core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/update-on-virtual-data.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/shared/update-on-virtual-data.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getChangedParams),\n/* harmony export */   g: () => (/* binding */ getParams),\n/* harmony export */   m: () => (/* binding */ mountSwiper),\n/* harmony export */   u: () => (/* binding */ updateOnVirtualData)\n/* harmony export */ });\n/* harmony import */ var _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./update-swiper.mjs */ \"(ssr)/./node_modules/swiper/shared/update-swiper.mjs\");\n/* harmony import */ var _swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./swiper-core.mjs */ \"(ssr)/./node_modules/swiper/shared/swiper-core.mjs\");\n\n\nfunction getParams(obj, splitEvents) {\n    if (obj === void 0) {\n        obj = {};\n    }\n    if (splitEvents === void 0) {\n        splitEvents = true;\n    }\n    const params = {\n        on: {}\n    };\n    const events = {};\n    const passedParams = {};\n    (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(params, _swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__.d);\n    params._emitClasses = true;\n    params.init = false;\n    const rest = {};\n    const allowedParams = _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.p.map((key)=>key.replace(/_/, \"\"));\n    const plainObj = Object.assign({}, obj);\n    Object.keys(plainObj).forEach((key)=>{\n        if (typeof obj[key] === \"undefined\") return;\n        if (allowedParams.indexOf(key) >= 0) {\n            if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(obj[key])) {\n                params[key] = {};\n                passedParams[key] = {};\n                (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(params[key], obj[key]);\n                (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(passedParams[key], obj[key]);\n            } else {\n                params[key] = obj[key];\n                passedParams[key] = obj[key];\n            }\n        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === \"function\") {\n            if (splitEvents) {\n                events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];\n            } else {\n                params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];\n            }\n        } else {\n            rest[key] = obj[key];\n        }\n    });\n    [\n        \"navigation\",\n        \"pagination\",\n        \"scrollbar\"\n    ].forEach((key)=>{\n        if (params[key] === true) params[key] = {};\n        if (params[key] === false) delete params[key];\n    });\n    return {\n        params,\n        passedParams,\n        rest,\n        events\n    };\n}\nfunction mountSwiper(_ref, swiperParams) {\n    let { el, nextEl, prevEl, paginationEl, scrollbarEl, swiper } = _ref;\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(swiperParams) && nextEl && prevEl) {\n        swiper.params.navigation.nextEl = nextEl;\n        swiper.originalParams.navigation.nextEl = nextEl;\n        swiper.params.navigation.prevEl = prevEl;\n        swiper.originalParams.navigation.prevEl = prevEl;\n    }\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(swiperParams) && paginationEl) {\n        swiper.params.pagination.el = paginationEl;\n        swiper.originalParams.pagination.el = paginationEl;\n    }\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(swiperParams) && scrollbarEl) {\n        swiper.params.scrollbar.el = scrollbarEl;\n        swiper.originalParams.scrollbar.el = scrollbarEl;\n    }\n    swiper.init(el);\n}\nfunction getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {\n    const keys = [];\n    if (!oldParams) return keys;\n    const addKey = (key)=>{\n        if (keys.indexOf(key) < 0) keys.push(key);\n    };\n    if (children && oldChildren) {\n        const oldChildrenKeys = oldChildren.map(getKey);\n        const childrenKeys = children.map(getKey);\n        if (oldChildrenKeys.join(\"\") !== childrenKeys.join(\"\")) addKey(\"children\");\n        if (oldChildren.length !== children.length) addKey(\"children\");\n    }\n    const watchParams = _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.p.filter((key)=>key[0] === \"_\").map((key)=>key.replace(/_/, \"\"));\n    watchParams.forEach((key)=>{\n        if (key in swiperParams && key in oldParams) {\n            if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(swiperParams[key]) && (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(oldParams[key])) {\n                const newKeys = Object.keys(swiperParams[key]);\n                const oldKeys = Object.keys(oldParams[key]);\n                if (newKeys.length !== oldKeys.length) {\n                    addKey(key);\n                } else {\n                    newKeys.forEach((newKey)=>{\n                        if (swiperParams[key][newKey] !== oldParams[key][newKey]) {\n                            addKey(key);\n                        }\n                    });\n                    oldKeys.forEach((oldKey)=>{\n                        if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);\n                    });\n                }\n            } else if (swiperParams[key] !== oldParams[key]) {\n                addKey(key);\n            }\n        }\n    });\n    return keys;\n}\nconst updateOnVirtualData = (swiper)=>{\n    if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {\n        swiper.parallax.setTranslate();\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91cGRhdGUtb24tdmlydHVhbC1kYXRhLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUo7QUFDakc7QUFFbEQsU0FBU2MsVUFBVUMsR0FBRyxFQUFFQyxXQUFXO0lBQ2pDLElBQUlELFFBQVEsS0FBSyxHQUFHO1FBQ2xCQSxNQUFNLENBQUM7SUFDVDtJQUNBLElBQUlDLGdCQUFnQixLQUFLLEdBQUc7UUFDMUJBLGNBQWM7SUFDaEI7SUFDQSxNQUFNQyxTQUFTO1FBQ2JDLElBQUksQ0FBQztJQUNQO0lBQ0EsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLE1BQU1DLGVBQWUsQ0FBQztJQUN0Qm5CLHFEQUFNQSxDQUFDZ0IsUUFBUUosK0NBQVFBO0lBQ3ZCSSxPQUFPSSxZQUFZLEdBQUc7SUFDdEJKLE9BQU9LLElBQUksR0FBRztJQUNkLE1BQU1DLE9BQU8sQ0FBQztJQUNkLE1BQU1DLGdCQUFnQnJCLGlEQUFVQSxDQUFDc0IsR0FBRyxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJQyxPQUFPLENBQUMsS0FBSztJQUM3RCxNQUFNQyxXQUFXQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHZjtJQUNuQ2MsT0FBT0UsSUFBSSxDQUFDSCxVQUFVSSxPQUFPLENBQUNOLENBQUFBO1FBQzVCLElBQUksT0FBT1gsR0FBRyxDQUFDVyxJQUFJLEtBQUssYUFBYTtRQUNyQyxJQUFJRixjQUFjUyxPQUFPLENBQUNQLFFBQVEsR0FBRztZQUNuQyxJQUFJckIscURBQVFBLENBQUNVLEdBQUcsQ0FBQ1csSUFBSSxHQUFHO2dCQUN0QlQsTUFBTSxDQUFDUyxJQUFJLEdBQUcsQ0FBQztnQkFDZk4sWUFBWSxDQUFDTSxJQUFJLEdBQUcsQ0FBQztnQkFDckJ6QixxREFBTUEsQ0FBQ2dCLE1BQU0sQ0FBQ1MsSUFBSSxFQUFFWCxHQUFHLENBQUNXLElBQUk7Z0JBQzVCekIscURBQU1BLENBQUNtQixZQUFZLENBQUNNLElBQUksRUFBRVgs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LE9BQU9LO0FBQ1Q7QUFFQSxNQUFNb0Msc0JBQXNCdEIsQ0FBQUE7SUFDMUIsSUFBSSxDQUFDQSxVQUFVQSxPQUFPdUIsU0FBUyxJQUFJLENBQUN2QixPQUFPNUIsTUFBTSxDQUFDb0QsT0FBTyxJQUFJeEIsT0FBTzVCLE1BQU0sQ0FBQ29ELE9BQU8sSUFBSSxDQUFDeEIsT0FBTzVCLE1BQU0sQ0FBQ29ELE9BQU8sQ0FBQ0MsT0FBTyxFQUFFO0lBQ3RIekIsT0FBTzBCLFlBQVk7SUFDbkIxQixPQUFPMkIsY0FBYztJQUNyQjNCLE9BQU80QixtQkFBbUI7SUFDMUIsSUFBSTVCLE9BQU82QixRQUFRLElBQUk3QixPQUFPNUIsTUFBTSxDQUFDeUQsUUFBUSxJQUFJN0IsT0FBTzVCLE1BQU0sQ0FBQ3lELFFBQVEsQ0FBQ0osT0FBTyxFQUFFO1FBQy9FekIsT0FBTzZCLFFBQVEsQ0FBQ0MsWUFBWTtJQUM5QjtBQUNGO0FBRTZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluZm8tbmV4dC8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3VwZGF0ZS1vbi12aXJ0dWFsLWRhdGEubWpzP2U5NmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZSBhcyBleHRlbmQsIHAgYXMgcGFyYW1zTGlzdCwgaSBhcyBpc09iamVjdCwgbiBhcyBuZWVkc05hdmlnYXRpb24sIGEgYXMgbmVlZHNQYWdpbmF0aW9uLCBiIGFzIG5lZWRzU2Nyb2xsYmFyIH0gZnJvbSAnLi91cGRhdGUtc3dpcGVyLm1qcyc7XG5pbXBvcnQgeyBkIGFzIGRlZmF1bHRzIH0gZnJvbSAnLi9zd2lwZXItY29yZS5tanMnO1xuXG5mdW5jdGlvbiBnZXRQYXJhbXMob2JqLCBzcGxpdEV2ZW50cykge1xuICBpZiAob2JqID09PSB2b2lkIDApIHtcbiAgICBvYmogPSB7fTtcbiAgfVxuICBpZiAoc3BsaXRFdmVudHMgPT09IHZvaWQgMCkge1xuICAgIHNwbGl0RXZlbnRzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgb246IHt9XG4gIH07XG4gIGNvbnN0IGV2ZW50cyA9IHt9O1xuICBjb25zdCBwYXNzZWRQYXJhbXMgPSB7fTtcbiAgZXh0ZW5kKHBhcmFtcywgZGVmYXVsdHMpO1xuICBwYXJhbXMuX2VtaXRDbGFzc2VzID0gdHJ1ZTtcbiAgcGFyYW1zLmluaXQgPSBmYWxzZTtcbiAgY29uc3QgcmVzdCA9IHt9O1xuICBjb25zdCBhbGxvd2VkUGFyYW1zID0gcGFyYW1zTGlzdC5tYXAoa2V5ID0+IGtleS5yZXBsYWNlKC9fLywgJycpKTtcbiAgY29uc3QgcGxhaW5PYmogPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICBPYmplY3Qua2V5cyhwbGFpbk9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgaWYgKGFsbG93ZWRQYXJhbXMuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSB7fTtcbiAgICAgICAgcGFzc2VkUGFyYW1zW2tleV0gPSB7fTtcbiAgICAgICAgZXh0ZW5kKHBhcmFtc1trZXldLCBvYmpba2V5XSk7XG4gICAgICAgIGV4dGVuZChwYXNzZWRQYXJhbXNba2V5XSwgb2JqW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgcGFzc2VkUGFyYW1zW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleS5zZWFyY2goL29uW0EtWl0vKSA9PT0gMCAmJiB0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChzcGxpdEV2ZW50cykge1xuICAgICAgICBldmVudHNbYCR7a2V5WzJdLnRvTG93ZXJDYXNlKCl9JHtrZXkuc3Vic3RyKDMpfWBdID0gb2JqW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMub25bYCR7a2V5WzJdLnRvTG93ZXJDYXNlKCl9JHtrZXkuc3Vic3RyKDMpfWBdID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3Rba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIFsnbmF2aWdhdGlvbicsICdwYWdpbmF0aW9uJywgJ3Njcm9sbGJhciddLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAocGFyYW1zW2tleV0gPT09IHRydWUpIHBhcmFtc1trZXldID0ge307XG4gICAgaWYgKHBhcmFtc1trZXldID09PSBmYWxzZSkgZGVsZXRlIHBhcmFtc1trZXldO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGFzc2VkUGFyYW1zLFxuICAgIHJlc3QsXG4gICAgZXZlbnRzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50U3dpcGVyKF9yZWYsIHN3aXBlclBhcmFtcykge1xuICBsZXQge1xuICAgIGVsLFxuICAgIG5leHRFbCxcbiAgICBwcmV2RWwsXG4gICAgcGFnaW5hdGlvbkVsLFxuICAgIHNjcm9sbGJhckVsLFxuICAgIHN3aXBlclxuICB9ID0gX3JlZjtcbiAgaWYgKG5lZWRzTmF2aWdhdGlvbihzd2lwZXJQYXJhbXMpICYmIG5leHRFbCAmJiBwcmV2RWwpIHtcbiAgICBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ubmV4dEVsID0gbmV4dEVsO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5uYXZpZ2F0aW9uLm5leHRFbCA9IG5leHRFbDtcbiAgICBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ucHJldkVsID0gcHJldkVsO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCA9IHByZXZFbDtcbiAgfVxuICBpZiAobmVlZHNQYWdpbmF0aW9uKHN3aXBlclBhcmFtcykgJiYgcGFnaW5hdGlvbkVsKSB7XG4gICAgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmVsID0gcGFnaW5hdGlvbkVsO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5wYWdpbmF0aW9uLmVsID0gcGFnaW5hdGlvbkVsO1xuICB9XG4gIGlmIChuZWVkc1Njcm9sbGJhcihzd2lwZXJQYXJhbXMpICYmIHNjcm9sbGJhckVsKSB7XG4gICAgc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgPSBzY3JvbGxiYXJFbDtcbiAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMuc2Nyb2xsYmFyLmVsID0gc2Nyb2xsYmFyRWw7XG4gIH1cbiAgc3dpcGVyLmluaXQoZWwpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VkUGFyYW1zKHN3aXBlclBhcmFtcywgb2xkUGFyYW1zLCBjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGdldEtleSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGlmICghb2xkUGFyYW1zKSByZXR1cm4ga2V5cztcbiAgY29uc3QgYWRkS2V5ID0ga2V5ID0+IHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPCAwKSBrZXlzLnB1c2goa2V5KTtcbiAgfTtcbiAgaWYgKGNoaWxkcmVuICYmIG9sZENoaWxkcmVuKSB7XG4gICAgY29uc3Qgb2xkQ2hpbGRyZW5LZXlzID0gb2xkQ2hpbGRyZW4ubWFwKGdldEtleSk7XG4gICAgY29uc3QgY2hpbGRyZW5LZXlzID0gY2hpbGRyZW4ubWFwKGdldEtleSk7XG4gICAgaWYgKG9sZENoaWxkcmVuS2V5cy5qb2luKCcnKSAhPT0gY2hpbGRyZW5LZXlzLmpvaW4oJycpKSBhZGRLZXkoJ2NoaWxkcmVuJyk7XG4gICAgaWYgKG9sZENoaWxkcmVuLmxlbmd0aCAhPT0gY2hpbGRyZW4ubGVuZ3RoKSBhZGRLZXkoJ2NoaWxkcmVuJyk7XG4gIH1cbiAgY29uc3Qgd2F0Y2hQYXJhbXMgPSBwYXJhbXNMaXN0LmZpbHRlcihrZXkgPT4ga2V5WzBdID09PSAnXycpLm1hcChrZXkgPT4ga2V5LnJlcGxhY2UoL18vLCAnJykpO1xuICB3YXRjaFBhcmFtcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGtleSBpbiBzd2lwZXJQYXJhbXMgJiYga2V5IGluIG9sZFBhcmFtcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHN3aXBlclBhcmFtc1trZXldKSAmJiBpc09iamVjdChvbGRQYXJhbXNba2V5XSkpIHtcbiAgICAgICAgY29uc3QgbmV3S2V5cyA9IE9iamVjdC5rZXlzKHN3aXBlclBhcmFtc1trZXldKTtcbiAgICAgICAgY29uc3Qgb2xkS2V5cyA9IE9iamVjdC5rZXlzKG9sZFBhcmFtc1trZXldKTtcbiAgICAgICAgaWYgKG5ld0tleXMubGVuZ3RoICE9PSBvbGRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGFkZEtleShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0tleXMuZm9yRWFjaChuZXdLZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHN3aXBlclBhcmFtc1trZXldW25ld0tleV0gIT09IG9sZFBhcmFtc1trZXldW25ld0tleV0pIHtcbiAgICAgICAgICAgICAgYWRkS2V5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2xkS2V5cy5mb3JFYWNoKG9sZEtleSA9PiB7XG4gICAgICAgICAgICBpZiAoc3dpcGVyUGFyYW1zW2tleV1bb2xkS2V5XSAhPT0gb2xkUGFyYW1zW2tleV1bb2xkS2V5XSkgYWRkS2V5KGtleSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3dpcGVyUGFyYW1zW2tleV0gIT09IG9sZFBhcmFtc1trZXldKSB7XG4gICAgICAgIGFkZEtleShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5jb25zdCB1cGRhdGVPblZpcnR1YWxEYXRhID0gc3dpcGVyID0+IHtcbiAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLnBhcmFtcy52aXJ0dWFsIHx8IHN3aXBlci5wYXJhbXMudmlydHVhbCAmJiAhc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgaWYgKHN3aXBlci5wYXJhbGxheCAmJiBzd2lwZXIucGFyYW1zLnBhcmFsbGF4ICYmIHN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkge1xuICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2xhdGUoKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ2V0Q2hhbmdlZFBhcmFtcyBhcyBhLCBnZXRQYXJhbXMgYXMgZywgbW91bnRTd2lwZXIgYXMgbSwgdXBkYXRlT25WaXJ0dWFsRGF0YSBhcyB1IH07XG4iXSwibmFtZXMiOlsiZSIsImV4dGVuZCIsInAiLCJwYXJhbXNMaXN0IiwiaSIsImlzT2JqZWN0IiwibiIsIm5lZWRzTmF2aWdhdGlvbiIsImEiLCJuZWVkc1BhZ2luYXRpb24iLCJiIiwibmVlZHNTY3JvbGxiYXIiLCJkIiwiZGVmYXVsdHMiLCJnZXRQYXJhbXMiLCJvYmoiLCJzcGxpdEV2ZW50cyIsInBhcmFtcyIsIm9uIiwiZXZlbnRzIiwicGFzc2VkUGFyYW1zIiwiX2VtaXRDbGFzc2VzIiwiaW5pdCIsInJlc3QiLCJhbGxvd2VkUGFyYW1zIiwibWFwIiwia2V5IiwicmVwbGFjZSIsInBsYWluT2JqIiwiT2JqZWN0IiwiYXNzaWduIiwia2V5cyIsImZvckVhY2giLCJpbmRleE9mIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJzdWJzdHIiLCJtb3VudFN3aXBlciIsIl9yZWYiLCJzd2lwZXJQYXJhbXMiLCJlbCIsIm5leHRFbCIsInByZXZFbCIsInBhZ2luYXRpb25FbCIsInNjcm9sbGJhckVsIiwic3dpcGVyIiwibmF2aWdhdGlvbiIsIm9yaWdpbmFsUGFyYW1zIiwicGFnaW5hdGlvbiIsInNjcm9sbGJhciIsImdldENoYW5nZWRQYXJhbXMiLCJvbGRQYXJhbXMiLCJjaGlsZHJlbiIsIm9sZENoaWxkcmVuIiwiZ2V0S2V5IiwiYWRkS2V5IiwicHVzaCIsIm9sZENoaWxkcmVuS2V5cyIsImNoaWxkcmVuS2V5cyIsImpvaW4iLCJsZW5ndGgiLCJ3YXRjaFBhcmFtcyIsImZpbHRlciIsIm5ld0tleXMiLCJvbGRLZXlzIiwibmV3S2V5Iiwib2xkS2V5IiwidXBkYXRlT25WaXJ0dWFsRGF0YSIsImRlc3Ryb3llZCIsInZpcnR1YWwiLCJlbmFibGVkIiwidXBkYXRlU2xpZGVzIiwidXBkYXRlUHJvZ3Jlc3MiLCJ1cGRhdGVTbGlkZXNDbGFzc2VzIiwicGFyYWxsYXgiLCJzZXRUcmFuc2xhdGUiLCJnIiwibSIsInUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/update-on-virtual-data.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/update-swiper.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/shared/update-swiper.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ needsPagination),\n/* harmony export */   b: () => (/* binding */ needsScrollbar),\n/* harmony export */   c: () => (/* binding */ attrToProp),\n/* harmony export */   d: () => (/* binding */ uniqueClasses),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   n: () => (/* binding */ needsNavigation),\n/* harmony export */   p: () => (/* binding */ paramsList),\n/* harmony export */   u: () => (/* binding */ updateSwiper),\n/* harmony export */   w: () => (/* binding */ wrapperClass)\n/* harmony export */ });\n/* underscore in name -> watch for changes */ const paramsList = [\n    \"eventsPrefix\",\n    \"injectStyles\",\n    \"injectStylesUrls\",\n    \"modules\",\n    \"init\",\n    \"_direction\",\n    \"oneWayMovement\",\n    \"swiperElementNodeName\",\n    \"touchEventsTarget\",\n    \"initialSlide\",\n    \"_speed\",\n    \"cssMode\",\n    \"updateOnWindowResize\",\n    \"resizeObserver\",\n    \"nested\",\n    \"focusableElements\",\n    \"_enabled\",\n    \"_width\",\n    \"_height\",\n    \"preventInteractionOnTransition\",\n    \"userAgent\",\n    \"url\",\n    \"_edgeSwipeDetection\",\n    \"_edgeSwipeThreshold\",\n    \"_freeMode\",\n    \"_autoHeight\",\n    \"setWrapperSize\",\n    \"virtualTranslate\",\n    \"_effect\",\n    \"breakpoints\",\n    \"breakpointsBase\",\n    \"_spaceBetween\",\n    \"_slidesPerView\",\n    \"maxBackfaceHiddenSlides\",\n    \"_grid\",\n    \"_slidesPerGroup\",\n    \"_slidesPerGroupSkip\",\n    \"_slidesPerGroupAuto\",\n    \"_centeredSlides\",\n    \"_centeredSlidesBounds\",\n    \"_slidesOffsetBefore\",\n    \"_slidesOffsetAfter\",\n    \"normalizeSlideIndex\",\n    \"_centerInsufficientSlides\",\n    \"_watchOverflow\",\n    \"roundLengths\",\n    \"touchRatio\",\n    \"touchAngle\",\n    \"simulateTouch\",\n    \"_shortSwipes\",\n    \"_longSwipes\",\n    \"longSwipesRatio\",\n    \"longSwipesMs\",\n    \"_followFinger\",\n    \"allowTouchMove\",\n    \"_threshold\",\n    \"touchMoveStopPropagation\",\n    \"touchStartPreventDefault\",\n    \"touchStartForcePreventDefault\",\n    \"touchReleaseOnEdges\",\n    \"uniqueNavElements\",\n    \"_resistance\",\n    \"_resistanceRatio\",\n    \"_watchSlidesProgress\",\n    \"_grabCursor\",\n    \"preventClicks\",\n    \"preventClicksPropagation\",\n    \"_slideToClickedSlide\",\n    \"_loop\",\n    \"loopAdditionalSlides\",\n    \"loopAddBlankSlides\",\n    \"loopPreventsSliding\",\n    \"_rewind\",\n    \"_allowSlidePrev\",\n    \"_allowSlideNext\",\n    \"_swipeHandler\",\n    \"_noSwiping\",\n    \"noSwipingClass\",\n    \"noSwipingSelector\",\n    \"passiveListeners\",\n    \"containerModifierClass\",\n    \"slideClass\",\n    \"slideActiveClass\",\n    \"slideVisibleClass\",\n    \"slideFullyVisibleClass\",\n    \"slideNextClass\",\n    \"slidePrevClass\",\n    \"slideBlankClass\",\n    \"wrapperClass\",\n    \"lazyPreloaderClass\",\n    \"lazyPreloadPrevNext\",\n    \"runCallbacksOnInit\",\n    \"observer\",\n    \"observeParents\",\n    \"observeSlideChildren\",\n    // modules\n    \"a11y\",\n    \"_autoplay\",\n    \"_controller\",\n    \"coverflowEffect\",\n    \"cubeEffect\",\n    \"fadeEffect\",\n    \"flipEffect\",\n    \"creativeEffect\",\n    \"cardsEffect\",\n    \"hashNavigation\",\n    \"history\",\n    \"keyboard\",\n    \"mousewheel\",\n    \"_navigation\",\n    \"_pagination\",\n    \"parallax\",\n    \"_scrollbar\",\n    \"_thumbs\",\n    \"virtual\",\n    \"zoom\",\n    \"control\"\n];\nfunction isObject(o) {\n    return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\" && !o.__swiper__;\n}\nfunction extend(target, src) {\n    const noExtend = [\n        \"__proto__\",\n        \"constructor\",\n        \"prototype\"\n    ];\n    Object.keys(src).filter((key)=>noExtend.indexOf(key) < 0).forEach((key)=>{\n        if (typeof target[key] === \"undefined\") target[key] = src[key];\n        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n            if (src[key].__swiper__) target[key] = src[key];\n            else extend(target[key], src[key]);\n        } else {\n            target[key] = src[key];\n        }\n    });\n}\nfunction needsNavigation(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.navigation && typeof params.navigation.nextEl === \"undefined\" && typeof params.navigation.prevEl === \"undefined\";\n}\nfunction needsPagination(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.pagination && typeof params.pagination.el === \"undefined\";\n}\nfunction needsScrollbar(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.scrollbar && typeof params.scrollbar.el === \"undefined\";\n}\nfunction uniqueClasses(classNames) {\n    if (classNames === void 0) {\n        classNames = \"\";\n    }\n    const classes = classNames.split(\" \").map((c)=>c.trim()).filter((c)=>!!c);\n    const unique = [];\n    classes.forEach((c)=>{\n        if (unique.indexOf(c) < 0) unique.push(c);\n    });\n    return unique.join(\" \");\n}\nfunction attrToProp(attrName) {\n    if (attrName === void 0) {\n        attrName = \"\";\n    }\n    return attrName.replace(/-[a-z]/g, (l)=>l.toUpperCase().replace(\"-\", \"\"));\n}\nfunction wrapperClass(className) {\n    if (className === void 0) {\n        className = \"\";\n    }\n    if (!className) return \"swiper-wrapper\";\n    if (!className.includes(\"swiper-wrapper\")) return `swiper-wrapper ${className}`;\n    return className;\n}\nfunction updateSwiper(_ref) {\n    let { swiper, slides, passedParams, changedParams, nextEl, prevEl, scrollbarEl, paginationEl } = _ref;\n    const updateParams = changedParams.filter((key)=>key !== \"children\" && key !== \"direction\" && key !== \"wrapperClass\");\n    const { params: currentParams, pagination, navigation, scrollbar, virtual, thumbs } = swiper;\n    let needThumbsInit;\n    let needControllerInit;\n    let needPaginationInit;\n    let needScrollbarInit;\n    let needNavigationInit;\n    let loopNeedDestroy;\n    let loopNeedEnable;\n    let loopNeedReloop;\n    if (changedParams.includes(\"thumbs\") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {\n        needThumbsInit = true;\n    }\n    if (changedParams.includes(\"controller\") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {\n        needControllerInit = true;\n    }\n    if (changedParams.includes(\"pagination\") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {\n        needPaginationInit = true;\n    }\n    if (changedParams.includes(\"scrollbar\") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {\n        needScrollbarInit = true;\n    }\n    if (changedParams.includes(\"navigation\") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {\n        needNavigationInit = true;\n    }\n    const destroyModule = (mod)=>{\n        if (!swiper[mod]) return;\n        swiper[mod].destroy();\n        if (mod === \"navigation\") {\n            if (swiper.isElement) {\n                swiper[mod].prevEl.remove();\n                swiper[mod].nextEl.remove();\n            }\n            currentParams[mod].prevEl = undefined;\n            currentParams[mod].nextEl = undefined;\n            swiper[mod].prevEl = undefined;\n            swiper[mod].nextEl = undefined;\n        } else {\n            if (swiper.isElement) {\n                swiper[mod].el.remove();\n            }\n            currentParams[mod].el = undefined;\n            swiper[mod].el = undefined;\n        }\n    };\n    if (changedParams.includes(\"loop\") && swiper.isElement) {\n        if (currentParams.loop && !passedParams.loop) {\n            loopNeedDestroy = true;\n        } else if (!currentParams.loop && passedParams.loop) {\n            loopNeedEnable = true;\n        } else {\n            loopNeedReloop = true;\n        }\n    }\n    updateParams.forEach((key)=>{\n        if (isObject(currentParams[key]) && isObject(passedParams[key])) {\n            Object.assign(currentParams[key], passedParams[key]);\n            if ((key === \"navigation\" || key === \"pagination\" || key === \"scrollbar\") && \"enabled\" in passedParams[key] && !passedParams[key].enabled) {\n                destroyModule(key);\n            }\n        } else {\n            const newValue = passedParams[key];\n            if ((newValue === true || newValue === false) && (key === \"navigation\" || key === \"pagination\" || key === \"scrollbar\")) {\n                if (newValue === false) {\n                    destroyModule(key);\n                }\n            } else {\n                currentParams[key] = passedParams[key];\n            }\n        }\n    });\n    if (updateParams.includes(\"controller\") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {\n        swiper.controller.control = currentParams.controller.control;\n    }\n    if (changedParams.includes(\"children\") && slides && virtual && currentParams.virtual.enabled) {\n        virtual.slides = slides;\n        virtual.update(true);\n    } else if (changedParams.includes(\"virtual\") && virtual && currentParams.virtual.enabled) {\n        if (slides) virtual.slides = slides;\n        virtual.update(true);\n    }\n    if (changedParams.includes(\"children\") && slides && currentParams.loop) {\n        loopNeedReloop = true;\n    }\n    if (needThumbsInit) {\n        const initialized = thumbs.init();\n        if (initialized) thumbs.update(true);\n    }\n    if (needControllerInit) {\n        swiper.controller.control = currentParams.controller.control;\n    }\n    if (needPaginationInit) {\n        if (swiper.isElement && (!paginationEl || typeof paginationEl === \"string\")) {\n            paginationEl = document.createElement(\"div\");\n            paginationEl.classList.add(\"swiper-pagination\");\n            paginationEl.part.add(\"pagination\");\n            swiper.el.appendChild(paginationEl);\n        }\n        if (paginationEl) currentParams.pagination.el = paginationEl;\n        pagination.init();\n        pagination.render();\n        pagination.update();\n    }\n    if (needScrollbarInit) {\n        if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === \"string\")) {\n            scrollbarEl = document.createElement(\"div\");\n            scrollbarEl.classList.add(\"swiper-scrollbar\");\n            scrollbarEl.part.add(\"scrollbar\");\n            swiper.el.appendChild(scrollbarEl);\n        }\n        if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;\n        scrollbar.init();\n        scrollbar.updateSize();\n        scrollbar.setTranslate();\n    }\n    if (needNavigationInit) {\n        if (swiper.isElement) {\n            if (!nextEl || typeof nextEl === \"string\") {\n                nextEl = document.createElement(\"div\");\n                nextEl.classList.add(\"swiper-button-next\");\n                nextEl.innerHTML = swiper.hostEl.constructor.nextButtonSvg;\n                nextEl.part.add(\"button-next\");\n                swiper.el.appendChild(nextEl);\n            }\n            if (!prevEl || typeof prevEl === \"string\") {\n                prevEl = document.createElement(\"div\");\n                prevEl.classList.add(\"swiper-button-prev\");\n                prevEl.innerHTML = swiper.hostEl.constructor.prevButtonSvg;\n                prevEl.part.add(\"button-prev\");\n                swiper.el.appendChild(prevEl);\n            }\n        }\n        if (nextEl) currentParams.navigation.nextEl = nextEl;\n        if (prevEl) currentParams.navigation.prevEl = prevEl;\n        navigation.init();\n        navigation.update();\n    }\n    if (changedParams.includes(\"allowSlideNext\")) {\n        swiper.allowSlideNext = passedParams.allowSlideNext;\n    }\n    if (changedParams.includes(\"allowSlidePrev\")) {\n        swiper.allowSlidePrev = passedParams.allowSlidePrev;\n    }\n    if (changedParams.includes(\"direction\")) {\n        swiper.changeDirection(passedParams.direction, false);\n    }\n    if (loopNeedDestroy || loopNeedReloop) {\n        swiper.loopDestroy();\n    }\n    if (loopNeedEnable || loopNeedReloop) {\n        swiper.loopCreate();\n    }\n    swiper.update();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91cGRhdGUtc3dpcGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDLEdBQzNDLE1BQU1BLGFBQWE7SUFBQztJQUFnQjtJQUFnQjtJQUFvQjtJQUFXO0lBQVE7SUFBYztJQUFrQjtJQUF5QjtJQUFxQjtJQUFnQjtJQUFVO0lBQVc7SUFBd0I7SUFBa0I7SUFBVTtJQUFxQjtJQUFZO0lBQVU7SUFBVztJQUFrQztJQUFhO0lBQU87SUFBdUI7SUFBdUI7SUFBYTtJQUFlO0lBQWtCO0lBQW9CO0lBQVc7SUFBZTtJQUFtQjtJQUFpQjtJQUFrQjtJQUEyQjtJQUFTO0lBQW1CO0lBQXVCO0lBQXVCO0lBQW1CO0lBQXlCO0lBQXVCO0lBQXNCO0lBQXVCO0lBQTZCO0lBQWtCO0lBQWdCO0lBQWM7SUFBYztJQUFpQjtJQUFnQjtJQUFlO0lBQW1CO0lBQWdCO0lBQWlCO0lBQWtCO0lBQWM7SUFBNEI7SUFBNEI7SUFBaUM7SUFBdUI7SUFBcUI7SUFBZTtJQUFvQjtJQUF3QjtJQUFlO0lBQWlCO0lBQTRCO0lBQXdCO0lBQVM7SUFBd0I7SUFBc0I7SUFBdUI7SUFBVztJQUFtQjtJQUFtQjtJQUFpQjtJQUFjO0lBQWtCO0lBQXFCO0lBQW9CO0lBQTBCO0lBQWM7SUFBb0I7SUFBcUI7SUFBMEI7SUFBa0I7SUFBa0I7SUFBbUI7SUFBZ0I7SUFBc0I7SUFBdUI7SUFBc0I7SUFBWTtJQUFrQjtJQUNsdUQsVUFBVTtJQUNWO0lBQVE7SUFBYTtJQUFlO0lBQW1CO0lBQWM7SUFBYztJQUFjO0lBQWtCO0lBQWU7SUFBa0I7SUFBVztJQUFZO0lBQWM7SUFBZTtJQUFlO0lBQVk7SUFBYztJQUFXO0lBQVc7SUFBUTtDQUFVO0FBRXpSLFNBQVNDLFNBQVNDLENBQUM7SUFDakIsT0FBTyxPQUFPQSxNQUFNLFlBQVlBLE1BQU0sUUFBUUEsRUFBRUMsV0FBVyxJQUFJQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FB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VTtnQkFDekNBLFNBQVMyRCxTQUFTQyxhQUFhLENBQUM7Z0JBQ2hDNUQsT0FBTzZELFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO2dCQUNyQjlELE9BQU9vRSxTQUFTLEdBQUcxQyxPQUFPMkMsTUFBTSxDQUFDMUYsV0FBVyxDQUFDNEYsYUFBYTtnQkFDMUR2RSxPQUFPK0QsSUFBSSxDQUFDRCxHQUFHLENBQUM7Z0JBQ2hCcEMsT0FBT3ZCLEVBQUUsQ0FBQzZELFdBQVcsQ0FBQ2hFO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJRCxRQUFRa0MsY0FBY25DLFVBQVUsQ0FBQ0MsTUFBTSxHQUFHQTtRQUM5QyxJQUFJQyxRQUFRaUMsY0FBY25DLFVBQVUsQ0FBQ0UsTUFBTSxHQUFHQTtRQUM5Q0YsV0FBVzRELElBQUk7UUFDZjVELFdBQVcwRCxNQUFNO0lBQ25CO0lBQ0EsSUFBSTNCLGNBQWNOLFFBQVEsQ0FBQyxtQkFBbUI7UUFDNUNHLE9BQU84QyxjQUFjLEdBQUc1QyxhQUFhNEMsY0FBYztJQUNyRDtJQUNBLElBQUkzQyxjQUFjTixRQUFRLENBQUMsbUJBQW1CO1FBQzVDRyxPQUFPK0MsY0FBYyxHQUFHN0MsYUFBYTZDLGNBQWM7SUFDckQ7SUFDQSxJQUFJNUMsY0FBY04sUUFBUSxDQUFDLGNBQWM7UUFDdkNHLE9BQU9nRCxlQUFlLENBQUM5QyxhQUFhK0MsU0FBUyxFQUFFO0lBQ2pEO0lBQ0EsSUFBSWxDLG1CQUFtQkUsZ0JBQWdCO1FBQ3JDakIsT0FBT2tELFdBQVc7SUFDcEI7SUFDQSxJQUFJbEMsa0JBQWtCQyxnQkFBZ0I7UUFDcENqQixPQUFPbUQsVUFBVTtJQUNuQjtJQUNBbkQsT0FBTzhCLE1BQU07QUFDZjtBQUVtTSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmZvLW5leHQvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91cGRhdGUtc3dpcGVyLm1qcz9hM2Q3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIHVuZGVyc2NvcmUgaW4gbmFtZSAtPiB3YXRjaCBmb3IgY2hhbmdlcyAqL1xuY29uc3QgcGFyYW1zTGlzdCA9IFsnZXZlbnRzUHJlZml4JywgJ2luamVjdFN0eWxlcycsICdpbmplY3RTdHlsZXNVcmxzJywgJ21vZHVsZXMnLCAnaW5pdCcsICdfZGlyZWN0aW9uJywgJ29uZVdheU1vdmVtZW50JywgJ3N3aXBlckVsZW1lbnROb2RlTmFtZScsICd0b3VjaEV2ZW50c1RhcmdldCcsICdpbml0aWFsU2xpZGUnLCAnX3NwZWVkJywgJ2Nzc01vZGUnLCAndXBkYXRlT25XaW5kb3dSZXNpemUnLCAncmVzaXplT2JzZXJ2ZXInLCAnbmVzdGVkJywgJ2ZvY3VzYWJsZUVsZW1lbnRzJywgJ19lbmFibGVkJywgJ193aWR0aCcsICdfaGVpZ2h0JywgJ3ByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbicsICd1c2VyQWdlbnQnLCAndXJsJywgJ19lZGdlU3dpcGVEZXRlY3Rpb24nLCAnX2VkZ2VTd2lwZVRocmVzaG9sZCcsICdfZnJlZU1vZGUnLCAnX2F1dG9IZWlnaHQnLCAnc2V0V3JhcHBlclNpemUnLCAndmlydHVhbFRyYW5zbGF0ZScsICdfZWZmZWN0JywgJ2JyZWFrcG9pbnRzJywgJ2JyZWFrcG9pbnRzQmFzZScsICdfc3BhY2VCZXR3ZWVuJywgJ19zbGlkZXNQZXJWaWV3JywgJ21heEJhY2tmYWNlSGlkZGVuU2xpZGVzJywgJ19ncmlkJywgJ19zbGlkZXNQZXJHcm91cCcsICdfc2xpZGVzUGVyR3JvdXBTa2lwJywgJ19zbGlkZXNQZXJHcm91cEF1dG8nLCAnX2NlbnRlcmVkU2xpZGVzJywgJ19jZW50ZXJlZFNsaWRlc0JvdW5kcycsICdfc2xpZGVzT2Zmc2V0QmVmb3JlJywgJ19zbGlkZXNPZmZzZXRBZnRlcicsICdub3JtYWxpemVTbGlkZUluZGV4JywgJ19jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMnLCAnX3dhdGNoT3ZlcmZsb3cnLCAncm91bmRMZW5ndGhzJywgJ3RvdWNoUmF0aW8nLCAndG91Y2hBbmdsZScsICdzaW11bGF0ZVRvdWNoJywgJ19zaG9ydFN3aXBlcycsICdfbG9uZ1N3aXBlcycsICdsb25nU3dpcGVzUmF0aW8nLCAnbG9uZ1N3aXBlc01zJywgJ19mb2xsb3dGaW5nZXInLCAnYWxsb3dUb3VjaE1vdmUnLCAnX3RocmVzaG9sZCcsICd0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24nLCAndG91Y2hTdGFydFByZXZlbnREZWZhdWx0JywgJ3RvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0JywgJ3RvdWNoUmVsZWFzZU9uRWRnZXMnLCAndW5pcXVlTmF2RWxlbWVudHMnLCAnX3Jlc2lzdGFuY2UnLCAnX3Jlc2lzdGFuY2VSYXRpbycsICdfd2F0Y2hTbGlkZXNQcm9ncmVzcycsICdfZ3JhYkN1cnNvcicsICdwcmV2ZW50Q2xpY2tzJywgJ3ByZXZlbnRDbGlja3NQcm9wYWdhdGlvbicsICdfc2xpZGVUb0NsaWNrZWRTbGlkZScsICdfbG9vcCcsICdsb29wQWRkaXRpb25hbFNsaWRlcycsICdsb29wQWRkQmxhbmtTbGlkZXMnLCAnbG9vcFByZXZlbnRzU2xpZGluZycsICdfcmV3aW5kJywgJ19hbGxvd1NsaWRlUHJldicsICdfYWxsb3dTbGlkZU5leHQnLCAnX3N3aXBlSGFuZGxlcicsICdfbm9Td2lwaW5nJywgJ25vU3dpcGluZ0NsYXNzJywgJ25vU3dpcGluZ1NlbGVjdG9yJywgJ3Bhc3NpdmVMaXN0ZW5lcnMnLCAnY29udGFpbmVyTW9kaWZpZXJDbGFzcycsICdzbGlkZUNsYXNzJywgJ3NsaWRlQWN0aXZlQ2xhc3MnLCAnc2xpZGVWaXNpYmxlQ2xhc3MnLCAnc2xpZGVGdWxseVZpc2libGVDbGFzcycsICdzbGlkZU5leHRDbGFzcycsICdzbGlkZVByZXZDbGFzcycsICdzbGlkZUJsYW5rQ2xhc3MnLCAnd3JhcHBlckNsYXNzJywgJ2xhenlQcmVsb2FkZXJDbGFzcycsICdsYXp5UHJlbG9hZFByZXZOZXh0JywgJ3J1bkNhbGxiYWNrc09uSW5pdCcsICdvYnNlcnZlcicsICdvYnNlcnZlUGFyZW50cycsICdvYnNlcnZlU2xpZGVDaGlsZHJlbicsXG4vLyBtb2R1bGVzXG4nYTExeScsICdfYXV0b3BsYXknLCAnX2NvbnRyb2xsZXInLCAnY292ZXJmbG93RWZmZWN0JywgJ2N1YmVFZmZlY3QnLCAnZmFkZUVmZmVjdCcsICdmbGlwRWZmZWN0JywgJ2NyZWF0aXZlRWZmZWN0JywgJ2NhcmRzRWZmZWN0JywgJ2hhc2hOYXZpZ2F0aW9uJywgJ2hpc3RvcnknLCAna2V5Ym9hcmQnLCAnbW91c2V3aGVlbCcsICdfbmF2aWdhdGlvbicsICdfcGFnaW5hdGlvbicsICdwYXJhbGxheCcsICdfc2Nyb2xsYmFyJywgJ190aHVtYnMnLCAndmlydHVhbCcsICd6b29tJywgJ2NvbnRyb2wnXTtcblxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8gIT09IG51bGwgJiYgby5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0JyAmJiAhby5fX3N3aXBlcl9fO1xufVxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc3JjKSB7XG4gIGNvbnN0IG5vRXh0ZW5kID0gWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ107XG4gIE9iamVjdC5rZXlzKHNyYykuZmlsdGVyKGtleSA9PiBub0V4dGVuZC5pbmRleE9mKGtleSkgPCAwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSBpZiAoaXNPYmplY3Qoc3JjW2tleV0pICYmIGlzT2JqZWN0KHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyhzcmNba2V5XSkubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHNyY1trZXldLl9fc3dpcGVyX18pIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSBleHRlbmQodGFyZ2V0W2tleV0sIHNyY1trZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbmVlZHNOYXZpZ2F0aW9uKHBhcmFtcykge1xuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuICByZXR1cm4gcGFyYW1zLm5hdmlnYXRpb24gJiYgdHlwZW9mIHBhcmFtcy5uYXZpZ2F0aW9uLm5leHRFbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBuZWVkc1BhZ2luYXRpb24ocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIHJldHVybiBwYXJhbXMucGFnaW5hdGlvbiAmJiB0eXBlb2YgcGFyYW1zLnBhZ2luYXRpb24uZWwgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gbmVlZHNTY3JvbGxiYXIocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIHJldHVybiBwYXJhbXMuc2Nyb2xsYmFyICYmIHR5cGVvZiBwYXJhbXMuc2Nyb2xsYmFyLmVsID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIHVuaXF1ZUNsYXNzZXMoY2xhc3NOYW1lcykge1xuICBpZiAoY2xhc3NOYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgY2xhc3NOYW1lcyA9ICcnO1xuICB9XG4gIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJykubWFwKGMgPT4gYy50cmltKCkpLmZpbHRlcihjID0+ICEhYyk7XG4gIGNvbnN0IHVuaXF1ZSA9IFtdO1xuICBjbGFzc2VzLmZvckVhY2goYyA9PiB7XG4gICAgaWYgKHVuaXF1ZS5pbmRleE9mKGMpIDwgMCkgdW5pcXVlLnB1c2goYyk7XG4gIH0pO1xuICByZXR1cm4gdW5pcXVlLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGF0dHJUb1Byb3AoYXR0ck5hbWUpIHtcbiAgaWYgKGF0dHJOYW1lID09PSB2b2lkIDApIHtcbiAgICBhdHRyTmFtZSA9ICcnO1xuICB9XG4gIHJldHVybiBhdHRyTmFtZS5yZXBsYWNlKC8tW2Etel0vZywgbCA9PiBsLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgnLScsICcnKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVyQ2xhc3MoY2xhc3NOYW1lKSB7XG4gIGlmIChjbGFzc05hbWUgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzTmFtZSA9ICcnO1xuICB9XG4gIGlmICghY2xhc3NOYW1lKSByZXR1cm4gJ3N3aXBlci13cmFwcGVyJztcbiAgaWYgKCFjbGFzc05hbWUuaW5jbHVkZXMoJ3N3aXBlci13cmFwcGVyJykpIHJldHVybiBgc3dpcGVyLXdyYXBwZXIgJHtjbGFzc05hbWV9YDtcbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3dpcGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgc2xpZGVzLFxuICAgIHBhc3NlZFBhcmFtcyxcbiAgICBjaGFuZ2VkUGFyYW1zLFxuICAgIG5leHRFbCxcbiAgICBwcmV2RWwsXG4gICAgc2Nyb2xsYmFyRWwsXG4gICAgcGFnaW5hdGlvbkVsXG4gIH0gPSBfcmVmO1xuICBjb25zdCB1cGRhdGVQYXJhbXMgPSBjaGFuZ2VkUGFyYW1zLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2RpcmVjdGlvbicgJiYga2V5ICE9PSAnd3JhcHBlckNsYXNzJyk7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXM6IGN1cnJlbnRQYXJhbXMsXG4gICAgcGFnaW5hdGlvbixcbiAgICBuYXZpZ2F0aW9uLFxuICAgIHNjcm9sbGJhcixcbiAgICB2aXJ0dWFsLFxuICAgIHRodW1ic1xuICB9ID0gc3dpcGVyO1xuICBsZXQgbmVlZFRodW1ic0luaXQ7XG4gIGxldCBuZWVkQ29udHJvbGxlckluaXQ7XG4gIGxldCBuZWVkUGFnaW5hdGlvbkluaXQ7XG4gIGxldCBuZWVkU2Nyb2xsYmFySW5pdDtcbiAgbGV0IG5lZWROYXZpZ2F0aW9uSW5pdDtcbiAgbGV0IGxvb3BOZWVkRGVzdHJveTtcbiAgbGV0IGxvb3BOZWVkRW5hYmxlO1xuICBsZXQgbG9vcE5lZWRSZWxvb3A7XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCd0aHVtYnMnKSAmJiBwYXNzZWRQYXJhbXMudGh1bWJzICYmIHBhc3NlZFBhcmFtcy50aHVtYnMuc3dpcGVyICYmIGN1cnJlbnRQYXJhbXMudGh1bWJzICYmICFjdXJyZW50UGFyYW1zLnRodW1icy5zd2lwZXIpIHtcbiAgICBuZWVkVGh1bWJzSW5pdCA9IHRydWU7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ2NvbnRyb2xsZXInKSAmJiBwYXNzZWRQYXJhbXMuY29udHJvbGxlciAmJiBwYXNzZWRQYXJhbXMuY29udHJvbGxlci5jb250cm9sICYmIGN1cnJlbnRQYXJhbXMuY29udHJvbGxlciAmJiAhY3VycmVudFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2wpIHtcbiAgICBuZWVkQ29udHJvbGxlckluaXQgPSB0cnVlO1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdwYWdpbmF0aW9uJykgJiYgcGFzc2VkUGFyYW1zLnBhZ2luYXRpb24gJiYgKHBhc3NlZFBhcmFtcy5wYWdpbmF0aW9uLmVsIHx8IHBhZ2luYXRpb25FbCkgJiYgKGN1cnJlbnRQYXJhbXMucGFnaW5hdGlvbiB8fCBjdXJyZW50UGFyYW1zLnBhZ2luYXRpb24gPT09IGZhbHNlKSAmJiBwYWdpbmF0aW9uICYmICFwYWdpbmF0aW9uLmVsKSB7XG4gICAgbmVlZFBhZ2luYXRpb25Jbml0ID0gdHJ1ZTtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnc2Nyb2xsYmFyJykgJiYgcGFzc2VkUGFyYW1zLnNjcm9sbGJhciAmJiAocGFzc2VkUGFyYW1zLnNjcm9sbGJhci5lbCB8fCBzY3JvbGxiYXJFbCkgJiYgKGN1cnJlbnRQYXJhbXMuc2Nyb2xsYmFyIHx8IGN1cnJlbnRQYXJhbXMuc2Nyb2xsYmFyID09PSBmYWxzZSkgJiYgc2Nyb2xsYmFyICYmICFzY3JvbGxiYXIuZWwpIHtcbiAgICBuZWVkU2Nyb2xsYmFySW5pdCA9IHRydWU7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ25hdmlnYXRpb24nKSAmJiBwYXNzZWRQYXJhbXMubmF2aWdhdGlvbiAmJiAocGFzc2VkUGFyYW1zLm5hdmlnYXRpb24ucHJldkVsIHx8IHByZXZFbCkgJiYgKHBhc3NlZFBhcmFtcy5uYXZpZ2F0aW9uLm5leHRFbCB8fCBuZXh0RWwpICYmIChjdXJyZW50UGFyYW1zLm5hdmlnYXRpb24gfHwgY3VycmVudFBhcmFtcy5uYXZpZ2F0aW9uID09PSBmYWxzZSkgJiYgbmF2aWdhdGlvbiAmJiAhbmF2aWdhdGlvbi5wcmV2RWwgJiYgIW5hdmlnYXRpb24ubmV4dEVsKSB7XG4gICAgbmVlZE5hdmlnYXRpb25Jbml0ID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBkZXN0cm95TW9kdWxlID0gbW9kID0+IHtcbiAgICBpZiAoIXN3aXBlclttb2RdKSByZXR1cm47XG4gICAgc3dpcGVyW21vZF0uZGVzdHJveSgpO1xuICAgIGlmIChtb2QgPT09ICduYXZpZ2F0aW9uJykge1xuICAgICAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgICAgc3dpcGVyW21vZF0ucHJldkVsLnJlbW92ZSgpO1xuICAgICAgICBzd2lwZXJbbW9kXS5uZXh0RWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFyYW1zW21vZF0ucHJldkVsID0gdW5kZWZpbmVkO1xuICAgICAgY3VycmVudFBhcmFtc1ttb2RdLm5leHRFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXBlclttb2RdLnByZXZFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXBlclttb2RdLm5leHRFbCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgICAgc3dpcGVyW21vZF0uZWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFyYW1zW21vZF0uZWwgPSB1bmRlZmluZWQ7XG4gICAgICBzd2lwZXJbbW9kXS5lbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdsb29wJykgJiYgc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIGlmIChjdXJyZW50UGFyYW1zLmxvb3AgJiYgIXBhc3NlZFBhcmFtcy5sb29wKSB7XG4gICAgICBsb29wTmVlZERlc3Ryb3kgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRQYXJhbXMubG9vcCAmJiBwYXNzZWRQYXJhbXMubG9vcCkge1xuICAgICAgbG9vcE5lZWRFbmFibGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb29wTmVlZFJlbG9vcCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGlzT2JqZWN0KGN1cnJlbnRQYXJhbXNba2V5XSkgJiYgaXNPYmplY3QocGFzc2VkUGFyYW1zW2tleV0pKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRQYXJhbXNba2V5XSwgcGFzc2VkUGFyYW1zW2tleV0pO1xuICAgICAgaWYgKChrZXkgPT09ICduYXZpZ2F0aW9uJyB8fCBrZXkgPT09ICdwYWdpbmF0aW9uJyB8fCBrZXkgPT09ICdzY3JvbGxiYXInKSAmJiAnZW5hYmxlZCcgaW4gcGFzc2VkUGFyYW1zW2tleV0gJiYgIXBhc3NlZFBhcmFtc1trZXldLmVuYWJsZWQpIHtcbiAgICAgICAgZGVzdHJveU1vZHVsZShrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhc3NlZFBhcmFtc1trZXldO1xuICAgICAgaWYgKChuZXdWYWx1ZSA9PT0gdHJ1ZSB8fCBuZXdWYWx1ZSA9PT0gZmFsc2UpICYmIChrZXkgPT09ICduYXZpZ2F0aW9uJyB8fCBrZXkgPT09ICdwYWdpbmF0aW9uJyB8fCBrZXkgPT09ICdzY3JvbGxiYXInKSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVzdHJveU1vZHVsZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UGFyYW1zW2tleV0gPSBwYXNzZWRQYXJhbXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAodXBkYXRlUGFyYW1zLmluY2x1ZGVzKCdjb250cm9sbGVyJykgJiYgIW5lZWRDb250cm9sbGVySW5pdCAmJiBzd2lwZXIuY29udHJvbGxlciAmJiBzd2lwZXIuY29udHJvbGxlci5jb250cm9sICYmIGN1cnJlbnRQYXJhbXMuY29udHJvbGxlciAmJiBjdXJyZW50UGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbCkge1xuICAgIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgPSBjdXJyZW50UGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbDtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnY2hpbGRyZW4nKSAmJiBzbGlkZXMgJiYgdmlydHVhbCAmJiBjdXJyZW50UGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgIHZpcnR1YWwuc2xpZGVzID0gc2xpZGVzO1xuICAgIHZpcnR1YWwudXBkYXRlKHRydWUpO1xuICB9IGVsc2UgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ3ZpcnR1YWwnKSAmJiB2aXJ0dWFsICYmIGN1cnJlbnRQYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgaWYgKHNsaWRlcykgdmlydHVhbC5zbGlkZXMgPSBzbGlkZXM7XG4gICAgdmlydHVhbC51cGRhdGUodHJ1ZSk7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ2NoaWxkcmVuJykgJiYgc2xpZGVzICYmIGN1cnJlbnRQYXJhbXMubG9vcCkge1xuICAgIGxvb3BOZWVkUmVsb29wID0gdHJ1ZTtcbiAgfVxuICBpZiAobmVlZFRodW1ic0luaXQpIHtcbiAgICBjb25zdCBpbml0aWFsaXplZCA9IHRodW1icy5pbml0KCk7XG4gICAgaWYgKGluaXRpYWxpemVkKSB0aHVtYnMudXBkYXRlKHRydWUpO1xuICB9XG4gIGlmIChuZWVkQ29udHJvbGxlckluaXQpIHtcbiAgICBzd2lwZXIuY29udHJvbGxlci5jb250cm9sID0gY3VycmVudFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2w7XG4gIH1cbiAgaWYgKG5lZWRQYWdpbmF0aW9uSW5pdCkge1xuICAgIGlmIChzd2lwZXIuaXNFbGVtZW50ICYmICghcGFnaW5hdGlvbkVsIHx8IHR5cGVvZiBwYWdpbmF0aW9uRWwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgcGFnaW5hdGlvbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwYWdpbmF0aW9uRWwuY2xhc3NMaXN0LmFkZCgnc3dpcGVyLXBhZ2luYXRpb24nKTtcbiAgICAgIHBhZ2luYXRpb25FbC5wYXJ0LmFkZCgncGFnaW5hdGlvbicpO1xuICAgICAgc3dpcGVyLmVsLmFwcGVuZENoaWxkKHBhZ2luYXRpb25FbCk7XG4gICAgfVxuICAgIGlmIChwYWdpbmF0aW9uRWwpIGN1cnJlbnRQYXJhbXMucGFnaW5hdGlvbi5lbCA9IHBhZ2luYXRpb25FbDtcbiAgICBwYWdpbmF0aW9uLmluaXQoKTtcbiAgICBwYWdpbmF0aW9uLnJlbmRlcigpO1xuICAgIHBhZ2luYXRpb24udXBkYXRlKCk7XG4gIH1cbiAgaWYgKG5lZWRTY3JvbGxiYXJJbml0KSB7XG4gICAgaWYgKHN3aXBlci5pc0VsZW1lbnQgJiYgKCFzY3JvbGxiYXJFbCB8fCB0eXBlb2Ygc2Nyb2xsYmFyRWwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgc2Nyb2xsYmFyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcm9sbGJhckVsLmNsYXNzTGlzdC5hZGQoJ3N3aXBlci1zY3JvbGxiYXInKTtcbiAgICAgIHNjcm9sbGJhckVsLnBhcnQuYWRkKCdzY3JvbGxiYXInKTtcbiAgICAgIHN3aXBlci5lbC5hcHBlbmRDaGlsZChzY3JvbGxiYXJFbCk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxiYXJFbCkgY3VycmVudFBhcmFtcy5zY3JvbGxiYXIuZWwgPSBzY3JvbGxiYXJFbDtcbiAgICBzY3JvbGxiYXIuaW5pdCgpO1xuICAgIHNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSgpO1xuICB9XG4gIGlmIChuZWVkTmF2aWdhdGlvbkluaXQpIHtcbiAgICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgICAgaWYgKCFuZXh0RWwgfHwgdHlwZW9mIG5leHRFbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmV4dEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG5leHRFbC5jbGFzc0xpc3QuYWRkKCdzd2lwZXItYnV0dG9uLW5leHQnKTtcbiAgICAgICAgbmV4dEVsLmlubmVySFRNTCA9IHN3aXBlci5ob3N0RWwuY29uc3RydWN0b3IubmV4dEJ1dHRvblN2ZztcbiAgICAgICAgbmV4dEVsLnBhcnQuYWRkKCdidXR0b24tbmV4dCcpO1xuICAgICAgICBzd2lwZXIuZWwuYXBwZW5kQ2hpbGQobmV4dEVsKTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJldkVsIHx8IHR5cGVvZiBwcmV2RWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByZXZFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2RWwuY2xhc3NMaXN0LmFkZCgnc3dpcGVyLWJ1dHRvbi1wcmV2Jyk7XG4gICAgICAgIHByZXZFbC5pbm5lckhUTUwgPSBzd2lwZXIuaG9zdEVsLmNvbnN0cnVjdG9yLnByZXZCdXR0b25Tdmc7XG4gICAgICAgIHByZXZFbC5wYXJ0LmFkZCgnYnV0dG9uLXByZXYnKTtcbiAgICAgICAgc3dpcGVyLmVsLmFwcGVuZENoaWxkKHByZXZFbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXh0RWwpIGN1cnJlbnRQYXJhbXMubmF2aWdhdGlvbi5uZXh0RWwgPSBuZXh0RWw7XG4gICAgaWYgKHByZXZFbCkgY3VycmVudFBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCA9IHByZXZFbDtcbiAgICBuYXZpZ2F0aW9uLmluaXQoKTtcbiAgICBuYXZpZ2F0aW9uLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdhbGxvd1NsaWRlTmV4dCcpKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gcGFzc2VkUGFyYW1zLmFsbG93U2xpZGVOZXh0O1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdhbGxvd1NsaWRlUHJldicpKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gcGFzc2VkUGFyYW1zLmFsbG93U2xpZGVQcmV2O1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdkaXJlY3Rpb24nKSkge1xuICAgIHN3aXBlci5jaGFuZ2VEaXJlY3Rpb24ocGFzc2VkUGFyYW1zLmRpcmVjdGlvbiwgZmFsc2UpO1xuICB9XG4gIGlmIChsb29wTmVlZERlc3Ryb3kgfHwgbG9vcE5lZWRSZWxvb3ApIHtcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgfVxuICBpZiAobG9vcE5lZWRFbmFibGUgfHwgbG9vcE5lZWRSZWxvb3ApIHtcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICB9XG4gIHN3aXBlci51cGRhdGUoKTtcbn1cblxuZXhwb3J0IHsgbmVlZHNQYWdpbmF0aW9uIGFzIGEsIG5lZWRzU2Nyb2xsYmFyIGFzIGIsIGF0dHJUb1Byb3AgYXMgYywgdW5pcXVlQ2xhc3NlcyBhcyBkLCBleHRlbmQgYXMgZSwgaXNPYmplY3QgYXMgaSwgbmVlZHNOYXZpZ2F0aW9uIGFzIG4sIHBhcmFtc0xpc3QgYXMgcCwgdXBkYXRlU3dpcGVyIGFzIHUsIHdyYXBwZXJDbGFzcyBhcyB3IH07XG4iXSwibmFtZXMiOlsicGFyYW1zTGlzdCIsImlzT2JqZWN0IiwibyIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJfX3N3aXBlcl9fIiwiZXh0ZW5kIiwidGFyZ2V0Iiwic3JjIiwibm9FeHRlbmQiLCJrZXlzIiwiZmlsdGVyIiwia2V5IiwiaW5kZXhPZiIsImZvckVhY2giLCJsZW5ndGgiLCJuZWVkc05hdmlnYXRpb24iLCJwYXJhbXMiLCJuYXZpZ2F0aW9uIiwibmV4dEVsIiwicHJldkVsIiwibmVlZHNQYWdpbmF0aW9uIiwicGFnaW5hdGlvbiIsImVsIiwibmVlZHNTY3JvbGxiYXIiLCJzY3JvbGxiYXIiLCJ1bmlxdWVDbGFzc2VzIiwiY2xhc3NOYW1lcyIsImNsYXNzZXMiLCJzcGxpdCIsIm1hcCIsImMiLCJ0cmltIiwidW5pcXVlIiwicHVzaCIsImpvaW4iLCJhdHRyVG9Qcm9wIiwiYXR0ck5hbWUiLCJyZXBsYWNlIiwibCIsInRvVXBwZXJDYXNlIiwid3JhcHBlckNsYXNzIiwiY2xhc3NOYW1lIiwiaW5jbHVkZXMiLCJ1cGRhdGVTd2lwZXIiLCJfcmVmIiwic3dpcGVyIiwic2xpZGVzIiwicGFzc2VkUGFyYW1zIiwiY2hhbmdlZFBhcmFtcyIsInNjcm9sbGJhckVsIiwicGFnaW5hdGlvbkVsIiwidXBkYXRlUGFyYW1zIiwiY3VycmVudFBhcmFtcyIsInZpcnR1YWwiLCJ0aHVtYnMiLCJuZWVkVGh1bWJzSW5pdCIsIm5lZWRDb250cm9sbGVySW5pdCIsIm5lZWRQYWdpbmF0aW9uSW5pdCIsIm5lZWRTY3JvbGxiYXJJbml0IiwibmVlZE5hdmlnYXRpb25Jbml0IiwibG9vcE5lZWREZXN0cm95IiwibG9vcE5lZWRFbmFibGUiLCJsb29wTmVlZFJlbG9vcCIsImNvbnRyb2xsZXIiLCJjb250cm9sIiwiZGVzdHJveU1vZHVsZSIsIm1vZCIsImRlc3Ryb3kiLCJpc0VsZW1lbnQiLCJyZW1vdmUiLCJ1bmRlZmluZWQiLCJsb29wIiwiYXNzaWduIiwiZW5hYmxlZCIsIm5ld1ZhbHVlIiwidXBkYXRlIiwiaW5pdGlhbGl6ZWQiLCJpbml0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwicGFydCIsImFwcGVuZENoaWxkIiwicmVuZGVyIiwidXBkYXRlU2l6ZSIsInNldFRyYW5zbGF0ZSIsImlubmVySFRNTCIsImhvc3RFbCIsIm5leHRCdXR0b25TdmciLCJwcmV2QnV0dG9uU3ZnIiwiYWxsb3dTbGlkZU5leHQiLCJhbGxvd1NsaWRlUHJldiIsImNoYW5nZURpcmVjdGlvbiIsImRpcmVjdGlvbiIsImxvb3BEZXN0cm95IiwibG9vcENyZWF0ZSIsImEiLCJiIiwiZCIsImUiLCJpIiwibiIsInAiLCJ1IiwidyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/update-swiper.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/utils.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/shared/utils.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ elementParents),\n/* harmony export */   b: () => (/* binding */ elementOffset),\n/* harmony export */   c: () => (/* binding */ createElement),\n/* harmony export */   d: () => (/* binding */ now),\n/* harmony export */   e: () => (/* binding */ elementChildren),\n/* harmony export */   f: () => (/* binding */ elementOuterSize),\n/* harmony export */   g: () => (/* binding */ getSlideTransformEl),\n/* harmony export */   h: () => (/* binding */ elementIndex),\n/* harmony export */   i: () => (/* binding */ classesToTokens),\n/* harmony export */   j: () => (/* binding */ getTranslate),\n/* harmony export */   k: () => (/* binding */ elementTransitionEnd),\n/* harmony export */   l: () => (/* binding */ isObject),\n/* harmony export */   m: () => (/* binding */ makeElementsArray),\n/* harmony export */   n: () => (/* binding */ nextTick),\n/* harmony export */   o: () => (/* binding */ elementStyle),\n/* harmony export */   p: () => (/* binding */ elementNextAll),\n/* harmony export */   q: () => (/* binding */ elementPrevAll),\n/* harmony export */   r: () => (/* binding */ animateCSSModeScroll),\n/* harmony export */   s: () => (/* binding */ setCSSProperty),\n/* harmony export */   t: () => (/* binding */ showWarning),\n/* harmony export */   u: () => (/* binding */ extend),\n/* harmony export */   v: () => (/* binding */ deleteProps)\n/* harmony export */ });\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs\");\n\nfunction classesToTokens(classes) {\n    if (classes === void 0) {\n        classes = \"\";\n    }\n    return classes.trim().split(\" \").filter((c)=>!!c.trim());\n}\nfunction deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach((key)=>{\n        try {\n            object[key] = null;\n        } catch (e) {\n        // no getter for object\n        }\n        try {\n            delete object[key];\n        } catch (e) {\n        // something got wrong\n        }\n    });\n}\nfunction nextTick(callback, delay) {\n    if (delay === void 0) {\n        delay = 0;\n    }\n    return setTimeout(callback, delay);\n}\nfunction now() {\n    return Date.now();\n}\nfunction getComputedStyle(el) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    let style;\n    if (window1.getComputedStyle) {\n        style = window1.getComputedStyle(el, null);\n    }\n    if (!style && el.currentStyle) {\n        style = el.currentStyle;\n    }\n    if (!style) {\n        style = el.style;\n    }\n    return style;\n}\nfunction getTranslate(el, axis) {\n    if (axis === void 0) {\n        axis = \"x\";\n    }\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n    const curStyle = getComputedStyle(el);\n    if (window1.WebKitCSSMatrix) {\n        curTransform = curStyle.transform || curStyle.webkitTransform;\n        if (curTransform.split(\",\").length > 6) {\n            curTransform = curTransform.split(\", \").map((a)=>a.replace(\",\", \".\")).join(\", \");\n        }\n        // Some old versions of Webkit choke when 'none' is passed; pass\n        // empty string instead in this case\n        transformMatrix = new window1.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n    } else {\n        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n        matrix = transformMatrix.toString().split(\",\");\n    }\n    if (axis === \"x\") {\n        // Latest Chrome and webkits Fix\n        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n        else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === \"y\") {\n        // Latest Chrome and webkits Fix\n        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n        else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n}\nfunction isObject(o) {\n    return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n}\nfunction isNode(node) {\n    // eslint-disable-next-line\n    if (false) {}\n    return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend() {\n    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n    const noExtend = [\n        \"__proto__\",\n        \"constructor\",\n        \"prototype\"\n    ];\n    for(let i = 1; i < arguments.length; i += 1){\n        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n            const keysArray = Object.keys(Object(nextSource)).filter((key)=>noExtend.indexOf(key) < 0);\n            for(let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){\n                const nextKey = keysArray[nextIndex];\n                const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                if (desc !== undefined && desc.enumerable) {\n                    if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                        if (nextSource[nextKey].__swiper__) {\n                            to[nextKey] = nextSource[nextKey];\n                        } else {\n                            extend(to[nextKey], nextSource[nextKey]);\n                        }\n                    } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                        to[nextKey] = {};\n                        if (nextSource[nextKey].__swiper__) {\n                            to[nextKey] = nextSource[nextKey];\n                        } else {\n                            extend(to[nextKey], nextSource[nextKey]);\n                        }\n                    } else {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n    }\n    return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n    el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll(_ref) {\n    let { swiper, targetPosition, side } = _ref;\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const startPosition = -swiper.translate;\n    let startTime = null;\n    let time;\n    const duration = swiper.params.speed;\n    swiper.wrapperEl.style.scrollSnapType = \"none\";\n    window1.cancelAnimationFrame(swiper.cssModeFrameID);\n    const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n    const isOutOfBound = (current, target)=>{\n        return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n    };\n    const animate = ()=>{\n        time = new Date().getTime();\n        if (startTime === null) {\n            startTime = time;\n        }\n        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n        if (isOutOfBound(currentPosition, targetPosition)) {\n            currentPosition = targetPosition;\n        }\n        swiper.wrapperEl.scrollTo({\n            [side]: currentPosition\n        });\n        if (isOutOfBound(currentPosition, targetPosition)) {\n            swiper.wrapperEl.style.overflow = \"hidden\";\n            swiper.wrapperEl.style.scrollSnapType = \"\";\n            setTimeout(()=>{\n                swiper.wrapperEl.style.overflow = \"\";\n                swiper.wrapperEl.scrollTo({\n                    [side]: currentPosition\n                });\n            });\n            window1.cancelAnimationFrame(swiper.cssModeFrameID);\n            return;\n        }\n        swiper.cssModeFrameID = window1.requestAnimationFrame(animate);\n    };\n    animate();\n}\nfunction getSlideTransformEl(slideEl) {\n    return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(\".swiper-slide-transform\") || slideEl;\n}\nfunction elementChildren(element, selector) {\n    if (selector === void 0) {\n        selector = \"\";\n    }\n    return [\n        ...element.children\n    ].filter((el)=>el.matches(selector));\n}\nfunction showWarning(text) {\n    try {\n        console.warn(text);\n        return;\n    } catch (err) {\n    // err\n    }\n}\nfunction createElement(tag, classes) {\n    if (classes === void 0) {\n        classes = [];\n    }\n    const el = document.createElement(tag);\n    el.classList.add(...Array.isArray(classes) ? classes : classesToTokens(classes));\n    return el;\n}\nfunction elementOffset(el) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    const box = el.getBoundingClientRect();\n    const body = document1.body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === window1 ? window1.scrollY : el.scrollTop;\n    const scrollLeft = el === window1 ? window1.scrollX : el.scrollLeft;\n    return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft\n    };\n}\nfunction elementPrevAll(el, selector) {\n    const prevEls = [];\n    while(el.previousElementSibling){\n        const prev = el.previousElementSibling; // eslint-disable-line\n        if (selector) {\n            if (prev.matches(selector)) prevEls.push(prev);\n        } else prevEls.push(prev);\n        el = prev;\n    }\n    return prevEls;\n}\nfunction elementNextAll(el, selector) {\n    const nextEls = [];\n    while(el.nextElementSibling){\n        const next = el.nextElementSibling; // eslint-disable-line\n        if (selector) {\n            if (next.matches(selector)) nextEls.push(next);\n        } else nextEls.push(next);\n        el = next;\n    }\n    return nextEls;\n}\nfunction elementStyle(el, prop) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    return window1.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n    let child = el;\n    let i;\n    if (child) {\n        i = 0;\n        // eslint-disable-next-line\n        while((child = child.previousSibling) !== null){\n            if (child.nodeType === 1) i += 1;\n        }\n        return i;\n    }\n    return undefined;\n}\nfunction elementParents(el, selector) {\n    const parents = []; // eslint-disable-line\n    let parent = el.parentElement; // eslint-disable-line\n    while(parent){\n        if (selector) {\n            if (parent.matches(selector)) parents.push(parent);\n        } else {\n            parents.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n    function fireCallBack(e) {\n        if (e.target !== el) return;\n        callback.call(el, e);\n        el.removeEventListener(\"transitionend\", fireCallBack);\n    }\n    if (callback) {\n        el.addEventListener(\"transitionend\", fireCallBack);\n    }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    if (includeMargins) {\n        return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n    }\n    return el.offsetWidth;\n}\nfunction makeElementsArray(el) {\n    return (Array.isArray(el) ? el : [\n        el\n    ]).filter((e)=>!!e);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91dGlscy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0U7QUFFeEUsU0FBU0ksZ0JBQWdCQyxPQUFPO0lBQzlCLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVO0lBQ1o7SUFDQSxPQUFPQSxRQUFRQyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLENBQUFBLElBQUssQ0FBQyxDQUFDQSxFQUFFSCxJQUFJO0FBQ3ZEO0FBRUEsU0FBU0ksWUFBWUMsR0FBRztJQUN0QixNQUFNQyxTQUFTRDtJQUNmRSxPQUFPQyxJQUFJLENBQUNGLFFBQVFHLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDMUIsSUFBSTtZQUNGSixNQUFNLENBQUNJLElBQUksR0FBRztRQUNoQixFQUFFLE9BQU9DLEdBQUc7UUFDVix1QkFBdUI7UUFDekI7UUFDQSxJQUFJO1lBQ0YsT0FBT0wsTUFBTSxDQUFDSSxJQUFJO1FBQ3BCLEVBQUUsT0FBT0MsR0FBRztRQUNWLHNCQUFzQjtRQUN4QjtJQUNGO0FBQ0Y7QUFDQSxTQUFTQyxTQUFTQyxRQUFRLEVBQUVDLEtBQUs7SUFDL0IsSUFBSUEsVUFBVSxLQUFLLEdBQUc7UUFDcEJBLFFBQVE7SUFDVjtJQUNBLE9BQU9DLFdBQVdGLFVBQVVDO0FBQzlCO0FBQ0EsU0FBU0U7SUFDUCxPQUFPQyxLQUFLRCxHQUFHO0FBQ2pCO0FBQ0EsU0FBU0UsaUJBQWlCQyxFQUFFO0lBQzFCLE1BQU1DLFVBQVN6QixzREFBU0E7SUFDeEIsSUFBSTBCO0lBQ0osSUFBSUQsUUFBT0YsZ0JBQWdCLEVBQUU7UUFDM0JHLFFBQVFELFFBQU9GLGdCQUFnQixDQUFDQyxJQUFJO0lBQ3RDO0lBQ0EsSUFBSSxDQUFDRSxTQUFTRixHQUFHRyxZQUFZLEVBQUU7UUFDN0JELFFBQVFGLEdBQUdHLFlBQVk7SUFDekI7SUFDQSxJQUFJLENBQUNELE9BQU87UUFDVkEs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QUFpQkQ7SUFDMUM7SUFDQSxJQUFJbkosVUFBVTtRQUNaTSxHQUFHK0ksZ0JBQWdCLENBQUMsaUJBQWlCRjtJQUN2QztBQUNGO0FBQ0EsU0FBU0csaUJBQWlCaEosRUFBRSxFQUFFaUosSUFBSSxFQUFFQyxjQUFjO0lBQ2hELE1BQU1qSixVQUFTekIsc0RBQVNBO0lBQ3hCLElBQUkwSyxnQkFBZ0I7UUFDbEIsT0FBT2xKLEVBQUUsQ0FBQ2lKLFNBQVMsVUFBVSxnQkFBZ0IsZUFBZSxHQUFHekgsV0FBV3ZCLFFBQU9GLGdCQUFnQixDQUFDQyxJQUFJLE1BQU1xQixnQkFBZ0IsQ0FBQzRILFNBQVMsVUFBVSxpQkFBaUIsaUJBQWlCekgsV0FBV3ZCLFFBQU9GLGdCQUFnQixDQUFDQyxJQUFJLE1BQU1xQixnQkFBZ0IsQ0FBQzRILFNBQVMsVUFBVSxnQkFBZ0I7SUFDclI7SUFDQSxPQUFPakosR0FBR21KLFdBQVc7QUFDdkI7QUFDQSxTQUFTQyxrQkFBa0JwSixFQUFFO0lBQzNCLE9BQU8sQ0FBQzRHLE1BQU1DLE9BQU8sQ0FBQzdHLE1BQU1BLEtBQUs7UUFBQ0E7S0FBRyxFQUFFakIsTUFBTSxDQUFDUyxDQUFBQSxJQUFLLENBQUMsQ0FBQ0E7QUFDdkQ7QUFFbWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5mby1uZXh0Ly4vbm9kZV9tb2R1bGVzL3N3aXBlci9zaGFyZWQvdXRpbHMubWpzPzlkMTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYSBhcyBnZXRXaW5kb3csIGcgYXMgZ2V0RG9jdW1lbnQgfSBmcm9tICcuL3Nzci13aW5kb3cuZXNtLm1qcyc7XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb1Rva2VucyhjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0gJyc7XG4gIH1cbiAgcmV0dXJuIGNsYXNzZXMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKGMgPT4gISFjLnRyaW0oKSk7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iaikge1xuICBjb25zdCBvYmplY3QgPSBvYmo7XG4gIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBvYmplY3Rba2V5XSA9IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbm8gZ2V0dGVyIGZvciBvYmplY3RcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSBvYmplY3Rba2V5XTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzb21ldGhpbmcgZ290IHdyb25nXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrLCBkZWxheSkge1xuICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgIGRlbGF5ID0gMDtcbiAgfVxuICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXkpO1xufVxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWwpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGxldCBzdHlsZTtcbiAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gIH1cbiAgaWYgKCFzdHlsZSAmJiBlbC5jdXJyZW50U3R5bGUpIHtcbiAgICBzdHlsZSA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgfVxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBlbC5zdHlsZTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoZWwsIGF4aXMpIHtcbiAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuICAgIGF4aXMgPSAneCc7XG4gIH1cbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGxldCBtYXRyaXg7XG4gIGxldCBjdXJUcmFuc2Zvcm07XG4gIGxldCB0cmFuc2Zvcm1NYXRyaXg7XG4gIGNvbnN0IGN1clN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSB7XG4gICAgY3VyVHJhbnNmb3JtID0gY3VyU3R5bGUudHJhbnNmb3JtIHx8IGN1clN0eWxlLndlYmtpdFRyYW5zZm9ybTtcbiAgICBpZiAoY3VyVHJhbnNmb3JtLnNwbGl0KCcsJykubGVuZ3RoID4gNikge1xuICAgICAgY3VyVHJhbnNmb3JtID0gY3VyVHJhbnNmb3JtLnNwbGl0KCcsICcpLm1hcChhID0+IGEucmVwbGFjZSgnLCcsICcuJykpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIFdlYmtpdCBjaG9rZSB3aGVuICdub25lJyBpcyBwYXNzZWQ7IHBhc3NcbiAgICAvLyBlbXB0eSBzdHJpbmcgaW5zdGVhZCBpbiB0aGlzIGNhc2VcbiAgICB0cmFuc2Zvcm1NYXRyaXggPSBuZXcgd2luZG93LldlYktpdENTU01hdHJpeChjdXJUcmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogY3VyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2Zvcm1NYXRyaXggPSBjdXJTdHlsZS5Nb3pUcmFuc2Zvcm0gfHwgY3VyU3R5bGUuT1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5Nc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5tc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykucmVwbGFjZSgndHJhbnNsYXRlKCcsICdtYXRyaXgoMSwgMCwgMCwgMSwnKTtcbiAgICBtYXRyaXggPSB0cmFuc2Zvcm1NYXRyaXgudG9TdHJpbmcoKS5zcGxpdCgnLCcpO1xuICB9XG4gIGlmIChheGlzID09PSAneCcpIHtcbiAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSBjdXJUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1NYXRyaXgubTQxO1xuICAgIC8vIENyYXp5IElFMTAgTWF0cml4XG4gICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEyXSk7XG4gICAgLy8gTm9ybWFsIEJyb3dzZXJzXG4gICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs0XSk7XG4gIH1cbiAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgIC8vIExhdGVzdCBDaHJvbWUgYW5kIHdlYmtpdHMgRml4XG4gICAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDI7XG4gICAgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID09PSAxNikgY3VyVHJhbnNmb3JtID0gcGFyc2VGbG9hdChtYXRyaXhbMTNdKTtcbiAgICAvLyBOb3JtYWwgQnJvd3NlcnNcbiAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzVdKTtcbiAgfVxuICByZXR1cm4gY3VyVHJhbnNmb3JtIHx8IDA7XG59XG5mdW5jdGlvbiBpc09iamVjdChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLmNvbnN0cnVjdG9yICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkgPT09ICdPYmplY3QnO1xufVxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gMTEpO1xufVxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICBjb25zdCB0byA9IE9iamVjdChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pO1xuICBjb25zdCBub0V4dGVuZCA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IG5leHRTb3VyY2UgPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBuZXh0U291cmNlICE9PSBudWxsICYmICFpc05vZGUobmV4dFNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSkuZmlsdGVyKGtleSA9PiBub0V4dGVuZC5pbmRleE9mKGtleSkgPCAwKTtcbiAgICAgIGZvciAobGV0IG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4ICs9IDEpIHtcbiAgICAgICAgY29uc3QgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZVtuZXh0S2V5XS5fX3N3aXBlcl9fKSB7XG4gICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuZCh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICB0b1tuZXh0S2V5XSA9IHt9O1xuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VbbmV4dEtleV0uX19zd2lwZXJfXykge1xuICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbmQodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbmZ1bmN0aW9uIHNldENTU1Byb3BlcnR5KGVsLCB2YXJOYW1lLCB2YXJWYWx1ZSkge1xuICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSh2YXJOYW1lLCB2YXJWYWx1ZSk7XG59XG5mdW5jdGlvbiBhbmltYXRlQ1NTTW9kZVNjcm9sbChfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIHNpZGVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBzdGFydFBvc2l0aW9uID0gLXN3aXBlci50cmFuc2xhdGU7XG4gIGxldCBzdGFydFRpbWUgPSBudWxsO1xuICBsZXQgdGltZTtcbiAgY29uc3QgZHVyYXRpb24gPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJ25vbmUnO1xuICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoc3dpcGVyLmNzc01vZGVGcmFtZUlEKTtcbiAgY29uc3QgZGlyID0gdGFyZ2V0UG9zaXRpb24gPiBzdGFydFBvc2l0aW9uID8gJ25leHQnIDogJ3ByZXYnO1xuICBjb25zdCBpc091dE9mQm91bmQgPSAoY3VycmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgcmV0dXJuIGRpciA9PT0gJ25leHQnICYmIGN1cnJlbnQgPj0gdGFyZ2V0IHx8IGRpciA9PT0gJ3ByZXYnICYmIGN1cnJlbnQgPD0gdGFyZ2V0O1xuICB9O1xuICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKCh0aW1lIC0gc3RhcnRUaW1lKSAvIGR1cmF0aW9uLCAxKSwgMCk7XG4gICAgY29uc3QgZWFzZVByb2dyZXNzID0gMC41IC0gTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDI7XG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gKyBlYXNlUHJvZ3Jlc3MgKiAodGFyZ2V0UG9zaXRpb24gLSBzdGFydFBvc2l0aW9uKTtcbiAgICBpZiAoaXNPdXRPZkJvdW5kKGN1cnJlbnRQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pKSB7XG4gICAgICBjdXJyZW50UG9zaXRpb24gPSB0YXJnZXRQb3NpdGlvbjtcbiAgICB9XG4gICAgc3dpcGVyLndyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICBbc2lkZV06IGN1cnJlbnRQb3NpdGlvblxuICAgIH0pO1xuICAgIGlmIChpc091dE9mQm91bmQoY3VycmVudFBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbikpIHtcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnJztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgIHN3aXBlci53cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICAgIFtzaWRlXTogY3VycmVudFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoc3dpcGVyLmNzc01vZGVGcmFtZUlEKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpcGVyLmNzc01vZGVGcmFtZUlEID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgfTtcbiAgYW5pbWF0ZSgpO1xufVxuZnVuY3Rpb24gZ2V0U2xpZGVUcmFuc2Zvcm1FbChzbGlkZUVsKSB7XG4gIHJldHVybiBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtdHJhbnNmb3JtJykgfHwgc2xpZGVFbC5zaGFkb3dSb290ICYmIHNsaWRlRWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXRyYW5zZm9ybScpIHx8IHNsaWRlRWw7XG59XG5mdW5jdGlvbiBlbGVtZW50Q2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RvciA9ICcnO1xuICB9XG4gIHJldHVybiBbLi4uZWxlbWVudC5jaGlsZHJlbl0uZmlsdGVyKGVsID0+IGVsLm1hdGNoZXMoc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIHNob3dXYXJuaW5nKHRleHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgcmV0dXJuO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBlcnJcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzZXMpIHtcbiAgaWYgKGNsYXNzZXMgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzZXMgPSBbXTtcbiAgfVxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi4oQXJyYXkuaXNBcnJheShjbGFzc2VzKSA/IGNsYXNzZXMgOiBjbGFzc2VzVG9Ub2tlbnMoY2xhc3NlcykpKTtcbiAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZWxlbWVudE9mZnNldChlbCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IGNsaWVudFRvcCA9IGVsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICBjb25zdCBjbGllbnRMZWZ0ID0gZWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gZWwgPT09IHdpbmRvdyA/IHdpbmRvdy5zY3JvbGxZIDogZWwuc2Nyb2xsVG9wO1xuICBjb25zdCBzY3JvbGxMZWZ0ID0gZWwgPT09IHdpbmRvdyA/IHdpbmRvdy5zY3JvbGxYIDogZWwuc2Nyb2xsTGVmdDtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3AsXG4gICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdFxuICB9O1xufVxuZnVuY3Rpb24gZWxlbWVudFByZXZBbGwoZWwsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IHByZXZFbHMgPSBbXTtcbiAgd2hpbGUgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBjb25zdCBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHByZXYubWF0Y2hlcyhzZWxlY3RvcikpIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICB9IGVsc2UgcHJldkVscy5wdXNoKHByZXYpO1xuICAgIGVsID0gcHJldjtcbiAgfVxuICByZXR1cm4gcHJldkVscztcbn1cbmZ1bmN0aW9uIGVsZW1lbnROZXh0QWxsKGVsLCBzZWxlY3Rvcikge1xuICBjb25zdCBuZXh0RWxzID0gW107XG4gIHdoaWxlIChlbC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBjb25zdCBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkgbmV4dEVscy5wdXNoKG5leHQpO1xuICAgIH0gZWxzZSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgZWwgPSBuZXh0O1xuICB9XG4gIHJldHVybiBuZXh0RWxzO1xufVxuZnVuY3Rpb24gZWxlbWVudFN0eWxlKGVsLCBwcm9wKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG59XG5mdW5jdGlvbiBlbGVtZW50SW5kZXgoZWwpIHtcbiAgbGV0IGNoaWxkID0gZWw7XG4gIGxldCBpO1xuICBpZiAoY2hpbGQpIHtcbiAgICBpID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB3aGlsZSAoKGNoaWxkID0gY2hpbGQucHJldmlvdXNTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSBpICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBlbGVtZW50UGFyZW50cyhlbCwgc2VsZWN0b3IpIHtcbiAgY29uc3QgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChwYXJlbnQubWF0Y2hlcyhzZWxlY3RvcikpIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5mdW5jdGlvbiBlbGVtZW50VHJhbnNpdGlvbkVuZChlbCwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgIT09IGVsKSByZXR1cm47XG4gICAgY2FsbGJhY2suY2FsbChlbCwgZSk7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZpcmVDYWxsQmFjayk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZpcmVDYWxsQmFjayk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnRPdXRlclNpemUoZWwsIHNpemUsIGluY2x1ZGVNYXJnaW5zKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICByZXR1cm4gZWxbc2l6ZSA9PT0gJ3dpZHRoJyA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J10gKyBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHNpemUgPT09ICd3aWR0aCcgPyAnbWFyZ2luLXJpZ2h0JyA6ICdtYXJnaW4tdG9wJykpICsgcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShzaXplID09PSAnd2lkdGgnID8gJ21hcmdpbi1sZWZ0JyA6ICdtYXJnaW4tYm90dG9tJykpO1xuICB9XG4gIHJldHVybiBlbC5vZmZzZXRXaWR0aDtcbn1cbmZ1bmN0aW9uIG1ha2VFbGVtZW50c0FycmF5KGVsKSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShlbCkgPyBlbCA6IFtlbF0pLmZpbHRlcihlID0+ICEhZSk7XG59XG5cbmV4cG9ydCB7IGVsZW1lbnRQYXJlbnRzIGFzIGEsIGVsZW1lbnRPZmZzZXQgYXMgYiwgY3JlYXRlRWxlbWVudCBhcyBjLCBub3cgYXMgZCwgZWxlbWVudENoaWxkcmVuIGFzIGUsIGVsZW1lbnRPdXRlclNpemUgYXMgZiwgZ2V0U2xpZGVUcmFuc2Zvcm1FbCBhcyBnLCBlbGVtZW50SW5kZXggYXMgaCwgY2xhc3Nlc1RvVG9rZW5zIGFzIGksIGdldFRyYW5zbGF0ZSBhcyBqLCBlbGVtZW50VHJhbnNpdGlvbkVuZCBhcyBrLCBpc09iamVjdCBhcyBsLCBtYWtlRWxlbWVudHNBcnJheSBhcyBtLCBuZXh0VGljayBhcyBuLCBlbGVtZW50U3R5bGUgYXMgbywgZWxlbWVudE5leHRBbGwgYXMgcCwgZWxlbWVudFByZXZBbGwgYXMgcSwgYW5pbWF0ZUNTU01vZGVTY3JvbGwgYXMgciwgc2V0Q1NTUHJvcGVydHkgYXMgcywgc2hvd1dhcm5pbmcgYXMgdCwgZXh0ZW5kIGFzIHUsIGRlbGV0ZVByb3BzIGFzIHYgfTtcbiJdLCJuYW1lcyI6WyJhIiwiZ2V0V2luZG93IiwiZyIsImdldERvY3VtZW50IiwiY2xhc3Nlc1RvVG9rZW5zIiwiY2xhc3NlcyIsInRyaW0iLCJzcGxpdCIsImZpbHRlciIsImMiLCJkZWxldGVQcm9wcyIsIm9iaiIsIm9iamVjdCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiZSIsIm5leHRUaWNrIiwiY2FsbGJhY2siLCJkZWxheSIsInNldFRpbWVvdXQiLCJub3ciLCJEYXRlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImVsIiwid2luZG93Iiwic3R5bGUiLCJjdXJyZW50U3R5bGUiLCJnZXRUcmFuc2xhdGUiLCJheGlzIiwibWF0cml4IiwiY3VyVHJhbnNmb3JtIiwidHJhbnNmb3JtTWF0cml4IiwiY3VyU3R5bGUiLCJXZWJLaXRDU1NNYXRyaXgiLCJ0cmFuc2Zvcm0iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJsZW5ndGgiLCJtYXAiLCJyZXBsYWNlIiwiam9pbiIsIk1velRyYW5zZm9ybSIsIk9UcmFuc2Zvcm0iLCJNc1RyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRvU3RyaW5nIiwibTQxIiwicGFyc2VGbG9hdCIsIm00MiIsImlzT2JqZWN0IiwibyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiY2FsbCIsInNsaWNlIiwiaXNOb2RlIiwibm9kZSIsIkhUTUxFbGVtZW50Iiwibm9kZVR5cGUiLCJleHRlbmQiLCJ0byIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIm5vRXh0ZW5kIiwiaSIsIm5leHRTb3VyY2UiLCJrZXlzQXJyYXkiLCJpbmRleE9mIiwibmV4dEluZGV4IiwibGVuIiwibmV4dEtleSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX19zd2lwZXJfXyIsInNldENTU1Byb3BlcnR5IiwidmFyTmFtZSIsInZhclZhbHVlIiwic2V0UHJvcGVydHkiLCJhbmltYXRlQ1NTTW9kZVNjcm9sbCIsIl9yZWYiLCJzd2lwZXIiLCJ0YXJnZXRQb3NpdGlvbiIsInNpZGUiLCJzdGFydFBvc2l0aW9uIiwidHJhbnNsYXRlIiwic3RhcnRUaW1lIiwidGltZSIsImR1cmF0aW9uIiwicGFyYW1zIiwic3BlZWQiLCJ3cmFwcGVyRWwiLCJzY3JvbGxTbmFwVHlwZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY3NzTW9kZUZyYW1lSUQiLCJkaXIiLCJpc091dE9mQm91bmQiLCJjdXJyZW50IiwidGFyZ2V0IiwiYW5pbWF0ZSIsImdldFRpbWUiLCJwcm9ncmVzcyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJlYXNlUHJvZ3Jlc3MiLCJjb3MiLCJQSSIsImN1cnJlbnRQb3NpdGlvbiIsInNjcm9sbFRvIiwib3ZlcmZsb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnZXRTbGlkZVRyYW5zZm9ybUVsIiwic2xpZGVFbCIsInF1ZXJ5U2VsZWN0b3IiLCJzaGFkb3dSb290IiwiZWxlbWVudENoaWxkcmVuIiwiZWxlbWVudCIsInNlbGVjdG9yIiwiY2hpbGRyZW4iLCJtYXRjaGVzIiwic2hvd1dhcm5pbmciLCJ0ZXh0IiwiY29uc29sZSIsIndhcm4iLCJlcnIiLCJjcmVhdGVFbGVtZW50IiwidGFnIiwiZG9jdW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJBcnJheSIsImlzQXJyYXkiLCJlbGVtZW50T2Zmc2V0IiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm9keSIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJzY3JvbGxUb3AiLCJzY3JvbGxZIiwic2Nyb2xsTGVmdCIsInNjcm9sbFgiLCJ0b3AiLCJsZWZ0IiwiZWxlbWVudFByZXZBbGwiLCJwcmV2RWxzIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInByZXYiLCJwdXNoIiwiZWxlbWVudE5leHRBbGwiLCJuZXh0RWxzIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwibmV4dCIsImVsZW1lbnRTdHlsZSIsInByb3AiLCJlbGVtZW50SW5kZXgiLCJjaGlsZCIsInByZXZpb3VzU2libGluZyIsImVsZW1lbnRQYXJlbnRzIiwicGFyZW50cyIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJlbGVtZW50VHJhbnNpdGlvbkVuZCIsImZpcmVDYWxsQmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiZWxlbWVudE91dGVyU2l6ZSIsInNpemUiLCJpbmNsdWRlTWFyZ2lucyIsIm9mZnNldFdpZHRoIiwibWFrZUVsZW1lbnRzQXJyYXkiLCJiIiwiZCIsImYiLCJoIiwiaiIsImsiLCJsIiwibSIsIm4iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/swiper-react.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/swiper-react.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Swiper: () => (/* binding */ Swiper),\n/* harmony export */   SwiperSlide: () => (/* binding */ SwiperSlide),\n/* harmony export */   useSwiper: () => (/* binding */ useSwiper),\n/* harmony export */   useSwiperSlide: () => (/* binding */ useSwiperSlide)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/swiper-core.mjs */ \"(ssr)/./node_modules/swiper/shared/swiper-core.mjs\");\n/* harmony import */ var _shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/update-on-virtual-data.mjs */ \"(ssr)/./node_modules/swiper/shared/update-on-virtual-data.mjs\");\n/* harmony import */ var _shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/update-swiper.mjs */ \"(ssr)/./node_modules/swiper/shared/update-swiper.mjs\");\n/**\n * Swiper React 11.1.1\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2024 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: April 9, 2024\n */ \n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction isChildSwiperSlide(child) {\n    return child.type && child.type.displayName && child.type.displayName.includes(\"SwiperSlide\");\n}\nfunction processChildren(c) {\n    const slides = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(c).forEach((child)=>{\n        if (isChildSwiperSlide(child)) {\n            slides.push(child);\n        } else if (child.props && child.props.children) {\n            processChildren(child.props.children).forEach((slide)=>slides.push(slide));\n        }\n    });\n    return slides;\n}\nfunction getChildren(c) {\n    const slides = [];\n    const slots = {\n        \"container-start\": [],\n        \"container-end\": [],\n        \"wrapper-start\": [],\n        \"wrapper-end\": []\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(c).forEach((child)=>{\n        if (isChildSwiperSlide(child)) {\n            slides.push(child);\n        } else if (child.props && child.props.slot && slots[child.props.slot]) {\n            slots[child.props.slot].push(child);\n        } else if (child.props && child.props.children) {\n            const foundSlides = processChildren(child.props.children);\n            if (foundSlides.length > 0) {\n                foundSlides.forEach((slide)=>slides.push(slide));\n            } else {\n                slots[\"container-end\"].push(child);\n            }\n        } else {\n            slots[\"container-end\"].push(child);\n        }\n    });\n    return {\n        slides,\n        slots\n    };\n}\nfunction renderVirtual(swiper, slides, virtualData) {\n    if (!virtualData) return null;\n    const getSlideIndex = (index)=>{\n        let slideIndex = index;\n        if (index < 0) {\n            slideIndex = slides.length + index;\n        } else if (slideIndex >= slides.length) {\n            // eslint-disable-next-line\n            slideIndex = slideIndex - slides.length;\n        }\n        return slideIndex;\n    };\n    const style = swiper.isHorizontal() ? {\n        [swiper.rtlTranslate ? \"right\" : \"left\"]: `${virtualData.offset}px`\n    } : {\n        top: `${virtualData.offset}px`\n    };\n    const { from, to } = virtualData;\n    const loopFrom = swiper.params.loop ? -slides.length : 0;\n    const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;\n    const slidesToRender = [];\n    for(let i = loopFrom; i < loopTo; i += 1){\n        if (i >= from && i <= to) {\n            slidesToRender.push(slides[getSlideIndex(i)]);\n        }\n    }\n    return slidesToRender.map((child, index)=>{\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, {\n            swiper,\n            style,\n            key: child.props.virtualIndex || child.key || `slide-${index}`\n        });\n    });\n}\nfunction useIsomorphicLayoutEffect(callback, deps) {\n    // eslint-disable-next-line\n    if (true) return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(callback, deps);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(callback, deps);\n}\nconst SwiperSlideContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst useSwiperSlide = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SwiperSlideContext);\n};\nconst SwiperContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst useSwiper = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SwiperContext);\n};\nconst Swiper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(_temp, externalElRef) {\n    let { className, tag: Tag = \"div\", wrapperTag: WrapperTag = \"div\", children, onSwiper, ...rest } = _temp === void 0 ? {} : _temp;\n    let eventsAssigned = false;\n    const [containerClasses, setContainerClasses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"swiper\");\n    const [virtualData, setVirtualData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [breakpointChanged, setBreakpointChanged] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const initializedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const swiperElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const swiperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const oldPassedParamsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const oldSlides = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const nextElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const prevElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const paginationElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const scrollbarElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { params: swiperParams, passedParams, rest: restProps, events } = (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(rest);\n    const { slides, slots } = getChildren(children);\n    const onBeforeBreakpoint = ()=>{\n        setBreakpointChanged(!breakpointChanged);\n    };\n    Object.assign(swiperParams.on, {\n        _containerClasses (swiper, classes) {\n            setContainerClasses(classes);\n        }\n    });\n    const initSwiper = ()=>{\n        // init swiper\n        Object.assign(swiperParams.on, events);\n        eventsAssigned = true;\n        const passParams = {\n            ...swiperParams\n        };\n        delete passParams.wrapperClass;\n        swiperRef.current = new _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__.S(passParams);\n        if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {\n            swiperRef.current.virtual.slides = slides;\n            const extendWith = {\n                cache: false,\n                slides,\n                renderExternal: setVirtualData,\n                renderExternalUpdate: false\n            };\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(swiperRef.current.params.virtual, extendWith);\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(swiperRef.current.originalParams.virtual, extendWith);\n        }\n    };\n    if (!swiperElRef.current) {\n        initSwiper();\n    }\n    // Listen for breakpoints change\n    if (swiperRef.current) {\n        swiperRef.current.on(\"_beforeBreakpoint\", onBeforeBreakpoint);\n    }\n    const attachEvents = ()=>{\n        if (eventsAssigned || !events || !swiperRef.current) return;\n        Object.keys(events).forEach((eventName)=>{\n            swiperRef.current.on(eventName, events[eventName]);\n        });\n    };\n    const detachEvents = ()=>{\n        if (!events || !swiperRef.current) return;\n        Object.keys(events).forEach((eventName)=>{\n            swiperRef.current.off(eventName, events[eventName]);\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (swiperRef.current) swiperRef.current.off(\"_beforeBreakpoint\", onBeforeBreakpoint);\n        };\n    });\n    // set initialized flag\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!initializedRef.current && swiperRef.current) {\n            swiperRef.current.emitSlidesClasses();\n            initializedRef.current = true;\n        }\n    });\n    // mount swiper\n    useIsomorphicLayoutEffect(()=>{\n        if (externalElRef) {\n            externalElRef.current = swiperElRef.current;\n        }\n        if (!swiperElRef.current) return;\n        if (swiperRef.current.destroyed) {\n            initSwiper();\n        }\n        (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.m)({\n            el: swiperElRef.current,\n            nextEl: nextElRef.current,\n            prevEl: prevElRef.current,\n            paginationEl: paginationElRef.current,\n            scrollbarEl: scrollbarElRef.current,\n            swiper: swiperRef.current\n        }, swiperParams);\n        if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);\n        // eslint-disable-next-line\n        return ()=>{\n            if (swiperRef.current && !swiperRef.current.destroyed) {\n                swiperRef.current.destroy(true, false);\n            }\n        };\n    }, []);\n    // watch for params change\n    useIsomorphicLayoutEffect(()=>{\n        attachEvents();\n        const changedParams = (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c)=>c.key);\n        oldPassedParamsRef.current = passedParams;\n        oldSlides.current = slides;\n        if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.u)({\n                swiper: swiperRef.current,\n                slides,\n                passedParams,\n                changedParams,\n                nextEl: nextElRef.current,\n                prevEl: prevElRef.current,\n                scrollbarEl: scrollbarElRef.current,\n                paginationEl: paginationElRef.current\n            });\n        }\n        return ()=>{\n            detachEvents();\n        };\n    });\n    // update on virtual update\n    useIsomorphicLayoutEffect(()=>{\n        (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(swiperRef.current);\n    }, [\n        virtualData\n    ]);\n    // bypass swiper instance to slides\n    function renderSlides() {\n        if (swiperParams.virtual) {\n            return renderVirtual(swiperRef.current, slides, virtualData);\n        }\n        return slides.map((child, index)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, {\n                swiper: swiperRef.current,\n                swiperSlideIndex: index\n            });\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, _extends({\n        ref: swiperElRef,\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.d)(`${containerClasses}${className ? ` ${className}` : \"\"}`)\n    }, restProps), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperContext.Provider, {\n        value: swiperRef.current\n    }, slots[\"container-start\"], /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrapperTag, {\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.w)(swiperParams.wrapperClass)\n    }, slots[\"wrapper-start\"], renderSlides(), slots[\"wrapper-end\"]), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.n)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: prevElRef,\n        className: \"swiper-button-prev\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: nextElRef,\n        className: \"swiper-button-next\"\n    })), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.b)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: scrollbarElRef,\n        className: \"swiper-scrollbar\"\n    }), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.a)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: paginationElRef,\n        className: \"swiper-pagination\"\n    }), slots[\"container-end\"]));\n});\nSwiper.displayName = \"Swiper\";\nconst SwiperSlide = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(_temp, externalRef) {\n    let { tag: Tag = \"div\", children, className = \"\", swiper, zoom, lazy, virtualIndex, swiperSlideIndex, ...rest } = _temp === void 0 ? {} : _temp;\n    const slideElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [slideClasses, setSlideClasses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"swiper-slide\");\n    const [lazyLoaded, setLazyLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    function updateClasses(_s, el, classNames) {\n        if (el === slideElRef.current) {\n            setSlideClasses(classNames);\n        }\n    }\n    useIsomorphicLayoutEffect(()=>{\n        if (typeof swiperSlideIndex !== \"undefined\") {\n            slideElRef.current.swiperSlideIndex = swiperSlideIndex;\n        }\n        if (externalRef) {\n            externalRef.current = slideElRef.current;\n        }\n        if (!slideElRef.current || !swiper) {\n            return;\n        }\n        if (swiper.destroyed) {\n            if (slideClasses !== \"swiper-slide\") {\n                setSlideClasses(\"swiper-slide\");\n            }\n            return;\n        }\n        swiper.on(\"_slideClass\", updateClasses);\n        // eslint-disable-next-line\n        return ()=>{\n            if (!swiper) return;\n            swiper.off(\"_slideClass\", updateClasses);\n        };\n    });\n    useIsomorphicLayoutEffect(()=>{\n        if (swiper && slideElRef.current && !swiper.destroyed) {\n            setSlideClasses(swiper.getSlideClasses(slideElRef.current));\n        }\n    }, [\n        swiper\n    ]);\n    const slideData = {\n        isActive: slideClasses.indexOf(\"swiper-slide-active\") >= 0,\n        isVisible: slideClasses.indexOf(\"swiper-slide-visible\") >= 0,\n        isPrev: slideClasses.indexOf(\"swiper-slide-prev\") >= 0,\n        isNext: slideClasses.indexOf(\"swiper-slide-next\") >= 0\n    };\n    const renderChildren = ()=>{\n        return typeof children === \"function\" ? children(slideData) : children;\n    };\n    const onLoad = ()=>{\n        setLazyLoaded(true);\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, _extends({\n        ref: slideElRef,\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.d)(`${slideClasses}${className ? ` ${className}` : \"\"}`),\n        \"data-swiper-slide-index\": virtualIndex,\n        onLoad: onLoad\n    }, rest), zoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperSlideContext.Provider, {\n        value: slideData\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-zoom-container\",\n        \"data-swiper-zoom\": typeof zoom === \"number\" ? zoom : undefined\n    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-lazy-preloader\"\n    }))), !zoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperSlideContext.Provider, {\n        value: slideData\n    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-lazy-preloader\"\n    })));\n});\nSwiperSlide.displayName = \"SwiperSlide\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBRWtIO0FBQzFEO0FBQytFO0FBQzRDO0FBRXBMLFNBQVM4QjtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsU0FBU1EsbUJBQW1CQyxLQUFLO0lBQy9CLE9BQU9BLE1BQU1DLElBQUksSUFBSUQsTUFBTUMsSUFBSSxDQUFDQyxXQUFXLElBQUlGLE1BQU1DLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxRQUFRLENBQUM7QUFDakY7QUFDQSxTQUFTQyxnQkFBZ0JDLENBQUM7SUFDeEIsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCbkQsMkNBQWMsQ0FBQ3FELE9BQU8sQ0FBQ0gsR0FBR0ksT0FBTyxDQUFDVCxDQUFBQTtRQUNoQyxJQUFJRCxtQkFBbUJDLFFBQVE7WUFDN0JNLE9BQU9JLElBQUksQ0FBQ1Y7UUFDZCxPQUFPLElBQUlBLE1BQU1XLEtBQUssSUFBSVgsTUFBTVcsS0FBSyxDQUFDQyxRQUFRLEVBQUU7WUFDOUNSLGdCQUFnQkosTUFBTVcsS0FBSyxDQUFDQyxRQUFRLEVBQUVILE9BQU8s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UUFDTGpFLFdBQVczRSw0REFBYUEsQ0FBQyxDQUFDLEVBQUU2SSxhQUFhLEVBQUVsRSxZQUFZLENBQUMsQ0FBQyxFQUFFQSxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUM7UUFDN0UsMkJBQTJCWDtRQUMzQjRGLFFBQVFBO0lBQ1YsR0FBRzNFLE9BQU95RCxRQUFRLFdBQVcsR0FBRTdKLGdEQUFtQixDQUFDdUYsbUJBQW1CaUUsUUFBUSxFQUFFO1FBQzlFQyxPQUFPZTtJQUNULEdBQUcsV0FBVyxHQUFFeEssZ0RBQW1CLENBQUMsT0FBTztRQUN6QzhGLFdBQVc7UUFDWCxvQkFBb0IsT0FBTytELFNBQVMsV0FBV0EsT0FBT21CO0lBQ3hELEdBQUdGLGtCQUFrQmhCLFFBQVEsQ0FBQ0ksY0FBYyxXQUFXLEdBQUVsSyxnREFBbUIsQ0FBQyxPQUFPO1FBQ2xGOEYsV0FBVztJQUNiLE1BQU0sQ0FBQytELFFBQVEsV0FBVyxHQUFFN0osZ0RBQW1CLENBQUN1RixtQkFBbUJpRSxRQUFRLEVBQUU7UUFDM0VDLE9BQU9lO0lBQ1QsR0FBR00sa0JBQWtCaEIsUUFBUSxDQUFDSSxjQUFjLFdBQVcsR0FBRWxLLGdEQUFtQixDQUFDLE9BQU87UUFDbEY4RixXQUFXO0lBQ2I7QUFDRjtBQUNBNkQsWUFBWTVHLFdBQVcsR0FBRztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmZvLW5leHQvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci1yZWFjdC5tanM/M2NkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN3aXBlciBSZWFjdCAxMS4xLjFcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXG4gKiBodHRwczovL3N3aXBlcmpzLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMjQgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBSZWxlYXNlZCBvbjogQXByaWwgOSwgMjAyNFxuICovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlQ29udGV4dCwgY3JlYXRlQ29udGV4dCwgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFMgYXMgU3dpcGVyJDEgfSBmcm9tICcuL3NoYXJlZC9zd2lwZXItY29yZS5tanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRQYXJhbXMsIG0gYXMgbW91bnRTd2lwZXIsIGEgYXMgZ2V0Q2hhbmdlZFBhcmFtcywgdSBhcyB1cGRhdGVPblZpcnR1YWxEYXRhIH0gZnJvbSAnLi9zaGFyZWQvdXBkYXRlLW9uLXZpcnR1YWwtZGF0YS5tanMnO1xuaW1wb3J0IHsgZCBhcyB1bmlxdWVDbGFzc2VzLCB3IGFzIHdyYXBwZXJDbGFzcywgbiBhcyBuZWVkc05hdmlnYXRpb24sIGIgYXMgbmVlZHNTY3JvbGxiYXIsIGEgYXMgbmVlZHNQYWdpbmF0aW9uLCBlIGFzIGV4dGVuZCwgdSBhcyB1cGRhdGVTd2lwZXIgfSBmcm9tICcuL3NoYXJlZC91cGRhdGUtc3dpcGVyLm1qcyc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBpc0NoaWxkU3dpcGVyU2xpZGUoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZS5kaXNwbGF5TmFtZSAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lLmluY2x1ZGVzKCdTd2lwZXJTbGlkZScpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkcmVuKGMpIHtcbiAgY29uc3Qgc2xpZGVzID0gW107XG4gIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoYykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgaWYgKGlzQ2hpbGRTd2lwZXJTbGlkZShjaGlsZCkpIHtcbiAgICAgIHNsaWRlcy5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBwcm9jZXNzQ2hpbGRyZW4oY2hpbGQucHJvcHMuY2hpbGRyZW4pLmZvckVhY2goc2xpZGUgPT4gc2xpZGVzLnB1c2goc2xpZGUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2xpZGVzO1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oYykge1xuICBjb25zdCBzbGlkZXMgPSBbXTtcbiAgY29uc3Qgc2xvdHMgPSB7XG4gICAgJ2NvbnRhaW5lci1zdGFydCc6IFtdLFxuICAgICdjb250YWluZXItZW5kJzogW10sXG4gICAgJ3dyYXBwZXItc3RhcnQnOiBbXSxcbiAgICAnd3JhcHBlci1lbmQnOiBbXVxuICB9O1xuICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGMpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGlmIChpc0NoaWxkU3dpcGVyU2xpZGUoY2hpbGQpKSB7XG4gICAgICBzbGlkZXMucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5zbG90ICYmIHNsb3RzW2NoaWxkLnByb3BzLnNsb3RdKSB7XG4gICAgICBzbG90c1tjaGlsZC5wcm9wcy5zbG90XS5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBmb3VuZFNsaWRlcyA9IHByb2Nlc3NDaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICBpZiAoZm91bmRTbGlkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3VuZFNsaWRlcy5mb3JFYWNoKHNsaWRlID0+IHNsaWRlcy5wdXNoKHNsaWRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90c1snY29udGFpbmVyLWVuZCddLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbG90c1snY29udGFpbmVyLWVuZCddLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2xpZGVzLFxuICAgIHNsb3RzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlclZpcnR1YWwoc3dpcGVyLCBzbGlkZXMsIHZpcnR1YWxEYXRhKSB7XG4gIGlmICghdmlydHVhbERhdGEpIHJldHVybiBudWxsO1xuICBjb25zdCBnZXRTbGlkZUluZGV4ID0gaW5kZXggPT4ge1xuICAgIGxldCBzbGlkZUluZGV4ID0gaW5kZXg7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgc2xpZGVJbmRleCA9IHNsaWRlcy5sZW5ndGggKyBpbmRleDtcbiAgICB9IGVsc2UgaWYgKHNsaWRlSW5kZXggPj0gc2xpZGVzLmxlbmd0aCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBzbGlkZUluZGV4ID0gc2xpZGVJbmRleCAtIHNsaWRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzbGlkZUluZGV4O1xuICB9O1xuICBjb25zdCBzdHlsZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHtcbiAgICBbc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/ICdyaWdodCcgOiAnbGVmdCddOiBgJHt2aXJ0dWFsRGF0YS5vZmZzZXR9cHhgXG4gIH0gOiB7XG4gICAgdG9wOiBgJHt2aXJ0dWFsRGF0YS5vZmZzZXR9cHhgXG4gIH07XG4gIGNvbnN0IHtcbiAgICBmcm9tLFxuICAgIHRvXG4gIH0gPSB2aXJ0dWFsRGF0YTtcbiAgY29uc3QgbG9vcEZyb20gPSBzd2lwZXIucGFyYW1zLmxvb3AgPyAtc2xpZGVzLmxlbmd0aCA6IDA7XG4gIGNvbnN0IGxvb3BUbyA9IHN3aXBlci5wYXJhbXMubG9vcCA/IHNsaWRlcy5sZW5ndGggKiAyIDogc2xpZGVzLmxlbmd0aDtcbiAgY29uc3Qgc2xpZGVzVG9SZW5kZXIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IGxvb3BGcm9tOyBpIDwgbG9vcFRvOyBpICs9IDEpIHtcbiAgICBpZiAoaSA+PSBmcm9tICYmIGkgPD0gdG8pIHtcbiAgICAgIHNsaWRlc1RvUmVuZGVyLnB1c2goc2xpZGVzW2dldFNsaWRlSW5kZXgoaSldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsaWRlc1RvUmVuZGVyLm1hcCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHN3aXBlcixcbiAgICAgIHN0eWxlLFxuICAgICAga2V5OiBjaGlsZC5wcm9wcy52aXJ0dWFsSW5kZXggfHwgY2hpbGQua2V5IHx8IGBzbGlkZS0ke2luZGV4fWBcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGRlcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVzZUVmZmVjdChjYWxsYmFjaywgZGVwcyk7XG4gIHJldHVybiB1c2VMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGRlcHMpO1xufVxuXG5jb25zdCBTd2lwZXJTbGlkZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHVzZVN3aXBlclNsaWRlID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChTd2lwZXJTbGlkZUNvbnRleHQpO1xufTtcbmNvbnN0IFN3aXBlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHVzZVN3aXBlciA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoU3dpcGVyQ29udGV4dCk7XG59O1xuXG5jb25zdCBTd2lwZXIgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAoX3RlbXAsIGV4dGVybmFsRWxSZWYpIHtcbiAgbGV0IHtcbiAgICBjbGFzc05hbWUsXG4gICAgdGFnOiBUYWcgPSAnZGl2JyxcbiAgICB3cmFwcGVyVGFnOiBXcmFwcGVyVGFnID0gJ2RpdicsXG4gICAgY2hpbGRyZW4sXG4gICAgb25Td2lwZXIsXG4gICAgLi4ucmVzdFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGxldCBldmVudHNBc3NpZ25lZCA9IGZhbHNlO1xuICBjb25zdCBbY29udGFpbmVyQ2xhc3Nlcywgc2V0Q29udGFpbmVyQ2xhc3Nlc10gPSB1c2VTdGF0ZSgnc3dpcGVyJyk7XG4gIGNvbnN0IFt2aXJ0dWFsRGF0YSwgc2V0VmlydHVhbERhdGFdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFticmVha3BvaW50Q2hhbmdlZCwgc2V0QnJlYWtwb2ludENoYW5nZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBpbml0aWFsaXplZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHN3aXBlckVsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzd2lwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9sZFBhc3NlZFBhcmFtc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2xkU2xpZGVzID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBuZXh0RWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByZXZFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcGFnaW5hdGlvbkVsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzY3JvbGxiYXJFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIHBhcmFtczogc3dpcGVyUGFyYW1zLFxuICAgIHBhc3NlZFBhcmFtcyxcbiAgICByZXN0OiByZXN0UHJvcHMsXG4gICAgZXZlbnRzXG4gIH0gPSBnZXRQYXJhbXMocmVzdCk7XG4gIGNvbnN0IHtcbiAgICBzbGlkZXMsXG4gICAgc2xvdHNcbiAgfSA9IGdldENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgY29uc3Qgb25CZWZvcmVCcmVha3BvaW50ID0gKCkgPT4ge1xuICAgIHNldEJyZWFrcG9pbnRDaGFuZ2VkKCFicmVha3BvaW50Q2hhbmdlZCk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyUGFyYW1zLm9uLCB7XG4gICAgX2NvbnRhaW5lckNsYXNzZXMoc3dpcGVyLCBjbGFzc2VzKSB7XG4gICAgICBzZXRDb250YWluZXJDbGFzc2VzKGNsYXNzZXMpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGluaXRTd2lwZXIgPSAoKSA9PiB7XG4gICAgLy8gaW5pdCBzd2lwZXJcbiAgICBPYmplY3QuYXNzaWduKHN3aXBlclBhcmFtcy5vbiwgZXZlbnRzKTtcbiAgICBldmVudHNBc3NpZ25lZCA9IHRydWU7XG4gICAgY29uc3QgcGFzc1BhcmFtcyA9IHtcbiAgICAgIC4uLnN3aXBlclBhcmFtc1xuICAgIH07XG4gICAgZGVsZXRlIHBhc3NQYXJhbXMud3JhcHBlckNsYXNzO1xuICAgIHN3aXBlclJlZi5jdXJyZW50ID0gbmV3IFN3aXBlciQxKHBhc3NQYXJhbXMpO1xuICAgIGlmIChzd2lwZXJSZWYuY3VycmVudC52aXJ0dWFsICYmIHN3aXBlclJlZi5jdXJyZW50LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICAgIHN3aXBlclJlZi5jdXJyZW50LnZpcnR1YWwuc2xpZGVzID0gc2xpZGVzO1xuICAgICAgY29uc3QgZXh0ZW5kV2l0aCA9IHtcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBzbGlkZXMsXG4gICAgICAgIHJlbmRlckV4dGVybmFsOiBzZXRWaXJ0dWFsRGF0YSxcbiAgICAgICAgcmVuZGVyRXh0ZXJuYWxVcGRhdGU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZXh0ZW5kKHN3aXBlclJlZi5jdXJyZW50LnBhcmFtcy52aXJ0dWFsLCBleHRlbmRXaXRoKTtcbiAgICAgIGV4dGVuZChzd2lwZXJSZWYuY3VycmVudC5vcmlnaW5hbFBhcmFtcy52aXJ0dWFsLCBleHRlbmRXaXRoKTtcbiAgICB9XG4gIH07XG4gIGlmICghc3dpcGVyRWxSZWYuY3VycmVudCkge1xuICAgIGluaXRTd2lwZXIoKTtcbiAgfVxuXG4gIC8vIExpc3RlbiBmb3IgYnJlYWtwb2ludHMgY2hhbmdlXG4gIGlmIChzd2lwZXJSZWYuY3VycmVudCkge1xuICAgIHN3aXBlclJlZi5jdXJyZW50Lm9uKCdfYmVmb3JlQnJlYWtwb2ludCcsIG9uQmVmb3JlQnJlYWtwb2ludCk7XG4gIH1cbiAgY29uc3QgYXR0YWNoRXZlbnRzID0gKCkgPT4ge1xuICAgIGlmIChldmVudHNBc3NpZ25lZCB8fCAhZXZlbnRzIHx8ICFzd2lwZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgc3dpcGVyUmVmLmN1cnJlbnQub24oZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGRldGFjaEV2ZW50cyA9ICgpID0+IHtcbiAgICBpZiAoIWV2ZW50cyB8fCAhc3dpcGVyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgIHN3aXBlclJlZi5jdXJyZW50Lm9mZihldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICB9KTtcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHN3aXBlclJlZi5jdXJyZW50KSBzd2lwZXJSZWYuY3VycmVudC5vZmYoJ19iZWZvcmVCcmVha3BvaW50Jywgb25CZWZvcmVCcmVha3BvaW50KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBzZXQgaW5pdGlhbGl6ZWQgZmxhZ1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW5pdGlhbGl6ZWRSZWYuY3VycmVudCAmJiBzd2lwZXJSZWYuY3VycmVudCkge1xuICAgICAgc3dpcGVyUmVmLmN1cnJlbnQuZW1pdFNsaWRlc0NsYXNzZXMoKTtcbiAgICAgIGluaXRpYWxpemVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gbW91bnQgc3dpcGVyXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChleHRlcm5hbEVsUmVmKSB7XG4gICAgICBleHRlcm5hbEVsUmVmLmN1cnJlbnQgPSBzd2lwZXJFbFJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoIXN3aXBlckVsUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyUmVmLmN1cnJlbnQuZGVzdHJveWVkKSB7XG4gICAgICBpbml0U3dpcGVyKCk7XG4gICAgfVxuICAgIG1vdW50U3dpcGVyKHtcbiAgICAgIGVsOiBzd2lwZXJFbFJlZi5jdXJyZW50LFxuICAgICAgbmV4dEVsOiBuZXh0RWxSZWYuY3VycmVudCxcbiAgICAgIHByZXZFbDogcHJldkVsUmVmLmN1cnJlbnQsXG4gICAgICBwYWdpbmF0aW9uRWw6IHBhZ2luYXRpb25FbFJlZi5jdXJyZW50LFxuICAgICAgc2Nyb2xsYmFyRWw6IHNjcm9sbGJhckVsUmVmLmN1cnJlbnQsXG4gICAgICBzd2lwZXI6IHN3aXBlclJlZi5jdXJyZW50XG4gICAgfSwgc3dpcGVyUGFyYW1zKTtcbiAgICBpZiAob25Td2lwZXIgJiYgIXN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3llZCkgb25Td2lwZXIoc3dpcGVyUmVmLmN1cnJlbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc3dpcGVyUmVmLmN1cnJlbnQgJiYgIXN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3llZCkge1xuICAgICAgICBzd2lwZXJSZWYuY3VycmVudC5kZXN0cm95KHRydWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gd2F0Y2ggZm9yIHBhcmFtcyBjaGFuZ2VcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYXR0YWNoRXZlbnRzKCk7XG4gICAgY29uc3QgY2hhbmdlZFBhcmFtcyA9IGdldENoYW5nZWRQYXJhbXMocGFzc2VkUGFyYW1zLCBvbGRQYXNzZWRQYXJhbXNSZWYuY3VycmVudCwgc2xpZGVzLCBvbGRTbGlkZXMuY3VycmVudCwgYyA9PiBjLmtleSk7XG4gICAgb2xkUGFzc2VkUGFyYW1zUmVmLmN1cnJlbnQgPSBwYXNzZWRQYXJhbXM7XG4gICAgb2xkU2xpZGVzLmN1cnJlbnQgPSBzbGlkZXM7XG4gICAgaWYgKGNoYW5nZWRQYXJhbXMubGVuZ3RoICYmIHN3aXBlclJlZi5jdXJyZW50ICYmICFzd2lwZXJSZWYuY3VycmVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHVwZGF0ZVN3aXBlcih7XG4gICAgICAgIHN3aXBlcjogc3dpcGVyUmVmLmN1cnJlbnQsXG4gICAgICAgIHNsaWRlcyxcbiAgICAgICAgcGFzc2VkUGFyYW1zLFxuICAgICAgICBjaGFuZ2VkUGFyYW1zLFxuICAgICAgICBuZXh0RWw6IG5leHRFbFJlZi5jdXJyZW50LFxuICAgICAgICBwcmV2RWw6IHByZXZFbFJlZi5jdXJyZW50LFxuICAgICAgICBzY3JvbGxiYXJFbDogc2Nyb2xsYmFyRWxSZWYuY3VycmVudCxcbiAgICAgICAgcGFnaW5hdGlvbkVsOiBwYWdpbmF0aW9uRWxSZWYuY3VycmVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZXRhY2hFdmVudHMoKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyB1cGRhdGUgb24gdmlydHVhbCB1cGRhdGVcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdXBkYXRlT25WaXJ0dWFsRGF0YShzd2lwZXJSZWYuY3VycmVudCk7XG4gIH0sIFt2aXJ0dWFsRGF0YV0pO1xuXG4gIC8vIGJ5cGFzcyBzd2lwZXIgaW5zdGFuY2UgdG8gc2xpZGVzXG4gIGZ1bmN0aW9uIHJlbmRlclNsaWRlcygpIHtcbiAgICBpZiAoc3dpcGVyUGFyYW1zLnZpcnR1YWwpIHtcbiAgICAgIHJldHVybiByZW5kZXJWaXJ0dWFsKHN3aXBlclJlZi5jdXJyZW50LCBzbGlkZXMsIHZpcnR1YWxEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWRlcy5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgc3dpcGVyOiBzd2lwZXJSZWYuY3VycmVudCxcbiAgICAgICAgc3dpcGVyU2xpZGVJbmRleDogaW5kZXhcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHtcbiAgICByZWY6IHN3aXBlckVsUmVmLFxuICAgIGNsYXNzTmFtZTogdW5pcXVlQ2xhc3NlcyhgJHtjb250YWluZXJDbGFzc2VzfSR7Y2xhc3NOYW1lID8gYCAke2NsYXNzTmFtZX1gIDogJyd9YClcbiAgfSwgcmVzdFByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3dpcGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzd2lwZXJSZWYuY3VycmVudFxuICB9LCBzbG90c1snY29udGFpbmVyLXN0YXJ0J10sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXJUYWcsIHtcbiAgICBjbGFzc05hbWU6IHdyYXBwZXJDbGFzcyhzd2lwZXJQYXJhbXMud3JhcHBlckNsYXNzKVxuICB9LCBzbG90c1snd3JhcHBlci1zdGFydCddLCByZW5kZXJTbGlkZXMoKSwgc2xvdHNbJ3dyYXBwZXItZW5kJ10pLCBuZWVkc05hdmlnYXRpb24oc3dpcGVyUGFyYW1zKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogcHJldkVsUmVmLFxuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItYnV0dG9uLXByZXZcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogbmV4dEVsUmVmLFxuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItYnV0dG9uLW5leHRcIlxuICB9KSksIG5lZWRzU2Nyb2xsYmFyKHN3aXBlclBhcmFtcykgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogc2Nyb2xsYmFyRWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1zY3JvbGxiYXJcIlxuICB9KSwgbmVlZHNQYWdpbmF0aW9uKHN3aXBlclBhcmFtcykgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogcGFnaW5hdGlvbkVsUmVmLFxuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItcGFnaW5hdGlvblwiXG4gIH0pLCBzbG90c1snY29udGFpbmVyLWVuZCddKSk7XG59KTtcblN3aXBlci5kaXNwbGF5TmFtZSA9ICdTd2lwZXInO1xuXG5jb25zdCBTd2lwZXJTbGlkZSA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChfdGVtcCwgZXh0ZXJuYWxSZWYpIHtcbiAgbGV0IHtcbiAgICB0YWc6IFRhZyA9ICdkaXYnLFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZSA9ICcnLFxuICAgIHN3aXBlcixcbiAgICB6b29tLFxuICAgIGxhenksXG4gICAgdmlydHVhbEluZGV4LFxuICAgIHN3aXBlclNsaWRlSW5kZXgsXG4gICAgLi4ucmVzdFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IHNsaWRlRWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtzbGlkZUNsYXNzZXMsIHNldFNsaWRlQ2xhc3Nlc10gPSB1c2VTdGF0ZSgnc3dpcGVyLXNsaWRlJyk7XG4gIGNvbnN0IFtsYXp5TG9hZGVkLCBzZXRMYXp5TG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyhfcywgZWwsIGNsYXNzTmFtZXMpIHtcbiAgICBpZiAoZWwgPT09IHNsaWRlRWxSZWYuY3VycmVudCkge1xuICAgICAgc2V0U2xpZGVDbGFzc2VzKGNsYXNzTmFtZXMpO1xuICAgIH1cbiAgfVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHN3aXBlclNsaWRlSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzbGlkZUVsUmVmLmN1cnJlbnQuc3dpcGVyU2xpZGVJbmRleCA9IHN3aXBlclNsaWRlSW5kZXg7XG4gICAgfVxuICAgIGlmIChleHRlcm5hbFJlZikge1xuICAgICAgZXh0ZXJuYWxSZWYuY3VycmVudCA9IHNsaWRlRWxSZWYuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKCFzbGlkZUVsUmVmLmN1cnJlbnQgfHwgIXN3aXBlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLmRlc3Ryb3llZCkge1xuICAgICAgaWYgKHNsaWRlQ2xhc3NlcyAhPT0gJ3N3aXBlci1zbGlkZScpIHtcbiAgICAgICAgc2V0U2xpZGVDbGFzc2VzKCdzd2lwZXItc2xpZGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpcGVyLm9uKCdfc2xpZGVDbGFzcycsIHVwZGF0ZUNsYXNzZXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXN3aXBlcikgcmV0dXJuO1xuICAgICAgc3dpcGVyLm9mZignX3NsaWRlQ2xhc3MnLCB1cGRhdGVDbGFzc2VzKTtcbiAgICB9O1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHN3aXBlciAmJiBzbGlkZUVsUmVmLmN1cnJlbnQgJiYgIXN3aXBlci5kZXN0cm95ZWQpIHtcbiAgICAgIHNldFNsaWRlQ2xhc3Nlcyhzd2lwZXIuZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWxSZWYuY3VycmVudCkpO1xuICAgIH1cbiAgfSwgW3N3aXBlcl0pO1xuICBjb25zdCBzbGlkZURhdGEgPSB7XG4gICAgaXNBY3RpdmU6IHNsaWRlQ2xhc3Nlcy5pbmRleE9mKCdzd2lwZXItc2xpZGUtYWN0aXZlJykgPj0gMCxcbiAgICBpc1Zpc2libGU6IHNsaWRlQ2xhc3Nlcy5pbmRleE9mKCdzd2lwZXItc2xpZGUtdmlzaWJsZScpID49IDAsXG4gICAgaXNQcmV2OiBzbGlkZUNsYXNzZXMuaW5kZXhPZignc3dpcGVyLXNsaWRlLXByZXYnKSA+PSAwLFxuICAgIGlzTmV4dDogc2xpZGVDbGFzc2VzLmluZGV4T2YoJ3N3aXBlci1zbGlkZS1uZXh0JykgPj0gMFxuICB9O1xuICBjb25zdCByZW5kZXJDaGlsZHJlbiA9ICgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oc2xpZGVEYXRhKSA6IGNoaWxkcmVuO1xuICB9O1xuICBjb25zdCBvbkxvYWQgPSAoKSA9PiB7XG4gICAgc2V0TGF6eUxvYWRlZCh0cnVlKTtcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe1xuICAgIHJlZjogc2xpZGVFbFJlZixcbiAgICBjbGFzc05hbWU6IHVuaXF1ZUNsYXNzZXMoYCR7c2xpZGVDbGFzc2VzfSR7Y2xhc3NOYW1lID8gYCAke2NsYXNzTmFtZX1gIDogJyd9YCksXG4gICAgXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiOiB2aXJ0dWFsSW5kZXgsXG4gICAgb25Mb2FkOiBvbkxvYWRcbiAgfSwgcmVzdCksIHpvb20gJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3dpcGVyU2xpZGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHNsaWRlRGF0YVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci16b29tLWNvbnRhaW5lclwiLFxuICAgIFwiZGF0YS1zd2lwZXItem9vbVwiOiB0eXBlb2Ygem9vbSA9PT0gJ251bWJlcicgPyB6b29tIDogdW5kZWZpbmVkXG4gIH0sIHJlbmRlckNoaWxkcmVuKCksIGxhenkgJiYgIWxhenlMb2FkZWQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItbGF6eS1wcmVsb2FkZXJcIlxuICB9KSkpLCAhem9vbSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTd2lwZXJTbGlkZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2xpZGVEYXRhXG4gIH0sIHJlbmRlckNoaWxkcmVuKCksIGxhenkgJiYgIWxhenlMb2FkZWQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItbGF6eS1wcmVsb2FkZXJcIlxuICB9KSkpO1xufSk7XG5Td2lwZXJTbGlkZS5kaXNwbGF5TmFtZSA9ICdTd2lwZXJTbGlkZSc7XG5cbmV4cG9ydCB7IFN3aXBlciwgU3dpcGVyU2xpZGUsIHVzZVN3aXBlciwgdXNlU3dpcGVyU2xpZGUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZm9yd2FyZFJlZiIsInVzZVN0YXRlIiwidXNlUmVmIiwiUyIsIlN3aXBlciQxIiwiZyIsImdldFBhcmFtcyIsIm0iLCJtb3VudFN3aXBlciIsImEiLCJnZXRDaGFuZ2VkUGFyYW1zIiwidSIsInVwZGF0ZU9uVmlydHVhbERhdGEiLCJkIiwidW5pcXVlQ2xhc3NlcyIsInciLCJ3cmFwcGVyQ2xhc3MiLCJuIiwibmVlZHNOYXZpZ2F0aW9uIiwiYiIsIm5lZWRzU2Nyb2xsYmFyIiwibmVlZHNQYWdpbmF0aW9uIiwiZSIsImV4dGVuZCIsInVwZGF0ZVN3aXBlciIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsImlzQ2hpbGRTd2lwZXJTbGlkZSIsImNoaWxkIiwidHlwZSIsImRpc3BsYXlOYW1lIiwiaW5jbHVkZXMiLCJwcm9jZXNzQ2hpbGRyZW4iLCJjIiwic2xpZGVzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiZm9yRWFjaCIsInB1c2giLCJwcm9wcyIsImNoaWxkcmVuIiwic2xpZGUiLCJnZXRDaGlsZHJlbiIsInNsb3RzIiwic2xvdCIsImZvdW5kU2xpZGVzIiwicmVuZGVyVmlydHVhbCIsInN3aXBlciIsInZpcnR1YWxEYXRhIiwiZ2V0U2xpZGVJbmRleCIsImluZGV4Iiwic2xpZGVJbmRleCIsInN0eWxlIiwiaXNIb3Jpem9udGFsIiwicnRsVHJhbnNsYXRlIiwib2Zmc2V0IiwidG9wIiwiZnJvbSIsInRvIiwibG9vcEZyb20iLCJwYXJhbXMiLCJsb29wIiwibG9vcFRvIiwic2xpZGVzVG9SZW5kZXIiLCJtYXAiLCJjbG9uZUVsZW1lbnQiLCJ2aXJ0dWFsSW5kZXgiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY2FsbGJhY2siLCJkZXBzIiwiU3dpcGVyU2xpZGVDb250ZXh0IiwidXNlU3dpcGVyU2xpZGUiLCJTd2lwZXJDb250ZXh0IiwidXNlU3dpcGVyIiwiU3dpcGVyIiwiX3RlbXAiLCJleHRlcm5hbEVsUmVmIiwiY2xhc3NOYW1lIiwidGFnIiwiVGFnIiwid3JhcHBlclRhZyIsIldyYXBwZXJUYWciLCJvblN3aXBlciIsInJlc3QiLCJldmVudHNBc3NpZ25lZCIsImNvbnRhaW5lckNsYXNzZXMiLCJzZXRDb250YWluZXJDbGFzc2VzIiwic2V0VmlydHVhbERhdGEiLCJicmVha3BvaW50Q2hhbmdlZCIsInNldEJyZWFrcG9pbnRDaGFuZ2VkIiwiaW5pdGlhbGl6ZWRSZWYiLCJzd2lwZXJFbFJlZiIsInN3aXBlclJlZiIsIm9sZFBhc3NlZFBhcmFtc1JlZiIsIm9sZFNsaWRlcyIsIm5leHRFbFJlZiIsInByZXZFbFJlZiIsInBhZ2luYXRpb25FbFJlZiIsInNjcm9sbGJhckVsUmVmIiwic3dpcGVyUGFyYW1zIiwicGFzc2VkUGFyYW1zIiwicmVzdFByb3BzIiwiZXZlbnRzIiwib25CZWZvcmVCcmVha3BvaW50Iiwib24iLCJfY29udGFpbmVyQ2xhc3NlcyIsImNsYXNzZXMiLCJpbml0U3dpcGVyIiwicGFzc1BhcmFtcyIsImN1cnJlbnQiLCJ2aXJ0dWFsIiwiZW5hYmxlZCIsImV4dGVuZFdpdGgiLCJjYWNoZSIsInJlbmRlckV4dGVybmFsIiwicmVuZGVyRXh0ZXJuYWxVcGRhdGUiLCJvcmlnaW5hbFBhcmFtcyIsImF0dGFjaEV2ZW50cyIsImtleXMiLCJldmVudE5hbWUiLCJkZXRhY2hFdmVudHMiLCJvZmYiLCJlbWl0U2xpZGVzQ2xhc3NlcyIsImRlc3Ryb3llZCIsImVsIiwibmV4dEVsIiwicHJldkVsIiwicGFnaW5hdGlvbkVsIiwic2Nyb2xsYmFyRWwiLCJkZXN0cm95IiwiY2hhbmdlZFBhcmFtcyIsInJlbmRlclNsaWRlcyIsInN3aXBlclNsaWRlSW5kZXgiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIkZyYWdtZW50IiwiU3dpcGVyU2xpZGUiLCJleHRlcm5hbFJlZiIsInpvb20iLCJsYXp5Iiwic2xpZGVFbFJlZiIsInNsaWRlQ2xhc3NlcyIsInNldFNsaWRlQ2xhc3NlcyIsImxhenlMb2FkZWQiLCJzZXRMYXp5TG9hZGVkIiwidXBkYXRlQ2xhc3NlcyIsIl9zIiwiY2xhc3NOYW1lcyIsImdldFNsaWRlQ2xhc3NlcyIsInNsaWRlRGF0YSIsImlzQWN0aXZlIiwiaW5kZXhPZiIsImlzVmlzaWJsZSIsImlzUHJldiIsImlzTmV4dCIsInJlbmRlckNoaWxkcmVuIiwib25Mb2FkIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/swiper-react.mjs\n");

/***/ })

};
;